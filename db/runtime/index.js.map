{
  "version": 3,
  "sources": ["../../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js", "../../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js", "../../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js", "../../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js", "../../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js", "../../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js", "../../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js", "../../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js", "../../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js", "../../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js", "../../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js", "../../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js", "../../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js", "../../generator-helper/src/byline.ts", "../../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js", "../../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js", "../../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js", "../../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js", "../../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js", "../../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js", "../../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js", "../../../node_modules/.pnpm/chalk@4.1.0/node_modules/chalk/source/util.js", "../../../node_modules/.pnpm/chalk@4.1.0/node_modules/chalk/source/templates.js", "../../../node_modules/.pnpm/chalk@4.1.0/node_modules/chalk/source/index.js", "../../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js", "../../../node_modules/.pnpm/debug@4.2.0/node_modules/debug/src/common.js", "../../../node_modules/.pnpm/debug@4.2.0/node_modules/debug/src/browser.js", "../../../node_modules/.pnpm/debug@4.2.0/node_modules/debug/src/node.js", "../../../node_modules/.pnpm/debug@4.2.0/node_modules/debug/src/index.js", "../../generator-helper/src/GeneratorProcess.ts", "../../generator-helper/src/generatorHandler.ts", "../../generator-helper/dist/types.js", "../../generator-helper/src/dmmf.ts", "../../generator-helper/src/index.ts", "../../../node_modules/.pnpm/indent-string@4.0.0/node_modules/indent-string/index.js", "../../../node_modules/.pnpm/js-levenshtein@1.1.6/node_modules/js-levenshtein/index.js", "../../../node_modules/.pnpm/ansi-regex@5.0.0/node_modules/ansi-regex/index.js", "../../../node_modules/.pnpm/strip-ansi@6.0.0/node_modules/strip-ansi/index.js", "../../../node_modules/.pnpm/is-regexp@2.1.0/node_modules/is-regexp/index.js", "../../../node_modules/.pnpm/is-obj@2.0.0/node_modules/is-obj/index.js", "../../../node_modules/.pnpm/get-own-enumerable-property-symbols@3.0.2/node_modules/get-own-enumerable-property-symbols/src/index.ts", "../../../node_modules/.pnpm/stacktrace-parser@0.1.10/node_modules/stacktrace-parser/dist/stack-trace-parser.cjs.js", "../../../node_modules/.pnpm/min-indent@1.0.1/node_modules/min-indent/index.js", "../../../node_modules/.pnpm/strip-indent@3.0.0/node_modules/strip-indent/index.js", "../../../node_modules/.pnpm/debug@4.1.1/node_modules/debug/src/common.js", "../../../node_modules/.pnpm/debug@4.1.1/node_modules/debug/src/browser.js", "../../../node_modules/.pnpm/debug@4.1.1/node_modules/debug/src/node.js", "../../../node_modules/.pnpm/debug@4.1.1/node_modules/debug/src/index.js", "../../debug/src/index.ts", "../../engine-core/src/log.ts", "../../../node_modules/.pnpm/ansi-escapes@4.3.1/node_modules/ansi-escapes/index.js", "../../../node_modules/.pnpm/supports-color@7.1.0/node_modules/supports-color/index.js", "../../../node_modules/.pnpm/supports-hyperlinks@2.1.0/node_modules/supports-hyperlinks/index.js", "../../../node_modules/.pnpm/terminal-link@2.1.1/node_modules/terminal-link/index.js", "../../../node_modules/.pnpm/new-github-issue-url@0.2.1/node_modules/new-github-issue-url/index.js", "../../engine-core/src/util.ts", "../../engine-core/src/Engine.ts", "../../../node_modules/.pnpm/@prisma/engines-version@2.10.0-cfabfaf0c4524c099dc3da4abcc4cffc17ae0365/node_modules/@prisma/engines-version/index.js", "../../../node_modules/.pnpm/@prisma/engines@2.10.0-cfabfaf0c4524c099dc3da4abcc4cffc17ae0365/node_modules/@prisma/engines/src/index.ts", "../../get-platform/src/getPlatform.ts", "../../get-platform/src/platforms.ts", "../../get-platform/src/index.ts", "../../engine-core/src/printGeneratorConfig.ts", "../../engine-core/src/byline.ts", "../../../node_modules/.pnpm/retry@0.12.0/node_modules/retry/lib/retry_operation.js", "../../../node_modules/.pnpm/retry@0.12.0/node_modules/retry/lib/retry.js", "../../../node_modules/.pnpm/retry@0.12.0/node_modules/retry/index.js", "../../../node_modules/.pnpm/p-retry@4.2.0/node_modules/p-retry/index.js", "../../../node_modules/.pnpm/strip-final-newline@2.0.0/node_modules/strip-final-newline/index.js", "../../../node_modules/.pnpm/npm-run-path@4.0.1/node_modules/npm-run-path/index.js", "../../../node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js", "../../../node_modules/.pnpm/onetime@5.1.0/node_modules/onetime/index.js", "../../../node_modules/.pnpm/human-signals@1.1.1/node_modules/human-signals/src/core.js", "../../../node_modules/.pnpm/human-signals@1.1.1/node_modules/human-signals/src/realtime.js", "../../../node_modules/.pnpm/human-signals@1.1.1/node_modules/human-signals/src/signals.js", "../../../node_modules/.pnpm/human-signals@1.1.1/node_modules/human-signals/src/main.js", "../../../node_modules/.pnpm/execa@4.0.2/node_modules/execa/lib/error.js", "../../../node_modules/.pnpm/execa@4.0.2/node_modules/execa/lib/stdio.js", "../../../node_modules/.pnpm/signal-exit@3.0.3/node_modules/signal-exit/signals.js", "../../../node_modules/.pnpm/signal-exit@3.0.3/node_modules/signal-exit/index.js", "../../../node_modules/.pnpm/execa@4.0.2/node_modules/execa/lib/kill.js", "../../../node_modules/.pnpm/is-stream@2.0.0/node_modules/is-stream/index.js", "../../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js", "../../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js", "../../../node_modules/.pnpm/end-of-stream@1.4.4/node_modules/end-of-stream/index.js", "../../../node_modules/.pnpm/pump@3.0.0/node_modules/pump/index.js", "../../../node_modules/.pnpm/get-stream@5.1.0/node_modules/get-stream/buffer-stream.js", "../../../node_modules/.pnpm/get-stream@5.1.0/node_modules/get-stream/index.js", "../../../node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js", "../../../node_modules/.pnpm/execa@4.0.2/node_modules/execa/lib/stream.js", "../../../node_modules/.pnpm/execa@4.0.2/node_modules/execa/lib/promise.js", "../../../node_modules/.pnpm/execa@4.0.2/node_modules/execa/lib/command.js", "../../../node_modules/.pnpm/execa@4.0.2/node_modules/execa/index.js", "../../engine-core/src/omit.ts", "../../../node_modules/.pnpm/get-stream@6.0.0/node_modules/get-stream/buffer-stream.js", "../../../node_modules/.pnpm/get-stream@6.0.0/node_modules/get-stream/index.js", "../../../node_modules/.pnpm/undici@2.0.7/node_modules/undici/lib/node/http-parser.js", "../../../node_modules/.pnpm/undici@2.0.7/node_modules/undici/lib/core/symbols.js", "../../../node_modules/.pnpm/undici@2.0.7/node_modules/undici/lib/core/util.js", "../../../node_modules/.pnpm/undici@2.0.7/node_modules/undici/lib/core/errors.js", "../../../node_modules/.pnpm/undici@2.0.7/node_modules/undici/lib/core/request.js", "../../../node_modules/.pnpm/undici@2.0.7/node_modules/undici/lib/core/client.js", "../../../node_modules/.pnpm/undici@2.0.7/node_modules/undici/lib/node/fixed-queue.js", "../../../node_modules/.pnpm/undici@2.0.7/node_modules/undici/lib/pool.js", "../../../node_modules/.pnpm/undici@2.0.7/node_modules/undici/lib/abort-signal.js", "../../../node_modules/.pnpm/undici@2.0.7/node_modules/undici/lib/client-request.js", "../../../node_modules/.pnpm/undici@2.0.7/node_modules/undici/lib/client-stream.js", "../../../node_modules/.pnpm/undici@2.0.7/node_modules/undici/lib/client-pipeline.js", "../../../node_modules/.pnpm/undici@2.0.7/node_modules/undici/lib/client-upgrade.js", "../../../node_modules/.pnpm/undici@2.0.7/node_modules/undici/lib/client-connect.js", "../../../node_modules/.pnpm/undici@2.0.7/node_modules/undici/index.js", "../../engine-core/src/undici.ts", "../../engine-core/src/NodeEngine.ts", "../../engine-core/src/getInternalDatamodelJson.ts", "../../engine-core/src/index.ts", "../../../node_modules/.pnpm/sql-template-tag@3.4.0/node_modules/sql-template-tag/src/index.ts", "../../../node_modules/.pnpm/dotenv@8.2.0/node_modules/dotenv/lib/main.js", "../../sdk/src/dotenvExpand.ts", "../../sdk/src/utils/mapPreviewFeatures.ts", "../src/runtime/index.ts", "../src/runtime/dmmf-types.ts", "../src/runtime/utils/common.ts", "../../../node_modules/.pnpm/decimal.js@10.2.1/node_modules/decimal.js/decimal.mjs", "../src/runtime/utils/common.ts", "../src/runtime/utils/common.ts", "../src/runtime/utils/common.ts", "../src/runtime/utils/common.ts", "../src/runtime/utils/common.ts", "../src/runtime/dmmf.ts", "../src/runtime/query.ts", "../src/runtime/utils/deep-extend.ts", "../src/runtime/utils/deep-set.ts", "../src/runtime/utils/filterObject.ts", "../src/runtime/utils/omit.ts", "../src/runtime/utils/printJsonErrors.ts", "../src/runtime/utils/stringifyObject.ts", "../src/runtime/utils/printJsonErrors.ts", "../src/runtime/utils/printStack.ts", "../src/runtime/highlight/theme.ts", "../src/runtime/highlight/prism.ts", "../src/runtime/highlight/highlight.ts", "../src/runtime/utils/dedent.ts", "../src/runtime/utils/printStack.ts", "../src/runtime/query.ts", "../src/runtime/utils/flatMap.ts", "../src/runtime/query.ts", "../src/runtime/query.ts", "../src/runtime/getPrismaClient.ts", "../src/runtime/getPrismaClient.ts", "../src/runtime/getLogLevel.ts", "../src/runtime/mergeBy.ts", "../src/runtime/Dataloader.ts", "../src/runtime/getPrismaClient.ts", "../src/runtime/getPrismaClient.ts", "../src/runtime/utils/serializeRawParameters.ts", "../src/runtime/getPrismaClient.ts", "../src/runtime/utils/clientVersion.ts", "../src/runtime/utils/mssqlPreparedStatement.ts", "../src/runtime/getPrismaClient.ts"],
  "sourcesContent": ["module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction checkPathExt (path, options) {\n  var pathext = options.pathExt !== undefined ?\n    options.pathExt : process.env.PATHEXT\n\n  if (!pathext) {\n    return true\n  }\n\n  pathext = pathext.split(';')\n  if (pathext.indexOf('') !== -1) {\n    return true\n  }\n  for (var i = 0; i < pathext.length; i++) {\n    var p = pathext[i].toLowerCase()\n    if (p && path.substr(-p.length).toLowerCase() === p) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction checkStat (stat, path, options) {\n  if (!stat.isSymbolicLink() && !stat.isFile()) {\n    return false\n  }\n  return checkPathExt(path, options)\n}\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, path, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), path, options)\n}\n", "module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), options)\n}\n\nfunction checkStat (stat, options) {\n  return stat.isFile() && checkMode(stat, options)\n}\n\nfunction checkMode (stat, options) {\n  var mod = stat.mode\n  var uid = stat.uid\n  var gid = stat.gid\n\n  var myUid = options.uid !== undefined ?\n    options.uid : process.getuid && process.getuid()\n  var myGid = options.gid !== undefined ?\n    options.gid : process.getgid && process.getgid()\n\n  var u = parseInt('100', 8)\n  var g = parseInt('010', 8)\n  var o = parseInt('001', 8)\n  var ug = u | g\n\n  var ret = (mod & o) ||\n    (mod & g) && gid === myGid ||\n    (mod & u) && uid === myUid ||\n    (mod & ug) && myUid === 0\n\n  return ret\n}\n", "var fs = require('fs')\nvar core\nif (process.platform === 'win32' || global.TESTING_WINDOWS) {\n  core = require('./windows.js')\n} else {\n  core = require('./mode.js')\n}\n\nmodule.exports = isexe\nisexe.sync = sync\n\nfunction isexe (path, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  if (!cb) {\n    if (typeof Promise !== 'function') {\n      throw new TypeError('callback not provided')\n    }\n\n    return new Promise(function (resolve, reject) {\n      isexe(path, options || {}, function (er, is) {\n        if (er) {\n          reject(er)\n        } else {\n          resolve(is)\n        }\n      })\n    })\n  }\n\n  core(path, options || {}, function (er, is) {\n    // ignore EACCES because that just means we aren't allowed to run it\n    if (er) {\n      if (er.code === 'EACCES' || options && options.ignoreErrors) {\n        er = null\n        is = false\n      }\n    }\n    cb(er, is)\n  })\n}\n\nfunction sync (path, options) {\n  // my kingdom for a filtered catch\n  try {\n    return core.sync(path, options || {})\n  } catch (er) {\n    if (options && options.ignoreErrors || er.code === 'EACCES') {\n      return false\n    } else {\n      throw er\n    }\n  }\n}\n", "const isWindows = process.platform === 'win32' ||\n    process.env.OSTYPE === 'cygwin' ||\n    process.env.OSTYPE === 'msys'\n\nconst path = require('path')\nconst COLON = isWindows ? ';' : ':'\nconst isexe = require('isexe')\n\nconst getNotFoundError = (cmd) =>\n  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })\n\nconst getPathInfo = (cmd, opt) => {\n  const colon = opt.colon || COLON\n\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? ['']\n    : (\n      [\n        // windows always checks the cwd first\n        ...(isWindows ? [process.cwd()] : []),\n        ...(opt.path || process.env.PATH ||\n          /* istanbul ignore next: very unusual */ '').split(colon),\n      ]\n    )\n  const pathExtExe = isWindows\n    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'\n    : ''\n  const pathExt = isWindows ? pathExtExe.split(colon) : ['']\n\n  if (isWindows) {\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\n      pathExt.unshift('')\n  }\n\n  return {\n    pathEnv,\n    pathExt,\n    pathExtExe,\n  }\n}\n\nconst which = (cmd, opt, cb) => {\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n  if (!opt)\n    opt = {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  const step = i => new Promise((resolve, reject) => {\n    if (i === pathEnv.length)\n      return opt.all && found.length ? resolve(found)\n        : reject(getNotFoundError(cmd))\n\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    resolve(subStep(p, i, 0))\n  })\n\n  const subStep = (p, i, ii) => new Promise((resolve, reject) => {\n    if (ii === pathExt.length)\n      return resolve(step(i + 1))\n    const ext = pathExt[ii]\n    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {\n      if (!er && is) {\n        if (opt.all)\n          found.push(p + ext)\n        else\n          return resolve(p + ext)\n      }\n      return resolve(subStep(p, i, ii + 1))\n    })\n  })\n\n  return cb ? step(0).then(res => cb(null, res), cb) : step(0)\n}\n\nconst whichSync = (cmd, opt) => {\n  opt = opt || {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (let i = 0; i < pathEnv.length; i ++) {\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    for (let j = 0; j < pathExt.length; j ++) {\n      const cur = p + pathExt[j]\n      try {\n        const is = isexe.sync(cur, { pathExt: pathExtExe })\n        if (is) {\n          if (opt.all)\n            found.push(cur)\n          else\n            return cur\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length)\n    return found\n\n  if (opt.nothrow)\n    return null\n\n  throw getNotFoundError(cmd)\n}\n\nmodule.exports = which\nwhich.sync = whichSync\n", "'use strict';\n\nconst pathKey = (options = {}) => {\n\tconst environment = options.env || process.env;\n\tconst platform = options.platform || process.platform;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';\n};\n\nmodule.exports = pathKey;\n// TODO: Remove this for the next major release\nmodule.exports.default = pathKey;\n", "'use strict';\n\nconst path = require('path');\nconst which = require('which');\nconst getPathKey = require('path-key');\n\nfunction resolveCommandAttempt(parsed, withoutPathExt) {\n    const env = parsed.options.env || process.env;\n    const cwd = process.cwd();\n    const hasCustomCwd = parsed.options.cwd != null;\n    // Worker threads do not have process.chdir()\n    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;\n\n    // If a custom `cwd` was specified, we need to change the process cwd\n    // because `which` will do stat calls but does not support a custom cwd\n    if (shouldSwitchCwd) {\n        try {\n            process.chdir(parsed.options.cwd);\n        } catch (err) {\n            /* Empty */\n        }\n    }\n\n    let resolved;\n\n    try {\n        resolved = which.sync(parsed.command, {\n            path: env[getPathKey({ env })],\n            pathExt: withoutPathExt ? path.delimiter : undefined,\n        });\n    } catch (e) {\n        /* Empty */\n    } finally {\n        if (shouldSwitchCwd) {\n            process.chdir(cwd);\n        }\n    }\n\n    // If we successfully resolved, ensure that an absolute path is returned\n    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it\n    if (resolved) {\n        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);\n    }\n\n    return resolved;\n}\n\nfunction resolveCommand(parsed) {\n    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n}\n\nmodule.exports = resolveCommand;\n", "'use strict';\n\n// See http://www.robvanderwoude.com/escapechars.php\nconst metaCharsRegExp = /([()\\][%!^\"`<>&|;, *?])/g;\n\nfunction escapeCommand(arg) {\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    return arg;\n}\n\nfunction escapeArgument(arg, doubleEscapeMetaChars) {\n    // Convert to string\n    arg = `${arg}`;\n\n    // Algorithm below is based on https://qntm.org/cmd\n\n    // Sequence of backslashes followed by a double quote:\n    // double up all the backslashes and escape the double quote\n    arg = arg.replace(/(\\\\*)\"/g, '$1$1\\\\\"');\n\n    // Sequence of backslashes followed by the end of the string\n    // (which will become a double quote later):\n    // double up all the backslashes\n    arg = arg.replace(/(\\\\*)$/, '$1$1');\n\n    // All other backslashes occur literally\n\n    // Quote the whole thing:\n    arg = `\"${arg}\"`;\n\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    // Double escape meta chars if necessary\n    if (doubleEscapeMetaChars) {\n        arg = arg.replace(metaCharsRegExp, '^$1');\n    }\n\n    return arg;\n}\n\nmodule.exports.command = escapeCommand;\nmodule.exports.argument = escapeArgument;\n", "'use strict';\nmodule.exports = /^#!(.*)/;\n", "'use strict';\nconst shebangRegex = require('shebang-regex');\n\nmodule.exports = (string = '') => {\n\tconst match = string.match(shebangRegex);\n\n\tif (!match) {\n\t\treturn null;\n\t}\n\n\tconst [path, argument] = match[0].replace(/#! ?/, '').split(' ');\n\tconst binary = path.split('/').pop();\n\n\tif (binary === 'env') {\n\t\treturn argument;\n\t}\n\n\treturn argument ? `${binary} ${argument}` : binary;\n};\n", "'use strict';\n\nconst fs = require('fs');\nconst shebangCommand = require('shebang-command');\n\nfunction readShebang(command) {\n    // Read the first 150 bytes from the file\n    const size = 150;\n    const buffer = Buffer.alloc(size);\n\n    let fd;\n\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, size, 0);\n        fs.closeSync(fd);\n    } catch (e) { /* Empty */ }\n\n    // Attempt to extract shebang (null is returned if not a shebang)\n    return shebangCommand(buffer.toString());\n}\n\nmodule.exports = readShebang;\n", "'use strict';\n\nconst path = require('path');\nconst resolveCommand = require('./util/resolveCommand');\nconst escape = require('./util/escape');\nconst readShebang = require('./util/readShebang');\n\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n\nfunction detectShebang(parsed) {\n    parsed.file = resolveCommand(parsed);\n\n    const shebang = parsed.file && readShebang(parsed.file);\n\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n\n        return resolveCommand(parsed);\n    }\n\n    return parsed.file;\n}\n\nfunction parseNonShell(parsed) {\n    if (!isWin) {\n        return parsed;\n    }\n\n    // Detect & add support for shebangs\n    const commandFile = detectShebang(parsed);\n\n    // We don't need a shell if the command filename is an executable\n    const needsShell = !isExecutableRegExp.test(commandFile);\n\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    // Note that `forceShell` is an hidden option used only in tests\n    if (parsed.options.forceShell || needsShell) {\n        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n        // we need to double escape them\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n\n        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n        // This is necessary otherwise it will always fail with ENOENT in those cases\n        parsed.command = path.normalize(parsed.command);\n\n        // Escape command & arguments\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));\n\n        const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n        parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    }\n\n    return parsed;\n}\n\nfunction parse(command, args, options) {\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n    options = Object.assign({}, options); // Clone object to avoid changing the original\n\n    // Build our parsed object\n    const parsed = {\n        command,\n        args,\n        options,\n        file: undefined,\n        original: {\n            command,\n            args,\n        },\n    };\n\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parsed : parseNonShell(parsed);\n}\n\nmodule.exports = parse;\n", "'use strict';\n\nconst isWin = process.platform === 'win32';\n\nfunction notFoundError(original, syscall) {\n    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {\n        code: 'ENOENT',\n        errno: 'ENOENT',\n        syscall: `${syscall} ${original.command}`,\n        path: original.command,\n        spawnargs: original.args,\n    });\n}\n\nfunction hookChildProcess(cp, parsed) {\n    if (!isWin) {\n        return;\n    }\n\n    const originalEmit = cp.emit;\n\n    cp.emit = function (name, arg1) {\n        // If emitting \"exit\" event and exit code is 1, we need to check if\n        // the command exists and emit an \"error\" instead\n        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16\n        if (name === 'exit') {\n            const err = verifyENOENT(arg1, parsed, 'spawn');\n\n            if (err) {\n                return originalEmit.call(cp, 'error', err);\n            }\n        }\n\n        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params\n    };\n}\n\nfunction verifyENOENT(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawn');\n    }\n\n    return null;\n}\n\nfunction verifyENOENTSync(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawnSync');\n    }\n\n    return null;\n}\n\nmodule.exports = {\n    hookChildProcess,\n    verifyENOENT,\n    verifyENOENTSync,\n    notFoundError,\n};\n", "'use strict';\n\nconst cp = require('child_process');\nconst parse = require('./lib/parse');\nconst enoent = require('./lib/enoent');\n\nfunction spawn(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);\n\n    // Hook into child process \"exit\" event to emit an error if the command\n    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    enoent.hookChildProcess(spawned, parsed);\n\n    return spawned;\n}\n\nfunction spawnSync(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);\n\n    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);\n\n    return result;\n}\n\nmodule.exports = spawn;\nmodule.exports.spawn = spawn;\nmodule.exports.sync = spawnSync;\n\nmodule.exports._parse = parse;\nmodule.exports._enoent = enoent;\n", null, "'use strict'\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n", "/* MIT license */\n/* eslint-disable no-mixed-operators */\nconst cssKeywords = require('color-name');\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nconst reverseKeywords = {};\nfor (const key of Object.keys(cssKeywords)) {\n\treverseKeywords[cssKeywords[key]] = key;\n}\n\nconst convert = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\nmodule.exports = convert;\n\n// Hide .channels and .labels properties\nfor (const model of Object.keys(convert)) {\n\tif (!('channels' in convert[model])) {\n\t\tthrow new Error('missing channels property: ' + model);\n\t}\n\n\tif (!('labels' in convert[model])) {\n\t\tthrow new Error('missing channel labels property: ' + model);\n\t}\n\n\tif (convert[model].labels.length !== convert[model].channels) {\n\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t}\n\n\tconst {channels, labels} = convert[model];\n\tdelete convert[model].channels;\n\tdelete convert[model].labels;\n\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\tObject.defineProperty(convert[model], 'labels', {value: labels});\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst min = Math.min(r, g, b);\n\tconst max = Math.max(r, g, b);\n\tconst delta = max - min;\n\tlet h;\n\tlet s;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst l = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tlet rdif;\n\tlet gdif;\n\tlet bdif;\n\tlet h;\n\tlet s;\n\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst v = Math.max(r, g, b);\n\tconst diff = v - Math.min(r, g, b);\n\tconst diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = 0;\n\t\ts = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tconst r = rgb[0];\n\tconst g = rgb[1];\n\tlet b = rgb[2];\n\tconst h = convert.rgb.hsl(rgb)[0];\n\tconst w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\n\tconst k = Math.min(1 - r, 1 - g, 1 - b);\n\tconst c = (1 - r - k) / (1 - k) || 0;\n\tconst m = (1 - g - k) / (1 - k) || 0;\n\tconst y = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\nfunction comparativeDistance(x, y) {\n\t/*\n\t\tSee https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n\t*/\n\treturn (\n\t\t((x[0] - y[0]) ** 2) +\n\t\t((x[1] - y[1]) ** 2) +\n\t\t((x[2] - y[2]) ** 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tconst reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tlet currentClosestDistance = Infinity;\n\tlet currentClosestKeyword;\n\n\tfor (const keyword of Object.keys(cssKeywords)) {\n\t\tconst value = cssKeywords[keyword];\n\n\t\t// Compute comparative distance\n\t\tconst distance = comparativeDistance(rgb, value);\n\n\t\t// Check if its less, if so set as closest\n\t\tif (distance < currentClosestDistance) {\n\t\t\tcurrentClosestDistance = distance;\n\t\t\tcurrentClosestKeyword = keyword;\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tlet r = rgb[0] / 255;\n\tlet g = rgb[1] / 255;\n\tlet b = rgb[2] / 255;\n\n\t// Assume sRGB\n\tr = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);\n\n\tconst x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tconst y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tconst z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tconst xyz = convert.rgb.xyz(rgb);\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tconst h = hsl[0] / 360;\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\tlet t2;\n\tlet t3;\n\tlet val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tconst t1 = 2 * l - t2;\n\n\tconst rgb = [0, 0, 0];\n\tfor (let i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tconst h = hsl[0];\n\tlet s = hsl[1] / 100;\n\tlet l = hsl[2] / 100;\n\tlet smin = s;\n\tconst lmin = Math.max(l, 0.01);\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tconst v = (l + s) / 2;\n\tconst sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tconst h = hsv[0] / 60;\n\tconst s = hsv[1] / 100;\n\tlet v = hsv[2] / 100;\n\tconst hi = Math.floor(h) % 6;\n\n\tconst f = h - Math.floor(h);\n\tconst p = 255 * v * (1 - s);\n\tconst q = 255 * v * (1 - (s * f));\n\tconst t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tconst h = hsv[0];\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\tconst vmin = Math.max(v, 0.01);\n\tlet sl;\n\tlet l;\n\n\tl = (2 - s) * v;\n\tconst lmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tconst h = hwb[0] / 360;\n\tlet wh = hwb[1] / 100;\n\tlet bl = hwb[2] / 100;\n\tconst ratio = wh + bl;\n\tlet f;\n\n\t// Wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\tconst i = Math.floor(6 * h);\n\tconst v = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tconst n = wh + f * (v - wh); // Linear interpolation\n\n\tlet r;\n\tlet g;\n\tlet b;\n\t/* eslint-disable max-statements-per-line,no-multi-spaces */\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v;  g = n;  b = wh; break;\n\t\tcase 1: r = n;  g = v;  b = wh; break;\n\t\tcase 2: r = wh; g = v;  b = n; break;\n\t\tcase 3: r = wh; g = n;  b = v; break;\n\t\tcase 4: r = n;  g = wh; b = v; break;\n\t\tcase 5: r = v;  g = wh; b = n; break;\n\t}\n\t/* eslint-enable max-statements-per-line,no-multi-spaces */\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tconst c = cmyk[0] / 100;\n\tconst m = cmyk[1] / 100;\n\tconst y = cmyk[2] / 100;\n\tconst k = cmyk[3] / 100;\n\n\tconst r = 1 - Math.min(1, c * (1 - k) + k);\n\tconst g = 1 - Math.min(1, m * (1 - k) + k);\n\tconst b = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tconst x = xyz[0] / 100;\n\tconst y = xyz[1] / 100;\n\tconst z = xyz[2] / 100;\n\tlet r;\n\tlet g;\n\tlet b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// Assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet x;\n\tlet y;\n\tlet z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tconst y2 = y ** 3;\n\tconst x2 = x ** 3;\n\tconst z2 = z ** 3;\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet h;\n\n\tconst hr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst c = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tconst l = lch[0];\n\tconst c = lch[1];\n\tconst h = lch[2];\n\n\tconst hr = h / 360 * 2 * Math.PI;\n\tconst a = c * Math.cos(hr);\n\tconst b = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args, saturation = null) {\n\tconst [r, g, b] = args;\n\tlet value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tlet ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// Optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tconst r = args[0];\n\tconst g = args[1];\n\tconst b = args[2];\n\n\t// We use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tconst ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tlet color = args % 10;\n\n\t// Handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tconst mult = (~~(args > 50) + 1) * 0.5;\n\tconst r = ((color & 1) * mult) * 255;\n\tconst g = (((color >> 1) & 1) * mult) * 255;\n\tconst b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// Handle greyscale\n\tif (args >= 232) {\n\t\tconst c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tlet rem;\n\tconst r = Math.floor(args / 36) / 5 * 255;\n\tconst g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tconst b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tconst integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tconst match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tlet colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(char => {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tconst integer = parseInt(colorString, 16);\n\tconst r = (integer >> 16) & 0xFF;\n\tconst g = (integer >> 8) & 0xFF;\n\tconst b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst max = Math.max(Math.max(r, g), b);\n\tconst min = Math.min(Math.min(r, g), b);\n\tconst chroma = (max - min);\n\tlet grayscale;\n\tlet hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\n\tconst c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));\n\n\tlet f = 0;\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\n\tconst c = s * v;\n\tlet f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tconst h = hcg[0] / 360;\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tconst pure = [0, 0, 0];\n\tconst hi = (h % 1) * 6;\n\tconst v = hi % 1;\n\tconst w = 1 - v;\n\tlet mg = 0;\n\n\t/* eslint-disable max-statements-per-line */\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\t/* eslint-enable max-statements-per-line */\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst v = c + g * (1.0 - c);\n\tlet f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst l = g * (1.0 - c) + 0.5 * c;\n\tlet s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\tconst v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tconst w = hwb[1] / 100;\n\tconst b = hwb[2] / 100;\n\tconst v = 1 - b;\n\tconst c = v - w;\n\tlet g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hsv = convert.gray.hsl;\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tconst val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tconst integer = (val << 16) + (val << 8) + val;\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tconst val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n", "const conversions = require('./conversions');\n\n/*\n\tThis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tconst graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tconst models = Object.keys(conversions);\n\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tconst graph = buildGraph();\n\tconst queue = [fromModel]; // Unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tconst current = queue.pop();\n\t\tconst adjacents = Object.keys(conversions[current]);\n\n\t\tfor (let len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tconst adjacent = adjacents[i];\n\t\t\tconst node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tconst path = [graph[toModel].parent, toModel];\n\tlet fn = conversions[graph[toModel].parent][toModel];\n\n\tlet cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tconst graph = deriveBFS(fromModel);\n\tconst conversion = {};\n\n\tconst models = Object.keys(graph);\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tconst toModel = models[i];\n\t\tconst node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// No possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n", "const conversions = require('./conversions');\nconst route = require('./route');\n\nconst convert = {};\n\nconst models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\tconst result = fn(args);\n\n\t\t// We're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (let len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(fromModel => {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tconst routes = route(fromModel);\n\tconst routeModels = Object.keys(routes);\n\n\trouteModels.forEach(toModel => {\n\t\tconst fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n", "'use strict';\n\nconst wrapAnsi16 = (fn, offset) => (...args) => {\n\tconst code = fn(...args);\n\treturn `\\u001B[${code + offset}m`;\n};\n\nconst wrapAnsi256 = (fn, offset) => (...args) => {\n\tconst code = fn(...args);\n\treturn `\\u001B[${38 + offset};5;${code}m`;\n};\n\nconst wrapAnsi16m = (fn, offset) => (...args) => {\n\tconst rgb = fn(...args);\n\treturn `\\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;\n};\n\nconst ansi2ansi = n => n;\nconst rgb2rgb = (r, g, b) => [r, g, b];\n\nconst setLazyProperty = (object, property, get) => {\n\tObject.defineProperty(object, property, {\n\t\tget: () => {\n\t\t\tconst value = get();\n\n\t\t\tObject.defineProperty(object, property, {\n\t\t\t\tvalue,\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true\n\t\t\t});\n\n\t\t\treturn value;\n\t\t},\n\t\tenumerable: true,\n\t\tconfigurable: true\n\t});\n};\n\n/** @type {typeof import('color-convert')} */\nlet colorConvert;\nconst makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {\n\tif (colorConvert === undefined) {\n\t\tcolorConvert = require('color-convert');\n\t}\n\n\tconst offset = isBackground ? 10 : 0;\n\tconst styles = {};\n\n\tfor (const [sourceSpace, suite] of Object.entries(colorConvert)) {\n\t\tconst name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;\n\t\tif (sourceSpace === targetSpace) {\n\t\t\tstyles[name] = wrap(identity, offset);\n\t\t} else if (typeof suite === 'object') {\n\t\t\tstyles[name] = wrap(suite[targetSpace], offset);\n\t\t}\n\t}\n\n\treturn styles;\n};\n\nfunction assembleStyles() {\n\tconst codes = new Map();\n\tconst styles = {\n\t\tmodifier: {\n\t\t\treset: [0, 0],\n\t\t\t// 21 isn't widely supported and 22 does the same thing\n\t\t\tbold: [1, 22],\n\t\t\tdim: [2, 22],\n\t\t\titalic: [3, 23],\n\t\t\tunderline: [4, 24],\n\t\t\tinverse: [7, 27],\n\t\t\thidden: [8, 28],\n\t\t\tstrikethrough: [9, 29]\n\t\t},\n\t\tcolor: {\n\t\t\tblack: [30, 39],\n\t\t\tred: [31, 39],\n\t\t\tgreen: [32, 39],\n\t\t\tyellow: [33, 39],\n\t\t\tblue: [34, 39],\n\t\t\tmagenta: [35, 39],\n\t\t\tcyan: [36, 39],\n\t\t\twhite: [37, 39],\n\n\t\t\t// Bright color\n\t\t\tblackBright: [90, 39],\n\t\t\tredBright: [91, 39],\n\t\t\tgreenBright: [92, 39],\n\t\t\tyellowBright: [93, 39],\n\t\t\tblueBright: [94, 39],\n\t\t\tmagentaBright: [95, 39],\n\t\t\tcyanBright: [96, 39],\n\t\t\twhiteBright: [97, 39]\n\t\t},\n\t\tbgColor: {\n\t\t\tbgBlack: [40, 49],\n\t\t\tbgRed: [41, 49],\n\t\t\tbgGreen: [42, 49],\n\t\t\tbgYellow: [43, 49],\n\t\t\tbgBlue: [44, 49],\n\t\t\tbgMagenta: [45, 49],\n\t\t\tbgCyan: [46, 49],\n\t\t\tbgWhite: [47, 49],\n\n\t\t\t// Bright color\n\t\t\tbgBlackBright: [100, 49],\n\t\t\tbgRedBright: [101, 49],\n\t\t\tbgGreenBright: [102, 49],\n\t\t\tbgYellowBright: [103, 49],\n\t\t\tbgBlueBright: [104, 49],\n\t\t\tbgMagentaBright: [105, 49],\n\t\t\tbgCyanBright: [106, 49],\n\t\t\tbgWhiteBright: [107, 49]\n\t\t}\n\t};\n\n\t// Alias bright black as gray (and grey)\n\tstyles.color.gray = styles.color.blackBright;\n\tstyles.bgColor.bgGray = styles.bgColor.bgBlackBright;\n\tstyles.color.grey = styles.color.blackBright;\n\tstyles.bgColor.bgGrey = styles.bgColor.bgBlackBright;\n\n\tfor (const [groupName, group] of Object.entries(styles)) {\n\t\tfor (const [styleName, style] of Object.entries(group)) {\n\t\t\tstyles[styleName] = {\n\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\tclose: `\\u001B[${style[1]}m`\n\t\t\t};\n\n\t\t\tgroup[styleName] = styles[styleName];\n\n\t\t\tcodes.set(style[0], style[1]);\n\t\t}\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false\n\t\t});\n\t}\n\n\tObject.defineProperty(styles, 'codes', {\n\t\tvalue: codes,\n\t\tenumerable: false\n\t});\n\n\tstyles.color.close = '\\u001B[39m';\n\tstyles.bgColor.close = '\\u001B[49m';\n\n\tsetLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));\n\tsetLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));\n\tsetLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));\n\tsetLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));\n\tsetLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));\n\tsetLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));\n\n\treturn styles;\n}\n\n// Make the export immutable\nObject.defineProperty(module, 'exports', {\n\tenumerable: true,\n\tget: assembleStyles\n});\n", "'use strict';\n\nmodule.exports = (flag, argv = process.argv) => {\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst position = argv.indexOf(prefix + flag);\n\tconst terminatorPosition = argv.indexOf('--');\n\treturn position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n};\n", "'use strict';\nconst os = require('os');\nconst tty = require('tty');\nconst hasFlag = require('has-flag');\n\nconst {env} = process;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false') ||\n\thasFlag('color=never')) {\n\tforceColor = 0;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = 1;\n}\n\nif ('FORCE_COLOR' in env) {\n\tif (env.FORCE_COLOR === 'true') {\n\t\tforceColor = 1;\n\t} else if (env.FORCE_COLOR === 'false') {\n\t\tforceColor = 0;\n\t} else {\n\t\tforceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);\n\t}\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(haveStream, streamIsTTY) {\n\tif (forceColor === 0) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (haveStream && !streamIsTTY && forceColor === undefined) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor || 0;\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n\t\t// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream, stream && stream.isTTY);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: translateLevel(supportsColor(true, tty.isatty(1))),\n\tstderr: translateLevel(supportsColor(true, tty.isatty(2)))\n};\n", "'use strict';\n\nconst stringReplaceAll = (string, substring, replacer) => {\n\tlet index = string.indexOf(substring);\n\tif (index === -1) {\n\t\treturn string;\n\t}\n\n\tconst substringLength = substring.length;\n\tlet endIndex = 0;\n\tlet returnValue = '';\n\tdo {\n\t\treturnValue += string.substr(endIndex, index - endIndex) + substring + replacer;\n\t\tendIndex = index + substringLength;\n\t\tindex = string.indexOf(substring, endIndex);\n\t} while (index !== -1);\n\n\treturnValue += string.substr(endIndex);\n\treturn returnValue;\n};\n\nconst stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {\n\tlet endIndex = 0;\n\tlet returnValue = '';\n\tdo {\n\t\tconst gotCR = string[index - 1] === '\\r';\n\t\treturnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\\r\\n' : '\\n') + postfix;\n\t\tendIndex = index + 1;\n\t\tindex = string.indexOf('\\n', endIndex);\n\t} while (index !== -1);\n\n\treturnValue += string.substr(endIndex);\n\treturn returnValue;\n};\n\nmodule.exports = {\n\tstringReplaceAll,\n\tstringEncaseCRLFWithFirstIndex\n};\n", "'use strict';\nconst TEMPLATE_REGEX = /(?:\\\\(u(?:[a-f\\d]{4}|\\{[a-f\\d]{1,6}\\})|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\nconst STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\nconst STRING_REGEX = /^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\nconst ESCAPE_REGEX = /\\\\(u(?:[a-f\\d]{4}|{[a-f\\d]{1,6}})|x[a-f\\d]{2}|.)|([^\\\\])/gi;\n\nconst ESCAPES = new Map([\n\t['n', '\\n'],\n\t['r', '\\r'],\n\t['t', '\\t'],\n\t['b', '\\b'],\n\t['f', '\\f'],\n\t['v', '\\v'],\n\t['0', '\\0'],\n\t['\\\\', '\\\\'],\n\t['e', '\\u001B'],\n\t['a', '\\u0007']\n]);\n\nfunction unescape(c) {\n\tconst u = c[0] === 'u';\n\tconst bracket = c[1] === '{';\n\n\tif ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {\n\t\treturn String.fromCharCode(parseInt(c.slice(1), 16));\n\t}\n\n\tif (u && bracket) {\n\t\treturn String.fromCodePoint(parseInt(c.slice(2, -1), 16));\n\t}\n\n\treturn ESCAPES.get(c) || c;\n}\n\nfunction parseArguments(name, arguments_) {\n\tconst results = [];\n\tconst chunks = arguments_.trim().split(/\\s*,\\s*/g);\n\tlet matches;\n\n\tfor (const chunk of chunks) {\n\t\tconst number = Number(chunk);\n\t\tif (!Number.isNaN(number)) {\n\t\t\tresults.push(number);\n\t\t} else if ((matches = chunk.match(STRING_REGEX))) {\n\t\t\tresults.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));\n\t\t} else {\n\t\t\tthrow new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction parseStyle(style) {\n\tSTYLE_REGEX.lastIndex = 0;\n\n\tconst results = [];\n\tlet matches;\n\n\twhile ((matches = STYLE_REGEX.exec(style)) !== null) {\n\t\tconst name = matches[1];\n\n\t\tif (matches[2]) {\n\t\t\tconst args = parseArguments(name, matches[2]);\n\t\t\tresults.push([name].concat(args));\n\t\t} else {\n\t\t\tresults.push([name]);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction buildStyle(chalk, styles) {\n\tconst enabled = {};\n\n\tfor (const layer of styles) {\n\t\tfor (const style of layer.styles) {\n\t\t\tenabled[style[0]] = layer.inverse ? null : style.slice(1);\n\t\t}\n\t}\n\n\tlet current = chalk;\n\tfor (const [styleName, styles] of Object.entries(enabled)) {\n\t\tif (!Array.isArray(styles)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(styleName in current)) {\n\t\t\tthrow new Error(`Unknown Chalk style: ${styleName}`);\n\t\t}\n\n\t\tcurrent = styles.length > 0 ? current[styleName](...styles) : current[styleName];\n\t}\n\n\treturn current;\n}\n\nmodule.exports = (chalk, temporary) => {\n\tconst styles = [];\n\tconst chunks = [];\n\tlet chunk = [];\n\n\t// eslint-disable-next-line max-params\n\ttemporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {\n\t\tif (escapeCharacter) {\n\t\t\tchunk.push(unescape(escapeCharacter));\n\t\t} else if (style) {\n\t\t\tconst string = chunk.join('');\n\t\t\tchunk = [];\n\t\t\tchunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));\n\t\t\tstyles.push({inverse, styles: parseStyle(style)});\n\t\t} else if (close) {\n\t\t\tif (styles.length === 0) {\n\t\t\t\tthrow new Error('Found extraneous } in Chalk template literal');\n\t\t\t}\n\n\t\t\tchunks.push(buildStyle(chalk, styles)(chunk.join('')));\n\t\t\tchunk = [];\n\t\t\tstyles.pop();\n\t\t} else {\n\t\t\tchunk.push(character);\n\t\t}\n\t});\n\n\tchunks.push(chunk.join(''));\n\n\tif (styles.length > 0) {\n\t\tconst errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\\`}\\`)`;\n\t\tthrow new Error(errMessage);\n\t}\n\n\treturn chunks.join('');\n};\n", "'use strict';\nconst ansiStyles = require('ansi-styles');\nconst {stdout: stdoutColor, stderr: stderrColor} = require('supports-color');\nconst {\n\tstringReplaceAll,\n\tstringEncaseCRLFWithFirstIndex\n} = require('./util');\n\nconst {isArray} = Array;\n\n// `supportsColor.level` \u2192 `ansiStyles.color[name]` mapping\nconst levelMapping = [\n\t'ansi',\n\t'ansi',\n\t'ansi256',\n\t'ansi16m'\n];\n\nconst styles = Object.create(null);\n\nconst applyOptions = (object, options = {}) => {\n\tif (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {\n\t\tthrow new Error('The `level` option should be an integer from 0 to 3');\n\t}\n\n\t// Detect level if not set manually\n\tconst colorLevel = stdoutColor ? stdoutColor.level : 0;\n\tobject.level = options.level === undefined ? colorLevel : options.level;\n};\n\nclass ChalkClass {\n\tconstructor(options) {\n\t\t// eslint-disable-next-line no-constructor-return\n\t\treturn chalkFactory(options);\n\t}\n}\n\nconst chalkFactory = options => {\n\tconst chalk = {};\n\tapplyOptions(chalk, options);\n\n\tchalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);\n\n\tObject.setPrototypeOf(chalk, Chalk.prototype);\n\tObject.setPrototypeOf(chalk.template, chalk);\n\n\tchalk.template.constructor = () => {\n\t\tthrow new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');\n\t};\n\n\tchalk.template.Instance = ChalkClass;\n\n\treturn chalk.template;\n};\n\nfunction Chalk(options) {\n\treturn chalkFactory(options);\n}\n\nfor (const [styleName, style] of Object.entries(ansiStyles)) {\n\tstyles[styleName] = {\n\t\tget() {\n\t\t\tconst builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);\n\t\t\tObject.defineProperty(this, styleName, {value: builder});\n\t\t\treturn builder;\n\t\t}\n\t};\n}\n\nstyles.visible = {\n\tget() {\n\t\tconst builder = createBuilder(this, this._styler, true);\n\t\tObject.defineProperty(this, 'visible', {value: builder});\n\t\treturn builder;\n\t}\n};\n\nconst usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];\n\nfor (const model of usedModels) {\n\tstyles[model] = {\n\t\tget() {\n\t\t\tconst {level} = this;\n\t\t\treturn function (...arguments_) {\n\t\t\t\tconst styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);\n\t\t\t\treturn createBuilder(this, styler, this._isEmpty);\n\t\t\t};\n\t\t}\n\t};\n}\n\nfor (const model of usedModels) {\n\tconst bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);\n\tstyles[bgModel] = {\n\t\tget() {\n\t\t\tconst {level} = this;\n\t\t\treturn function (...arguments_) {\n\t\t\t\tconst styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);\n\t\t\t\treturn createBuilder(this, styler, this._isEmpty);\n\t\t\t};\n\t\t}\n\t};\n}\n\nconst proto = Object.defineProperties(() => {}, {\n\t...styles,\n\tlevel: {\n\t\tenumerable: true,\n\t\tget() {\n\t\t\treturn this._generator.level;\n\t\t},\n\t\tset(level) {\n\t\t\tthis._generator.level = level;\n\t\t}\n\t}\n});\n\nconst createStyler = (open, close, parent) => {\n\tlet openAll;\n\tlet closeAll;\n\tif (parent === undefined) {\n\t\topenAll = open;\n\t\tcloseAll = close;\n\t} else {\n\t\topenAll = parent.openAll + open;\n\t\tcloseAll = close + parent.closeAll;\n\t}\n\n\treturn {\n\t\topen,\n\t\tclose,\n\t\topenAll,\n\t\tcloseAll,\n\t\tparent\n\t};\n};\n\nconst createBuilder = (self, _styler, _isEmpty) => {\n\tconst builder = (...arguments_) => {\n\t\tif (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {\n\t\t\t// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`\n\t\t\treturn applyStyle(builder, chalkTag(builder, ...arguments_));\n\t\t}\n\n\t\t// Single argument is hot path, implicit coercion is faster than anything\n\t\t// eslint-disable-next-line no-implicit-coercion\n\t\treturn applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));\n\t};\n\n\t// We alter the prototype because we must return a function, but there is\n\t// no way to create a function with a different prototype\n\tObject.setPrototypeOf(builder, proto);\n\n\tbuilder._generator = self;\n\tbuilder._styler = _styler;\n\tbuilder._isEmpty = _isEmpty;\n\n\treturn builder;\n};\n\nconst applyStyle = (self, string) => {\n\tif (self.level <= 0 || !string) {\n\t\treturn self._isEmpty ? '' : string;\n\t}\n\n\tlet styler = self._styler;\n\n\tif (styler === undefined) {\n\t\treturn string;\n\t}\n\n\tconst {openAll, closeAll} = styler;\n\tif (string.indexOf('\\u001B') !== -1) {\n\t\twhile (styler !== undefined) {\n\t\t\t// Replace any instances already present with a re-opening code\n\t\t\t// otherwise only the part of the string until said closing code\n\t\t\t// will be colored, and the rest will simply be 'plain'.\n\t\t\tstring = stringReplaceAll(string, styler.close, styler.open);\n\n\t\t\tstyler = styler.parent;\n\t\t}\n\t}\n\n\t// We can move both next actions out of loop, because remaining actions in loop won't have\n\t// any/visible effect on parts we add here. Close the styling before a linebreak and reopen\n\t// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92\n\tconst lfIndex = string.indexOf('\\n');\n\tif (lfIndex !== -1) {\n\t\tstring = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);\n\t}\n\n\treturn openAll + string + closeAll;\n};\n\nlet template;\nconst chalkTag = (chalk, ...strings) => {\n\tconst [firstString] = strings;\n\n\tif (!isArray(firstString) || !isArray(firstString.raw)) {\n\t\t// If chalk() was called by itself or with a string,\n\t\t// return the string itself as a string.\n\t\treturn strings.join(' ');\n\t}\n\n\tconst arguments_ = strings.slice(1);\n\tconst parts = [firstString.raw[0]];\n\n\tfor (let i = 1; i < firstString.length; i++) {\n\t\tparts.push(\n\t\t\tString(arguments_[i - 1]).replace(/[{}\\\\]/g, '\\\\$&'),\n\t\t\tString(firstString.raw[i])\n\t\t);\n\t}\n\n\tif (template === undefined) {\n\t\ttemplate = require('./templates');\n\t}\n\n\treturn template(chalk, parts.join(''));\n};\n\nObject.defineProperties(Chalk.prototype, styles);\n\nconst chalk = Chalk(); // eslint-disable-line new-cap\nchalk.supportsColor = stdoutColor;\nchalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap\nchalk.stderr.supportsColor = stderrColor;\n\nmodule.exports = chalk;\n", "/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n", "\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n", "/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n", "/**\n * Module dependencies.\n */\n\nconst tty = require('tty');\nconst util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = require('supports-color');\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.format(...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.replace(/\\s*\\n\\s*/g, ' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n", "/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = require('./browser.js');\n} else {\n\tmodule.exports = require('./node.js');\n}\n", null, null, "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map", null, null, "'use strict';\n\nmodule.exports = (string, count = 1, options) => {\n\toptions = {\n\t\tindent: ' ',\n\t\tincludeEmptyLines: false,\n\t\t...options\n\t};\n\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`input\\` to be a \\`string\\`, got \\`${typeof string}\\``\n\t\t);\n\t}\n\n\tif (typeof count !== 'number') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`count\\` to be a \\`number\\`, got \\`${typeof count}\\``\n\t\t);\n\t}\n\n\tif (typeof options.indent !== 'string') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`options.indent\\` to be a \\`string\\`, got \\`${typeof options.indent}\\``\n\t\t);\n\t}\n\n\tif (count === 0) {\n\t\treturn string;\n\t}\n\n\tconst regex = options.includeEmptyLines ? /^/gm : /^(?!\\s*$)/gm;\n\n\treturn string.replace(regex, options.indent.repeat(count));\n};\n", "'use strict';\nmodule.exports = (function()\n{\n  function _min(d0, d1, d2, bx, ay)\n  {\n    return d0 < d1 || d2 < d1\n        ? d0 > d2\n            ? d2 + 1\n            : d0 + 1\n        : bx === ay\n            ? d1\n            : d1 + 1;\n  }\n\n  return function(a, b)\n  {\n    if (a === b) {\n      return 0;\n    }\n\n    if (a.length > b.length) {\n      var tmp = a;\n      a = b;\n      b = tmp;\n    }\n\n    var la = a.length;\n    var lb = b.length;\n\n    while (la > 0 && (a.charCodeAt(la - 1) === b.charCodeAt(lb - 1))) {\n      la--;\n      lb--;\n    }\n\n    var offset = 0;\n\n    while (offset < la && (a.charCodeAt(offset) === b.charCodeAt(offset))) {\n      offset++;\n    }\n\n    la -= offset;\n    lb -= offset;\n\n    if (la === 0 || lb < 3) {\n      return lb;\n    }\n\n    var x = 0;\n    var y;\n    var d0;\n    var d1;\n    var d2;\n    var d3;\n    var dd;\n    var dy;\n    var ay;\n    var bx0;\n    var bx1;\n    var bx2;\n    var bx3;\n\n    var vector = [];\n\n    for (y = 0; y < la; y++) {\n      vector.push(y + 1);\n      vector.push(a.charCodeAt(offset + y));\n    }\n\n    var len = vector.length - 1;\n\n    for (; x < lb - 3;) {\n      bx0 = b.charCodeAt(offset + (d0 = x));\n      bx1 = b.charCodeAt(offset + (d1 = x + 1));\n      bx2 = b.charCodeAt(offset + (d2 = x + 2));\n      bx3 = b.charCodeAt(offset + (d3 = x + 3));\n      dd = (x += 4);\n      for (y = 0; y < len; y += 2) {\n        dy = vector[y];\n        ay = vector[y + 1];\n        d0 = _min(dy, d0, d1, bx0, ay);\n        d1 = _min(d0, d1, d2, bx1, ay);\n        d2 = _min(d1, d2, d3, bx2, ay);\n        dd = _min(d2, d3, dd, bx3, ay);\n        vector[y] = dd;\n        d3 = d2;\n        d2 = d1;\n        d1 = d0;\n        d0 = dy;\n      }\n    }\n\n    for (; x < lb;) {\n      bx0 = b.charCodeAt(offset + (d0 = x));\n      dd = ++x;\n      for (y = 0; y < len; y += 2) {\n        dy = vector[y];\n        vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);\n        d0 = dy;\n      }\n    }\n\n    return dd;\n  };\n})();\n\n", "'use strict';\n\nmodule.exports = ({onlyFirst = false} = {}) => {\n\tconst pattern = [\n\t\t'[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n\t\t'(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'\n\t].join('|');\n\n\treturn new RegExp(pattern, onlyFirst ? undefined : 'g');\n};\n", "'use strict';\nconst ansiRegex = require('ansi-regex');\n\nmodule.exports = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;\n", "'use strict';\n\nmodule.exports = input => Object.prototype.toString.call(input) === '[object RegExp]';\n", "'use strict';\n\nmodule.exports = value => {\n\tconst type = typeof value;\n\treturn value !== null && (type === 'object' || type === 'function');\n};\n", null, "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar UNKNOWN_FUNCTION = '<unknown>';\n/**\n * This parses the different stack traces and puts them into one format\n * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)\n */\n\nfunction parse(stackString) {\n  var lines = stackString.split('\\n');\n  return lines.reduce(function (stack, line) {\n    var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);\n\n    if (parseResult) {\n      stack.push(parseResult);\n    }\n\n    return stack;\n  }, []);\n}\nvar chromeRe = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\/|[a-z]:\\\\|\\\\\\\\).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nvar chromeEvalRe = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n\nfunction parseChrome(line) {\n  var parts = chromeRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n\n  var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n  var submatch = chromeEvalRe.exec(parts[2]);\n\n  if (isEval && submatch != null) {\n    // throw out eval line/column and use top-most line/column number\n    parts[2] = submatch[1]; // url\n\n    parts[3] = submatch[2]; // line\n\n    parts[4] = submatch[3]; // column\n  }\n\n  return {\n    file: !isNative ? parts[2] : null,\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: isNative ? [parts[2]] : [],\n    lineNumber: parts[3] ? +parts[3] : null,\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\nvar winjsRe = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nfunction parseWinjs(line) {\n  var parts = winjsRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[2],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[3],\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\nvar geckoRe = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nvar geckoEvalRe = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n\nfunction parseGecko(line) {\n  var parts = geckoRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n  var submatch = geckoEvalRe.exec(parts[3]);\n\n  if (isEval && submatch != null) {\n    // throw out eval line/column and use top-most line number\n    parts[3] = submatch[1];\n    parts[4] = submatch[2];\n    parts[5] = null; // no column when eval\n  }\n\n  return {\n    file: parts[3],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: parts[2] ? parts[2].split(',') : [],\n    lineNumber: parts[4] ? +parts[4] : null,\n    column: parts[5] ? +parts[5] : null\n  };\n}\n\nvar javaScriptCoreRe = /^\\s*(?:([^@]*)(?:\\((.*?)\\))?@)?(\\S.*?):(\\d+)(?::(\\d+))?\\s*$/i;\n\nfunction parseJSC(line) {\n  var parts = javaScriptCoreRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[3],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[4],\n    column: parts[5] ? +parts[5] : null\n  };\n}\n\nvar nodeRe = /^\\s*at (?:((?:\\[object object\\])?[^\\\\/]+(?: \\[as \\S+\\])?) )?\\(?(.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nfunction parseNode(line) {\n  var parts = nodeRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[2],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[3],\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\nexports.parse = parse;\n", "'use strict';\nmodule.exports = string => {\n\tconst match = string.match(/^[ \\t]*(?=\\S)/gm);\n\n\tif (!match) {\n\t\treturn 0;\n\t}\n\n\treturn match.reduce((r, a) => Math.min(r, a.length), Infinity);\n};\n", "'use strict';\nconst minIndent = require('min-indent');\n\nmodule.exports = string => {\n\tconst indent = minIndent(string);\n\n\tif (indent === 0) {\n\t\treturn string;\n\t}\n\n\tconst regex = new RegExp(`^[ \\\\t]{${indent}}`, 'gm');\n\n\treturn string.replace(regex, '');\n};\n", "\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n", "/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n", "/**\n * Module dependencies.\n */\n\nconst tty = require('tty');\nconst util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = require('supports-color');\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.format(...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.replace(/\\s*\\n\\s*/g, ' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n", "/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = require('./browser.js');\n} else {\n\tmodule.exports = require('./node.js');\n}\n", null, null, "'use strict';\nconst ansiEscapes = module.exports;\n// TODO: remove this in the next major version\nmodule.exports.default = ansiEscapes;\n\nconst ESC = '\\u001B[';\nconst OSC = '\\u001B]';\nconst BEL = '\\u0007';\nconst SEP = ';';\nconst isTerminalApp = process.env.TERM_PROGRAM === 'Apple_Terminal';\n\nansiEscapes.cursorTo = (x, y) => {\n\tif (typeof x !== 'number') {\n\t\tthrow new TypeError('The `x` argument is required');\n\t}\n\n\tif (typeof y !== 'number') {\n\t\treturn ESC + (x + 1) + 'G';\n\t}\n\n\treturn ESC + (y + 1) + ';' + (x + 1) + 'H';\n};\n\nansiEscapes.cursorMove = (x, y) => {\n\tif (typeof x !== 'number') {\n\t\tthrow new TypeError('The `x` argument is required');\n\t}\n\n\tlet ret = '';\n\n\tif (x < 0) {\n\t\tret += ESC + (-x) + 'D';\n\t} else if (x > 0) {\n\t\tret += ESC + x + 'C';\n\t}\n\n\tif (y < 0) {\n\t\tret += ESC + (-y) + 'A';\n\t} else if (y > 0) {\n\t\tret += ESC + y + 'B';\n\t}\n\n\treturn ret;\n};\n\nansiEscapes.cursorUp = (count = 1) => ESC + count + 'A';\nansiEscapes.cursorDown = (count = 1) => ESC + count + 'B';\nansiEscapes.cursorForward = (count = 1) => ESC + count + 'C';\nansiEscapes.cursorBackward = (count = 1) => ESC + count + 'D';\n\nansiEscapes.cursorLeft = ESC + 'G';\nansiEscapes.cursorSavePosition = isTerminalApp ? '\\u001B7' : ESC + 's';\nansiEscapes.cursorRestorePosition = isTerminalApp ? '\\u001B8' : ESC + 'u';\nansiEscapes.cursorGetPosition = ESC + '6n';\nansiEscapes.cursorNextLine = ESC + 'E';\nansiEscapes.cursorPrevLine = ESC + 'F';\nansiEscapes.cursorHide = ESC + '?25l';\nansiEscapes.cursorShow = ESC + '?25h';\n\nansiEscapes.eraseLines = count => {\n\tlet clear = '';\n\n\tfor (let i = 0; i < count; i++) {\n\t\tclear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : '');\n\t}\n\n\tif (count) {\n\t\tclear += ansiEscapes.cursorLeft;\n\t}\n\n\treturn clear;\n};\n\nansiEscapes.eraseEndLine = ESC + 'K';\nansiEscapes.eraseStartLine = ESC + '1K';\nansiEscapes.eraseLine = ESC + '2K';\nansiEscapes.eraseDown = ESC + 'J';\nansiEscapes.eraseUp = ESC + '1J';\nansiEscapes.eraseScreen = ESC + '2J';\nansiEscapes.scrollUp = ESC + 'S';\nansiEscapes.scrollDown = ESC + 'T';\n\nansiEscapes.clearScreen = '\\u001Bc';\n\nansiEscapes.clearTerminal = process.platform === 'win32' ?\n\t`${ansiEscapes.eraseScreen}${ESC}0f` :\n\t// 1. Erases the screen (Only done in case `2` is not supported)\n\t// 2. Erases the whole screen including scrollback buffer\n\t// 3. Moves cursor to the top-left position\n\t// More info: https://www.real-world-systems.com/docs/ANSIcode.html\n\t`${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`;\n\nansiEscapes.beep = BEL;\n\nansiEscapes.link = (text, url) => {\n\treturn [\n\t\tOSC,\n\t\t'8',\n\t\tSEP,\n\t\tSEP,\n\t\turl,\n\t\tBEL,\n\t\ttext,\n\t\tOSC,\n\t\t'8',\n\t\tSEP,\n\t\tSEP,\n\t\tBEL\n\t].join('');\n};\n\nansiEscapes.image = (buffer, options = {}) => {\n\tlet ret = `${OSC}1337;File=inline=1`;\n\n\tif (options.width) {\n\t\tret += `;width=${options.width}`;\n\t}\n\n\tif (options.height) {\n\t\tret += `;height=${options.height}`;\n\t}\n\n\tif (options.preserveAspectRatio === false) {\n\t\tret += ';preserveAspectRatio=0';\n\t}\n\n\treturn ret + ':' + buffer.toString('base64') + BEL;\n};\n\nansiEscapes.iTerm = {\n\tsetCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,\n\n\tannotation: (message, options = {}) => {\n\t\tlet ret = `${OSC}1337;`;\n\n\t\tconst hasX = typeof options.x !== 'undefined';\n\t\tconst hasY = typeof options.y !== 'undefined';\n\t\tif ((hasX || hasY) && !(hasX && hasY && typeof options.length !== 'undefined')) {\n\t\t\tthrow new Error('`x`, `y` and `length` must be defined when `x` or `y` is defined');\n\t\t}\n\n\t\tmessage = message.replace(/\\|/g, '');\n\n\t\tret += options.isHidden ? 'AddHiddenAnnotation=' : 'AddAnnotation=';\n\n\t\tif (options.length > 0) {\n\t\t\tret +=\n\t\t\t\t\t(hasX ?\n\t\t\t\t\t\t[message, options.length, options.x, options.y] :\n\t\t\t\t\t\t[options.length, message]).join('|');\n\t\t} else {\n\t\t\tret += message;\n\t\t}\n\n\t\treturn ret + BEL;\n\t}\n};\n", "'use strict';\nconst os = require('os');\nconst tty = require('tty');\nconst hasFlag = require('has-flag');\n\nconst {env} = process;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false') ||\n\thasFlag('color=never')) {\n\tforceColor = 0;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = 1;\n}\n\nif ('FORCE_COLOR' in env) {\n\tif (env.FORCE_COLOR === 'true') {\n\t\tforceColor = 1;\n\t} else if (env.FORCE_COLOR === 'false') {\n\t\tforceColor = 0;\n\t} else {\n\t\tforceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);\n\t}\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(haveStream, streamIsTTY) {\n\tif (forceColor === 0) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (haveStream && !streamIsTTY && forceColor === undefined) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor || 0;\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n\t\t// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif ('GITHUB_ACTIONS' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream, stream && stream.isTTY);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: translateLevel(supportsColor(true, tty.isatty(1))),\n\tstderr: translateLevel(supportsColor(true, tty.isatty(2)))\n};\n", "'use strict';\nconst supportsColor = require('supports-color');\nconst hasFlag = require('has-flag');\n\nfunction parseVersion(versionString) {\n\tif (/^\\d{3,4}$/.test(versionString)) {\n\t\t// Env var doesn't always use dots. example: 4601 => 46.1.0\n\t\tconst m = /(\\d{1,2})(\\d{2})/.exec(versionString);\n\t\treturn {\n\t\t\tmajor: 0,\n\t\t\tminor: parseInt(m[1], 10),\n\t\t\tpatch: parseInt(m[2], 10)\n\t\t};\n\t}\n\n\tconst versions = (versionString || '').split('.').map(n => parseInt(n, 10));\n\treturn {\n\t\tmajor: versions[0],\n\t\tminor: versions[1],\n\t\tpatch: versions[2]\n\t};\n}\n\nfunction supportsHyperlink(stream) {\n\tconst {env} = process;\n\n\tif ('FORCE_HYPERLINK' in env) {\n\t\treturn !(env.FORCE_HYPERLINK.length > 0 && parseInt(env.FORCE_HYPERLINK, 10) === 0);\n\t}\n\n\tif (hasFlag('no-hyperlink') || hasFlag('no-hyperlinks') || hasFlag('hyperlink=false') || hasFlag('hyperlink=never')) {\n\t\treturn false;\n\t}\n\n\tif (hasFlag('hyperlink=true') || hasFlag('hyperlink=always')) {\n\t\treturn true;\n\t}\n\n\t// If they specify no colors, they probably don't want hyperlinks.\n\tif (!supportsColor.supportsColor(stream)) {\n\t\treturn false;\n\t}\n\n\tif (stream && !stream.isTTY) {\n\t\treturn false;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\treturn false;\n\t}\n\n\tif ('CI' in env) {\n\t\treturn false;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn false;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseVersion(env.TERM_PROGRAM_VERSION);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\tif (version.major === 3) {\n\t\t\t\t\treturn version.minor >= 1;\n\t\t\t\t}\n\n\t\t\t\treturn version.major > 3;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif ('VTE_VERSION' in env) {\n\t\t// 0.50.0 was supposed to support hyperlinks, but throws a segfault\n\t\tif (env.VTE_VERSION === '0.50.0') {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst version = parseVersion(env.VTE_VERSION);\n\t\treturn version.major > 0 || version.minor >= 50;\n\t}\n\n\treturn false;\n}\n\nmodule.exports = {\n\tsupportsHyperlink,\n\tstdout: supportsHyperlink(process.stdout),\n\tstderr: supportsHyperlink(process.stderr)\n};\n", "'use strict';\nconst ansiEscapes = require('ansi-escapes');\nconst supportsHyperlinks = require('supports-hyperlinks');\n\nconst terminalLink = (text, url, {target = 'stdout', ...options} = {}) => {\n\tif (!supportsHyperlinks[target]) {\n\t\t// If the fallback has been explicitly disabled, don't modify the text itself.\n\t\tif (options.fallback === false) {\n\t\t\treturn text;\n\t\t}\n\n\t\treturn typeof options.fallback === 'function' ? options.fallback(text, url) : `${text} (\\u200B${url}\\u200B)`;\n\t}\n\n\treturn ansiEscapes.link(text, url);\n};\n\nmodule.exports = (text, url, options = {}) => terminalLink(text, url, options);\n\nmodule.exports.stderr = (text, url, options = {}) => terminalLink(text, url, {target: 'stderr', ...options});\n\nmodule.exports.isSupported = supportsHyperlinks.stdout;\nmodule.exports.stderr.isSupported = supportsHyperlinks.stderr;\n", "'use strict';\n\nmodule.exports = (options = {}) => {\n\tlet repoUrl;\n\tif (options.repoUrl) {\n\t\trepoUrl = options.repoUrl;\n\t} else if (options.user && options.repo) {\n\t\trepoUrl = `https://github.com/${options.user}/${options.repo}`;\n\t} else {\n\t\tthrow new Error('You need to specify either the `repoUrl` option or both the `user` and `repo` options');\n\t}\n\n\tconst url = new URL(`${repoUrl}/issues/new`);\n\n\tconst types = [\n\t\t'body',\n\t\t'title',\n\t\t'labels',\n\t\t'template',\n\t\t'milestone',\n\t\t'assignee',\n\t\t'projects'\n\t];\n\n\tfor (const type of types) {\n\t\tlet value = options[type];\n\t\tif (value === undefined) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type === 'labels' || type === 'projects') {\n\t\t\tif (!Array.isArray(value)) {\n\t\t\t\tthrow new TypeError(`The \\`${type}\\` option should be an array`);\n\t\t\t}\n\n\t\t\tvalue = value.join(',');\n\t\t}\n\n\t\turl.searchParams.set(type, value);\n\t}\n\n\treturn url.toString();\n};\n\n// TODO: Remove this for the next major release\nmodule.exports.default = module.exports;\n", null, null, "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.enginesVersion = void 0;\nexports.enginesVersion = require('./package.json').prisma.enginesVersion;\n//# sourceMappingURL=index.js.map", null, null, null, null, null, null, "function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts;\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(this._errors.length - 1, this._errors.length);\n      this._timeouts = this._cachedTimeouts.slice(0);\n      timeout = this._timeouts.shift();\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  var timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n", "var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && options.forever,\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n", "module.exports = require('./lib/retry');", "'use strict';\nconst retry = require('retry');\n\nclass AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nconst decorateErrorWithCounts = (error, attemptNumber, options) => {\n\t// Minus 1 from attemptNumber because the first attempt does not count as a retry\n\tconst retriesLeft = options.retries - (attemptNumber - 1);\n\n\terror.attemptNumber = attemptNumber;\n\terror.retriesLeft = retriesLeft;\n\treturn error;\n};\n\nconst pRetry = (input, options) => new Promise((resolve, reject) => {\n\toptions = {\n\t\tonFailedAttempt: () => {},\n\t\tretries: 10,\n\t\t...options\n\t};\n\n\tconst operation = retry.operation(options);\n\n\toperation.attempt(async attemptNumber => {\n\t\ttry {\n\t\t\tresolve(await input(attemptNumber));\n\t\t} catch (error) {\n\t\t\tif (!(error instanceof Error)) {\n\t\t\t\treject(new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (error instanceof AbortError) {\n\t\t\t\toperation.stop();\n\t\t\t\treject(error.originalError);\n\t\t\t} else if (error instanceof TypeError) {\n\t\t\t\toperation.stop();\n\t\t\t\treject(error);\n\t\t\t} else {\n\t\t\t\tdecorateErrorWithCounts(error, attemptNumber, options);\n\n\t\t\t\ttry {\n\t\t\t\t\tawait options.onFailedAttempt(error);\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!operation.retry(error)) {\n\t\t\t\t\treject(operation.mainError());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n});\n\nmodule.exports = pRetry;\n// TODO: remove this in the next major version\nmodule.exports.default = pRetry;\n\nmodule.exports.AbortError = AbortError;\n", "'use strict';\n\nmodule.exports = input => {\n\tconst LF = typeof input === 'string' ? '\\n' : '\\n'.charCodeAt();\n\tconst CR = typeof input === 'string' ? '\\r' : '\\r'.charCodeAt();\n\n\tif (input[input.length - 1] === LF) {\n\t\tinput = input.slice(0, input.length - 1);\n\t}\n\n\tif (input[input.length - 1] === CR) {\n\t\tinput = input.slice(0, input.length - 1);\n\t}\n\n\treturn input;\n};\n", "'use strict';\nconst path = require('path');\nconst pathKey = require('path-key');\n\nconst npmRunPath = options => {\n\toptions = {\n\t\tcwd: process.cwd(),\n\t\tpath: process.env[pathKey()],\n\t\texecPath: process.execPath,\n\t\t...options\n\t};\n\n\tlet previous;\n\tlet cwdPath = path.resolve(options.cwd);\n\tconst result = [];\n\n\twhile (previous !== cwdPath) {\n\t\tresult.push(path.join(cwdPath, 'node_modules/.bin'));\n\t\tprevious = cwdPath;\n\t\tcwdPath = path.resolve(cwdPath, '..');\n\t}\n\n\t// Ensure the running `node` binary is used\n\tconst execPathDir = path.resolve(options.cwd, options.execPath, '..');\n\tresult.push(execPathDir);\n\n\treturn result.concat(options.path).join(path.delimiter);\n};\n\nmodule.exports = npmRunPath;\n// TODO: Remove this for the next major release\nmodule.exports.default = npmRunPath;\n\nmodule.exports.env = options => {\n\toptions = {\n\t\tenv: process.env,\n\t\t...options\n\t};\n\n\tconst env = {...options.env};\n\tconst path = pathKey({env});\n\n\toptions.path = env[path];\n\tenv[path] = module.exports(options);\n\n\treturn env;\n};\n", "'use strict';\n\nconst mimicFn = (to, from) => {\n\tfor (const prop of Reflect.ownKeys(from)) {\n\t\tObject.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));\n\t}\n\n\treturn to;\n};\n\nmodule.exports = mimicFn;\n// TODO: Remove this for the next major release\nmodule.exports.default = mimicFn;\n", "'use strict';\nconst mimicFn = require('mimic-fn');\n\nconst calledFunctions = new WeakMap();\n\nconst oneTime = (fn, options = {}) => {\n\tif (typeof fn !== 'function') {\n\t\tthrow new TypeError('Expected a function');\n\t}\n\n\tlet ret;\n\tlet isCalled = false;\n\tlet callCount = 0;\n\tconst functionName = fn.displayName || fn.name || '<anonymous>';\n\n\tconst onetime = function (...args) {\n\t\tcalledFunctions.set(onetime, ++callCount);\n\n\t\tif (isCalled) {\n\t\t\tif (options.throw === true) {\n\t\t\t\tthrow new Error(`Function \\`${functionName}\\` can only be called once`);\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tisCalled = true;\n\t\tret = fn.apply(this, args);\n\t\tfn = null;\n\n\t\treturn ret;\n\t};\n\n\tmimicFn(onetime, fn);\n\tcalledFunctions.set(onetime, callCount);\n\n\treturn onetime;\n};\n\nmodule.exports = oneTime;\n// TODO: Remove this for the next major release\nmodule.exports.default = oneTime;\n\nmodule.exports.callCount = fn => {\n\tif (!calledFunctions.has(fn)) {\n\t\tthrow new Error(`The given function \\`${fn.name}\\` is not wrapped by the \\`onetime\\` package`);\n\t}\n\n\treturn calledFunctions.get(fn);\n};\n", "/* eslint-disable max-lines */\n// List of known process signals with information about them\nexport const SIGNALS = [\n  {\n    name: 'SIGHUP',\n    number: 1,\n    action: 'terminate',\n    description: 'Terminal closed',\n    standard: 'posix',\n  },\n  {\n    name: 'SIGINT',\n    number: 2,\n    action: 'terminate',\n    description: 'User interruption with CTRL-C',\n    standard: 'ansi',\n  },\n  {\n    name: 'SIGQUIT',\n    number: 3,\n    action: 'core',\n    description: 'User interruption with CTRL-\\\\',\n    standard: 'posix',\n  },\n  {\n    name: 'SIGILL',\n    number: 4,\n    action: 'core',\n    description: 'Invalid machine instruction',\n    standard: 'ansi',\n  },\n  {\n    name: 'SIGTRAP',\n    number: 5,\n    action: 'core',\n    description: 'Debugger breakpoint',\n    standard: 'posix',\n  },\n  {\n    name: 'SIGABRT',\n    number: 6,\n    action: 'core',\n    description: 'Aborted',\n    standard: 'ansi',\n  },\n  {\n    name: 'SIGIOT',\n    number: 6,\n    action: 'core',\n    description: 'Aborted',\n    standard: 'bsd',\n  },\n  {\n    name: 'SIGBUS',\n    number: 7,\n    action: 'core',\n    description:\n      'Bus error due to misaligned, non-existing address or paging error',\n    standard: 'bsd',\n  },\n  {\n    name: 'SIGEMT',\n    number: 7,\n    action: 'terminate',\n    description: 'Command should be emulated but is not implemented',\n    standard: 'other',\n  },\n  {\n    name: 'SIGFPE',\n    number: 8,\n    action: 'core',\n    description: 'Floating point arithmetic error',\n    standard: 'ansi',\n  },\n  {\n    name: 'SIGKILL',\n    number: 9,\n    action: 'terminate',\n    description: 'Forced termination',\n    standard: 'posix',\n    forced: true,\n  },\n  {\n    name: 'SIGUSR1',\n    number: 10,\n    action: 'terminate',\n    description: 'Application-specific signal',\n    standard: 'posix',\n  },\n  {\n    name: 'SIGSEGV',\n    number: 11,\n    action: 'core',\n    description: 'Segmentation fault',\n    standard: 'ansi',\n  },\n  {\n    name: 'SIGUSR2',\n    number: 12,\n    action: 'terminate',\n    description: 'Application-specific signal',\n    standard: 'posix',\n  },\n  {\n    name: 'SIGPIPE',\n    number: 13,\n    action: 'terminate',\n    description: 'Broken pipe or socket',\n    standard: 'posix',\n  },\n  {\n    name: 'SIGALRM',\n    number: 14,\n    action: 'terminate',\n    description: 'Timeout or timer',\n    standard: 'posix',\n  },\n  {\n    name: 'SIGTERM',\n    number: 15,\n    action: 'terminate',\n    description: 'Termination',\n    standard: 'ansi',\n  },\n  {\n    name: 'SIGSTKFLT',\n    number: 16,\n    action: 'terminate',\n    description: 'Stack is empty or overflowed',\n    standard: 'other',\n  },\n  {\n    name: 'SIGCHLD',\n    number: 17,\n    action: 'ignore',\n    description: 'Child process terminated, paused or unpaused',\n    standard: 'posix',\n  },\n  {\n    name: 'SIGCLD',\n    number: 17,\n    action: 'ignore',\n    description: 'Child process terminated, paused or unpaused',\n    standard: 'other',\n  },\n  {\n    name: 'SIGCONT',\n    number: 18,\n    action: 'unpause',\n    description: 'Unpaused',\n    standard: 'posix',\n    forced: true,\n  },\n  {\n    name: 'SIGSTOP',\n    number: 19,\n    action: 'pause',\n    description: 'Paused',\n    standard: 'posix',\n    forced: true,\n  },\n  {\n    name: 'SIGTSTP',\n    number: 20,\n    action: 'pause',\n    description: 'Paused using CTRL-Z or \"suspend\"',\n    standard: 'posix',\n  },\n  {\n    name: 'SIGTTIN',\n    number: 21,\n    action: 'pause',\n    description: 'Background process cannot read terminal input',\n    standard: 'posix',\n  },\n  {\n    name: 'SIGBREAK',\n    number: 21,\n    action: 'terminate',\n    description: 'User interruption with CTRL-BREAK',\n    standard: 'other',\n  },\n  {\n    name: 'SIGTTOU',\n    number: 22,\n    action: 'pause',\n    description: 'Background process cannot write to terminal output',\n    standard: 'posix',\n  },\n  {\n    name: 'SIGURG',\n    number: 23,\n    action: 'ignore',\n    description: 'Socket received out-of-band data',\n    standard: 'bsd',\n  },\n  {\n    name: 'SIGXCPU',\n    number: 24,\n    action: 'core',\n    description: 'Process timed out',\n    standard: 'bsd',\n  },\n  {\n    name: 'SIGXFSZ',\n    number: 25,\n    action: 'core',\n    description: 'File too big',\n    standard: 'bsd',\n  },\n  {\n    name: 'SIGVTALRM',\n    number: 26,\n    action: 'terminate',\n    description: 'Timeout or timer',\n    standard: 'bsd',\n  },\n  {\n    name: 'SIGPROF',\n    number: 27,\n    action: 'terminate',\n    description: 'Timeout or timer',\n    standard: 'bsd',\n  },\n  {\n    name: 'SIGWINCH',\n    number: 28,\n    action: 'ignore',\n    description: 'Terminal window size changed',\n    standard: 'bsd',\n  },\n  {\n    name: 'SIGIO',\n    number: 29,\n    action: 'terminate',\n    description: 'I/O is available',\n    standard: 'other',\n  },\n  {\n    name: 'SIGPOLL',\n    number: 29,\n    action: 'terminate',\n    description: 'Watched event',\n    standard: 'other',\n  },\n  {\n    name: 'SIGINFO',\n    number: 29,\n    action: 'ignore',\n    description: 'Request for process information',\n    standard: 'other',\n  },\n  {\n    name: 'SIGPWR',\n    number: 30,\n    action: 'terminate',\n    description: 'Device running out of power',\n    standard: 'systemv',\n  },\n  {\n    name: 'SIGSYS',\n    number: 31,\n    action: 'core',\n    description: 'Invalid system call',\n    standard: 'other',\n  },\n  {\n    name: 'SIGUNUSED',\n    number: 31,\n    action: 'terminate',\n    description: 'Invalid system call',\n    standard: 'other',\n  },\n]\n/* eslint-enable max-lines */\n", "// List of realtime signals with information about them\nexport const getRealtimeSignals = function() {\n  const length = SIGRTMAX - SIGRTMIN + 1\n  return Array.from({ length }, getRealtimeSignal)\n}\n\nconst getRealtimeSignal = function(value, index) {\n  return {\n    name: `SIGRT${index + 1}`,\n    number: SIGRTMIN + index,\n    action: 'terminate',\n    description: 'Application-specific signal (realtime)',\n    standard: 'posix',\n  }\n}\n\nconst SIGRTMIN = 34\nexport const SIGRTMAX = 64\n", "import { constants } from 'os'\n\nimport { SIGNALS } from './core.js'\nimport { getRealtimeSignals } from './realtime.js'\n\n// Retrieve list of know signals (including realtime) with information about\n// them\nexport const getSignals = function() {\n  const realtimeSignals = getRealtimeSignals()\n  const signals = [...SIGNALS, ...realtimeSignals].map(normalizeSignal)\n  return signals\n}\n\n// Normalize signal:\n//  - `number`: signal numbers are OS-specific. This is taken into account by\n//    `os.constants.signals`. However we provide a default `number` since some\n//     signals are not defined for some OS.\n//  - `forced`: set default to `false`\n//  - `supported`: set value\nconst normalizeSignal = function({\n  name,\n  number: defaultNumber,\n  description,\n  action,\n  forced = false,\n  standard,\n}) {\n  const {\n    signals: { [name]: constantSignal },\n  } = constants\n  const supported = constantSignal !== undefined\n  const number = supported ? constantSignal : defaultNumber\n  return { name, number, description, supported, action, forced, standard }\n}\n", "import { constants } from 'os'\n\nimport { getSignals } from './signals.js'\nimport { SIGRTMAX } from './realtime.js'\n\n// Retrieve `signalsByName`, an object mapping signal name to signal properties.\n// We make sure the object is sorted by `number`.\nconst getSignalsByName = function() {\n  const signals = getSignals()\n  return signals.reduce(getSignalByName, {})\n}\n\nconst getSignalByName = function(\n  signalByNameMemo,\n  { name, number, description, supported, action, forced, standard },\n) {\n  return {\n    ...signalByNameMemo,\n    [name]: { name, number, description, supported, action, forced, standard },\n  }\n}\n\nexport const signalsByName = getSignalsByName()\n\n// Retrieve `signalsByNumber`, an object mapping signal number to signal\n// properties.\n// We make sure the object is sorted by `number`.\nconst getSignalsByNumber = function() {\n  const signals = getSignals()\n  const length = SIGRTMAX + 1\n  const signalsA = Array.from({ length }, (value, number) =>\n    getSignalByNumber(number, signals),\n  )\n  return Object.assign({}, ...signalsA)\n}\n\nconst getSignalByNumber = function(number, signals) {\n  const signal = findSignalByNumber(number, signals)\n\n  if (signal === undefined) {\n    return {}\n  }\n\n  const { name, description, supported, action, forced, standard } = signal\n  return {\n    [number]: {\n      name,\n      number,\n      description,\n      supported,\n      action,\n      forced,\n      standard,\n    },\n  }\n}\n\n// Several signals might end up sharing the same number because of OS-specific\n// numbers, in which case those prevail.\nconst findSignalByNumber = function(number, signals) {\n  const signal = signals.find(({ name }) => constants.signals[name] === number)\n\n  if (signal !== undefined) {\n    return signal\n  }\n\n  return signals.find(signalA => signalA.number === number)\n}\n\nexport const signalsByNumber = getSignalsByNumber()\n", "'use strict';\nconst {signalsByName} = require('human-signals');\n\nconst getErrorPrefix = ({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled}) => {\n\tif (timedOut) {\n\t\treturn `timed out after ${timeout} milliseconds`;\n\t}\n\n\tif (isCanceled) {\n\t\treturn 'was canceled';\n\t}\n\n\tif (errorCode !== undefined) {\n\t\treturn `failed with ${errorCode}`;\n\t}\n\n\tif (signal !== undefined) {\n\t\treturn `was killed with ${signal} (${signalDescription})`;\n\t}\n\n\tif (exitCode !== undefined) {\n\t\treturn `failed with exit code ${exitCode}`;\n\t}\n\n\treturn 'failed';\n};\n\nconst makeError = ({\n\tstdout,\n\tstderr,\n\tall,\n\terror,\n\tsignal,\n\texitCode,\n\tcommand,\n\ttimedOut,\n\tisCanceled,\n\tkilled,\n\tparsed: {options: {timeout}}\n}) => {\n\t// `signal` and `exitCode` emitted on `spawned.on('exit')` event can be `null`.\n\t// We normalize them to `undefined`\n\texitCode = exitCode === null ? undefined : exitCode;\n\tsignal = signal === null ? undefined : signal;\n\tconst signalDescription = signal === undefined ? undefined : signalsByName[signal].description;\n\n\tconst errorCode = error && error.code;\n\n\tconst prefix = getErrorPrefix({timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled});\n\tconst execaMessage = `Command ${prefix}: ${command}`;\n\tconst isError = Object.prototype.toString.call(error) === '[object Error]';\n\tconst shortMessage = isError ? `${execaMessage}\\n${error.message}` : execaMessage;\n\tconst message = [shortMessage, stderr, stdout].filter(Boolean).join('\\n');\n\n\tif (isError) {\n\t\terror.originalMessage = error.message;\n\t\terror.message = message;\n\t} else {\n\t\terror = new Error(message);\n\t}\n\n\terror.shortMessage = shortMessage;\n\terror.command = command;\n\terror.exitCode = exitCode;\n\terror.signal = signal;\n\terror.signalDescription = signalDescription;\n\terror.stdout = stdout;\n\terror.stderr = stderr;\n\n\tif (all !== undefined) {\n\t\terror.all = all;\n\t}\n\n\tif ('bufferedData' in error) {\n\t\tdelete error.bufferedData;\n\t}\n\n\terror.failed = true;\n\terror.timedOut = Boolean(timedOut);\n\terror.isCanceled = isCanceled;\n\terror.killed = killed && !timedOut;\n\n\treturn error;\n};\n\nmodule.exports = makeError;\n", "'use strict';\nconst aliases = ['stdin', 'stdout', 'stderr'];\n\nconst hasAlias = opts => aliases.some(alias => opts[alias] !== undefined);\n\nconst normalizeStdio = opts => {\n\tif (!opts) {\n\t\treturn;\n\t}\n\n\tconst {stdio} = opts;\n\n\tif (stdio === undefined) {\n\t\treturn aliases.map(alias => opts[alias]);\n\t}\n\n\tif (hasAlias(opts)) {\n\t\tthrow new Error(`It's not possible to provide \\`stdio\\` in combination with one of ${aliases.map(alias => `\\`${alias}\\``).join(', ')}`);\n\t}\n\n\tif (typeof stdio === 'string') {\n\t\treturn stdio;\n\t}\n\n\tif (!Array.isArray(stdio)) {\n\t\tthrow new TypeError(`Expected \\`stdio\\` to be of type \\`string\\` or \\`Array\\`, got \\`${typeof stdio}\\``);\n\t}\n\n\tconst length = Math.max(stdio.length, aliases.length);\n\treturn Array.from({length}, (value, index) => stdio[index]);\n};\n\nmodule.exports = normalizeStdio;\n\n// `ipc` is pushed unless it is already present\nmodule.exports.node = opts => {\n\tconst stdio = normalizeStdio(opts);\n\n\tif (stdio === 'ipc') {\n\t\treturn 'ipc';\n\t}\n\n\tif (stdio === undefined || typeof stdio === 'string') {\n\t\treturn [stdio, stdio, stdio, 'ipc'];\n\t}\n\n\tif (stdio.includes('ipc')) {\n\t\treturn stdio;\n\t}\n\n\treturn [...stdio, 'ipc'];\n};\n", "// This is not the set of all possible signals.\n//\n// It IS, however, the set of all signals that trigger\n// an exit on either Linux or BSD systems.  Linux is a\n// superset of the signal names supported on BSD, and\n// the unknown signals just fail to register, so we can\n// catch that easily enough.\n//\n// Don't bother with SIGKILL.  It's uncatchable, which\n// means that we can't fire any callbacks anyway.\n//\n// If a user does happen to register a handler on a non-\n// fatal signal like SIGWINCH or something, and then\n// exit, it'll end up firing `process.emit('exit')`, so\n// the handler will be fired anyway.\n//\n// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n// artificially, inherently leave the process in a\n// state from which it is not safe to try and enter JS\n// listeners.\nmodule.exports = [\n  'SIGABRT',\n  'SIGALRM',\n  'SIGHUP',\n  'SIGINT',\n  'SIGTERM'\n]\n\nif (process.platform !== 'win32') {\n  module.exports.push(\n    'SIGVTALRM',\n    'SIGXCPU',\n    'SIGXFSZ',\n    'SIGUSR2',\n    'SIGTRAP',\n    'SIGSYS',\n    'SIGQUIT',\n    'SIGIOT'\n    // should detect profiler and enable/disable accordingly.\n    // see #21\n    // 'SIGPROF'\n  )\n}\n\nif (process.platform === 'linux') {\n  module.exports.push(\n    'SIGIO',\n    'SIGPOLL',\n    'SIGPWR',\n    'SIGSTKFLT',\n    'SIGUNUSED'\n  )\n}\n", "// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\nvar assert = require('assert')\nvar signals = require('./signals.js')\nvar isWin = /^win/i.test(process.platform)\n\nvar EE = require('events')\n/* istanbul ignore if */\nif (typeof EE !== 'function') {\n  EE = EE.EventEmitter\n}\n\nvar emitter\nif (process.__signal_exit_emitter__) {\n  emitter = process.__signal_exit_emitter__\n} else {\n  emitter = process.__signal_exit_emitter__ = new EE()\n  emitter.count = 0\n  emitter.emitted = {}\n}\n\n// Because this emitter is a global, we have to check to see if a\n// previous version of this library failed to enable infinite listeners.\n// I know what you're about to say.  But literally everything about\n// signal-exit is a compromise with evil.  Get used to it.\nif (!emitter.infinite) {\n  emitter.setMaxListeners(Infinity)\n  emitter.infinite = true\n}\n\nmodule.exports = function (cb, opts) {\n  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')\n\n  if (loaded === false) {\n    load()\n  }\n\n  var ev = 'exit'\n  if (opts && opts.alwaysLast) {\n    ev = 'afterexit'\n  }\n\n  var remove = function () {\n    emitter.removeListener(ev, cb)\n    if (emitter.listeners('exit').length === 0 &&\n        emitter.listeners('afterexit').length === 0) {\n      unload()\n    }\n  }\n  emitter.on(ev, cb)\n\n  return remove\n}\n\nmodule.exports.unload = unload\nfunction unload () {\n  if (!loaded) {\n    return\n  }\n  loaded = false\n\n  signals.forEach(function (sig) {\n    try {\n      process.removeListener(sig, sigListeners[sig])\n    } catch (er) {}\n  })\n  process.emit = originalProcessEmit\n  process.reallyExit = originalProcessReallyExit\n  emitter.count -= 1\n}\n\nfunction emit (event, code, signal) {\n  if (emitter.emitted[event]) {\n    return\n  }\n  emitter.emitted[event] = true\n  emitter.emit(event, code, signal)\n}\n\n// { <signal>: <listener fn>, ... }\nvar sigListeners = {}\nsignals.forEach(function (sig) {\n  sigListeners[sig] = function listener () {\n    // If there are no other listeners, an exit is coming!\n    // Simplest way: remove us and then re-send the signal.\n    // We know that this will kill the process, so we can\n    // safely emit now.\n    var listeners = process.listeners(sig)\n    if (listeners.length === emitter.count) {\n      unload()\n      emit('exit', null, sig)\n      /* istanbul ignore next */\n      emit('afterexit', null, sig)\n      /* istanbul ignore next */\n      if (isWin && sig === 'SIGHUP') {\n        // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n        // so use a supported signal instead\n        sig = 'SIGINT'\n      }\n      process.kill(process.pid, sig)\n    }\n  }\n})\n\nmodule.exports.signals = function () {\n  return signals\n}\n\nmodule.exports.load = load\n\nvar loaded = false\n\nfunction load () {\n  if (loaded) {\n    return\n  }\n  loaded = true\n\n  // This is the number of onSignalExit's that are in play.\n  // It's important so that we can count the correct number of\n  // listeners on signals, and don't wait for the other one to\n  // handle it instead of us.\n  emitter.count += 1\n\n  signals = signals.filter(function (sig) {\n    try {\n      process.on(sig, sigListeners[sig])\n      return true\n    } catch (er) {\n      return false\n    }\n  })\n\n  process.emit = processEmit\n  process.reallyExit = processReallyExit\n}\n\nvar originalProcessReallyExit = process.reallyExit\nfunction processReallyExit (code) {\n  process.exitCode = code || 0\n  emit('exit', process.exitCode, null)\n  /* istanbul ignore next */\n  emit('afterexit', process.exitCode, null)\n  /* istanbul ignore next */\n  originalProcessReallyExit.call(process, process.exitCode)\n}\n\nvar originalProcessEmit = process.emit\nfunction processEmit (ev, arg) {\n  if (ev === 'exit') {\n    if (arg !== undefined) {\n      process.exitCode = arg\n    }\n    var ret = originalProcessEmit.apply(this, arguments)\n    emit('exit', process.exitCode, null)\n    /* istanbul ignore next */\n    emit('afterexit', process.exitCode, null)\n    return ret\n  } else {\n    return originalProcessEmit.apply(this, arguments)\n  }\n}\n", "'use strict';\nconst os = require('os');\nconst onExit = require('signal-exit');\n\nconst DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;\n\n// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior\nconst spawnedKill = (kill, signal = 'SIGTERM', options = {}) => {\n\tconst killResult = kill(signal);\n\tsetKillTimeout(kill, signal, options, killResult);\n\treturn killResult;\n};\n\nconst setKillTimeout = (kill, signal, options, killResult) => {\n\tif (!shouldForceKill(signal, options, killResult)) {\n\t\treturn;\n\t}\n\n\tconst timeout = getForceKillAfterTimeout(options);\n\tconst t = setTimeout(() => {\n\t\tkill('SIGKILL');\n\t}, timeout);\n\n\t// Guarded because there's no `.unref()` when `execa` is used in the renderer\n\t// process in Electron. This cannot be tested since we don't run tests in\n\t// Electron.\n\t// istanbul ignore else\n\tif (t.unref) {\n\t\tt.unref();\n\t}\n};\n\nconst shouldForceKill = (signal, {forceKillAfterTimeout}, killResult) => {\n\treturn isSigterm(signal) && forceKillAfterTimeout !== false && killResult;\n};\n\nconst isSigterm = signal => {\n\treturn signal === os.constants.signals.SIGTERM ||\n\t\t(typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM');\n};\n\nconst getForceKillAfterTimeout = ({forceKillAfterTimeout = true}) => {\n\tif (forceKillAfterTimeout === true) {\n\t\treturn DEFAULT_FORCE_KILL_TIMEOUT;\n\t}\n\n\tif (!Number.isInteger(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {\n\t\tthrow new TypeError(`Expected the \\`forceKillAfterTimeout\\` option to be a non-negative integer, got \\`${forceKillAfterTimeout}\\` (${typeof forceKillAfterTimeout})`);\n\t}\n\n\treturn forceKillAfterTimeout;\n};\n\n// `childProcess.cancel()`\nconst spawnedCancel = (spawned, context) => {\n\tconst killResult = spawned.kill();\n\n\tif (killResult) {\n\t\tcontext.isCanceled = true;\n\t}\n};\n\nconst timeoutKill = (spawned, signal, reject) => {\n\tspawned.kill(signal);\n\treject(Object.assign(new Error('Timed out'), {timedOut: true, signal}));\n};\n\n// `timeout` option handling\nconst setupTimeout = (spawned, {timeout, killSignal = 'SIGTERM'}, spawnedPromise) => {\n\tif (timeout === 0 || timeout === undefined) {\n\t\treturn spawnedPromise;\n\t}\n\n\tif (!Number.isInteger(timeout) || timeout < 0) {\n\t\tthrow new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n\t}\n\n\tlet timeoutId;\n\tconst timeoutPromise = new Promise((resolve, reject) => {\n\t\ttimeoutId = setTimeout(() => {\n\t\t\ttimeoutKill(spawned, killSignal, reject);\n\t\t}, timeout);\n\t});\n\n\tconst safeSpawnedPromise = spawnedPromise.finally(() => {\n\t\tclearTimeout(timeoutId);\n\t});\n\n\treturn Promise.race([timeoutPromise, safeSpawnedPromise]);\n};\n\n// `cleanup` option handling\nconst setExitHandler = async (spawned, {cleanup, detached}, timedPromise) => {\n\tif (!cleanup || detached) {\n\t\treturn timedPromise;\n\t}\n\n\tconst removeExitHandler = onExit(() => {\n\t\tspawned.kill();\n\t});\n\n\treturn timedPromise.finally(() => {\n\t\tremoveExitHandler();\n\t});\n};\n\nmodule.exports = {\n\tspawnedKill,\n\tspawnedCancel,\n\tsetupTimeout,\n\tsetExitHandler\n};\n", "'use strict';\n\nconst isStream = stream =>\n\tstream !== null &&\n\ttypeof stream === 'object' &&\n\ttypeof stream.pipe === 'function';\n\nisStream.writable = stream =>\n\tisStream(stream) &&\n\tstream.writable !== false &&\n\ttypeof stream._write === 'function' &&\n\ttypeof stream._writableState === 'object';\n\nisStream.readable = stream =>\n\tisStream(stream) &&\n\tstream.readable !== false &&\n\ttypeof stream._read === 'function' &&\n\ttypeof stream._readableState === 'object';\n\nisStream.duplex = stream =>\n\tisStream.writable(stream) &&\n\tisStream.readable(stream);\n\nisStream.transform = stream =>\n\tisStream.duplex(stream) &&\n\ttypeof stream._transform === 'function' &&\n\ttypeof stream._transformState === 'object';\n\nmodule.exports = isStream;\n", "// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n", "var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n", "var once = require('once');\n\nvar noop = function() {};\n\nvar isRequest = function(stream) {\n\treturn stream.setHeader && typeof stream.abort === 'function';\n};\n\nvar isChildProcess = function(stream) {\n\treturn stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3\n};\n\nvar eos = function(stream, opts, callback) {\n\tif (typeof opts === 'function') return eos(stream, null, opts);\n\tif (!opts) opts = {};\n\n\tcallback = once(callback || noop);\n\n\tvar ws = stream._writableState;\n\tvar rs = stream._readableState;\n\tvar readable = opts.readable || (opts.readable !== false && stream.readable);\n\tvar writable = opts.writable || (opts.writable !== false && stream.writable);\n\tvar cancelled = false;\n\n\tvar onlegacyfinish = function() {\n\t\tif (!stream.writable) onfinish();\n\t};\n\n\tvar onfinish = function() {\n\t\twritable = false;\n\t\tif (!readable) callback.call(stream);\n\t};\n\n\tvar onend = function() {\n\t\treadable = false;\n\t\tif (!writable) callback.call(stream);\n\t};\n\n\tvar onexit = function(exitCode) {\n\t\tcallback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\n\t};\n\n\tvar onerror = function(err) {\n\t\tcallback.call(stream, err);\n\t};\n\n\tvar onclose = function() {\n\t\tprocess.nextTick(onclosenexttick);\n\t};\n\n\tvar onclosenexttick = function() {\n\t\tif (cancelled) return;\n\t\tif (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));\n\t\tif (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));\n\t};\n\n\tvar onrequest = function() {\n\t\tstream.req.on('finish', onfinish);\n\t};\n\n\tif (isRequest(stream)) {\n\t\tstream.on('complete', onfinish);\n\t\tstream.on('abort', onclose);\n\t\tif (stream.req) onrequest();\n\t\telse stream.on('request', onrequest);\n\t} else if (writable && !ws) { // legacy streams\n\t\tstream.on('end', onlegacyfinish);\n\t\tstream.on('close', onlegacyfinish);\n\t}\n\n\tif (isChildProcess(stream)) stream.on('exit', onexit);\n\n\tstream.on('end', onend);\n\tstream.on('finish', onfinish);\n\tif (opts.error !== false) stream.on('error', onerror);\n\tstream.on('close', onclose);\n\n\treturn function() {\n\t\tcancelled = true;\n\t\tstream.removeListener('complete', onfinish);\n\t\tstream.removeListener('abort', onclose);\n\t\tstream.removeListener('request', onrequest);\n\t\tif (stream.req) stream.req.removeListener('finish', onfinish);\n\t\tstream.removeListener('end', onlegacyfinish);\n\t\tstream.removeListener('close', onlegacyfinish);\n\t\tstream.removeListener('finish', onfinish);\n\t\tstream.removeListener('exit', onexit);\n\t\tstream.removeListener('end', onend);\n\t\tstream.removeListener('error', onerror);\n\t\tstream.removeListener('close', onclose);\n\t};\n};\n\nmodule.exports = eos;\n", "var once = require('once')\nvar eos = require('end-of-stream')\nvar fs = require('fs') // we only need fs to get the ReadStream and WriteStream prototypes\n\nvar noop = function () {}\nvar ancient = /^v?\\.0/.test(process.version)\n\nvar isFn = function (fn) {\n  return typeof fn === 'function'\n}\n\nvar isFS = function (stream) {\n  if (!ancient) return false // newer node version do not need to care about fs is a special way\n  if (!fs) return false // browser\n  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)\n}\n\nvar isRequest = function (stream) {\n  return stream.setHeader && isFn(stream.abort)\n}\n\nvar destroyer = function (stream, reading, writing, callback) {\n  callback = once(callback)\n\n  var closed = false\n  stream.on('close', function () {\n    closed = true\n  })\n\n  eos(stream, {readable: reading, writable: writing}, function (err) {\n    if (err) return callback(err)\n    closed = true\n    callback()\n  })\n\n  var destroyed = false\n  return function (err) {\n    if (closed) return\n    if (destroyed) return\n    destroyed = true\n\n    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks\n    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want\n\n    if (isFn(stream.destroy)) return stream.destroy()\n\n    callback(err || new Error('stream was destroyed'))\n  }\n}\n\nvar call = function (fn) {\n  fn()\n}\n\nvar pipe = function (from, to) {\n  return from.pipe(to)\n}\n\nvar pump = function () {\n  var streams = Array.prototype.slice.call(arguments)\n  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop\n\n  if (Array.isArray(streams[0])) streams = streams[0]\n  if (streams.length < 2) throw new Error('pump requires two streams per minimum')\n\n  var error\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1\n    var writing = i > 0\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err\n      if (err) destroys.forEach(call)\n      if (reading) return\n      destroys.forEach(call)\n      callback(error)\n    })\n  })\n\n  return streams.reduce(pipe)\n}\n\nmodule.exports = pump\n", "'use strict';\nconst {PassThrough: PassThroughStream} = require('stream');\n\nmodule.exports = options => {\n\toptions = {...options};\n\n\tconst {array} = options;\n\tlet {encoding} = options;\n\tconst isBuffer = encoding === 'buffer';\n\tlet objectMode = false;\n\n\tif (array) {\n\t\tobjectMode = !(encoding || isBuffer);\n\t} else {\n\t\tencoding = encoding || 'utf8';\n\t}\n\n\tif (isBuffer) {\n\t\tencoding = null;\n\t}\n\n\tconst stream = new PassThroughStream({objectMode});\n\n\tif (encoding) {\n\t\tstream.setEncoding(encoding);\n\t}\n\n\tlet length = 0;\n\tconst chunks = [];\n\n\tstream.on('data', chunk => {\n\t\tchunks.push(chunk);\n\n\t\tif (objectMode) {\n\t\t\tlength = chunks.length;\n\t\t} else {\n\t\t\tlength += chunk.length;\n\t\t}\n\t});\n\n\tstream.getBufferedValue = () => {\n\t\tif (array) {\n\t\t\treturn chunks;\n\t\t}\n\n\t\treturn isBuffer ? Buffer.concat(chunks, length) : chunks.join('');\n\t};\n\n\tstream.getBufferedLength = () => length;\n\n\treturn stream;\n};\n", "'use strict';\nconst pump = require('pump');\nconst bufferStream = require('./buffer-stream');\n\nclass MaxBufferError extends Error {\n\tconstructor() {\n\t\tsuper('maxBuffer exceeded');\n\t\tthis.name = 'MaxBufferError';\n\t}\n}\n\nasync function getStream(inputStream, options) {\n\tif (!inputStream) {\n\t\treturn Promise.reject(new Error('Expected a stream'));\n\t}\n\n\toptions = {\n\t\tmaxBuffer: Infinity,\n\t\t...options\n\t};\n\n\tconst {maxBuffer} = options;\n\n\tlet stream;\n\tawait new Promise((resolve, reject) => {\n\t\tconst rejectPromise = error => {\n\t\t\tif (error) { // A null check\n\t\t\t\terror.bufferedData = stream.getBufferedValue();\n\t\t\t}\n\n\t\t\treject(error);\n\t\t};\n\n\t\tstream = pump(inputStream, bufferStream(options), error => {\n\t\t\tif (error) {\n\t\t\t\trejectPromise(error);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolve();\n\t\t});\n\n\t\tstream.on('data', () => {\n\t\t\tif (stream.getBufferedLength() > maxBuffer) {\n\t\t\t\trejectPromise(new MaxBufferError());\n\t\t\t}\n\t\t});\n\t});\n\n\treturn stream.getBufferedValue();\n}\n\nmodule.exports = getStream;\n// TODO: Remove this for the next major release\nmodule.exports.default = getStream;\nmodule.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});\nmodule.exports.array = (stream, options) => getStream(stream, {...options, array: true});\nmodule.exports.MaxBufferError = MaxBufferError;\n", "'use strict';\n\nconst { PassThrough } = require('stream');\n\nmodule.exports = function (/*streams...*/) {\n  var sources = []\n  var output  = new PassThrough({objectMode: true})\n\n  output.setMaxListeners(0)\n\n  output.add = add\n  output.isEmpty = isEmpty\n\n  output.on('unpipe', remove)\n\n  Array.prototype.slice.call(arguments).forEach(add)\n\n  return output\n\n  function add (source) {\n    if (Array.isArray(source)) {\n      source.forEach(add)\n      return this\n    }\n\n    sources.push(source);\n    source.once('end', remove.bind(null, source))\n    source.once('error', output.emit.bind(output, 'error'))\n    source.pipe(output, {end: false})\n    return this\n  }\n\n  function isEmpty () {\n    return sources.length == 0;\n  }\n\n  function remove (source) {\n    sources = sources.filter(function (it) { return it !== source })\n    if (!sources.length && output.readable) { output.end() }\n  }\n}\n", "'use strict';\nconst isStream = require('is-stream');\nconst getStream = require('get-stream');\nconst mergeStream = require('merge-stream');\n\n// `input` option\nconst handleInput = (spawned, input) => {\n\t// Checking for stdin is workaround for https://github.com/nodejs/node/issues/26852\n\t// TODO: Remove `|| spawned.stdin === undefined` once we drop support for Node.js <=12.2.0\n\tif (input === undefined || spawned.stdin === undefined) {\n\t\treturn;\n\t}\n\n\tif (isStream(input)) {\n\t\tinput.pipe(spawned.stdin);\n\t} else {\n\t\tspawned.stdin.end(input);\n\t}\n};\n\n// `all` interleaves `stdout` and `stderr`\nconst makeAllStream = (spawned, {all}) => {\n\tif (!all || (!spawned.stdout && !spawned.stderr)) {\n\t\treturn;\n\t}\n\n\tconst mixed = mergeStream();\n\n\tif (spawned.stdout) {\n\t\tmixed.add(spawned.stdout);\n\t}\n\n\tif (spawned.stderr) {\n\t\tmixed.add(spawned.stderr);\n\t}\n\n\treturn mixed;\n};\n\n// On failure, `result.stdout|stderr|all` should contain the currently buffered stream\nconst getBufferedData = async (stream, streamPromise) => {\n\tif (!stream) {\n\t\treturn;\n\t}\n\n\tstream.destroy();\n\n\ttry {\n\t\treturn await streamPromise;\n\t} catch (error) {\n\t\treturn error.bufferedData;\n\t}\n};\n\nconst getStreamPromise = (stream, {encoding, buffer, maxBuffer}) => {\n\tif (!stream || !buffer) {\n\t\treturn;\n\t}\n\n\tif (encoding) {\n\t\treturn getStream(stream, {encoding, maxBuffer});\n\t}\n\n\treturn getStream.buffer(stream, {maxBuffer});\n};\n\n// Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)\nconst getSpawnedResult = async ({stdout, stderr, all}, {encoding, buffer, maxBuffer}, processDone) => {\n\tconst stdoutPromise = getStreamPromise(stdout, {encoding, buffer, maxBuffer});\n\tconst stderrPromise = getStreamPromise(stderr, {encoding, buffer, maxBuffer});\n\tconst allPromise = getStreamPromise(all, {encoding, buffer, maxBuffer: maxBuffer * 2});\n\n\ttry {\n\t\treturn await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);\n\t} catch (error) {\n\t\treturn Promise.all([\n\t\t\t{error, signal: error.signal, timedOut: error.timedOut},\n\t\t\tgetBufferedData(stdout, stdoutPromise),\n\t\t\tgetBufferedData(stderr, stderrPromise),\n\t\t\tgetBufferedData(all, allPromise)\n\t\t]);\n\t}\n};\n\nconst validateInputSync = ({input}) => {\n\tif (isStream(input)) {\n\t\tthrow new TypeError('The `input` option cannot be a stream in sync mode');\n\t}\n};\n\nmodule.exports = {\n\thandleInput,\n\tmakeAllStream,\n\tgetSpawnedResult,\n\tvalidateInputSync\n};\n\n", "'use strict';\n\nconst nativePromisePrototype = (async () => {})().constructor.prototype;\nconst descriptors = ['then', 'catch', 'finally'].map(property => [\n\tproperty,\n\tReflect.getOwnPropertyDescriptor(nativePromisePrototype, property)\n]);\n\n// The return value is a mixin of `childProcess` and `Promise`\nconst mergePromise = (spawned, promise) => {\n\tfor (const [property, descriptor] of descriptors) {\n\t\t// Starting the main `promise` is deferred to avoid consuming streams\n\t\tconst value = typeof promise === 'function' ?\n\t\t\t(...args) => Reflect.apply(descriptor.value, promise(), args) :\n\t\t\tdescriptor.value.bind(promise);\n\n\t\tReflect.defineProperty(spawned, property, {...descriptor, value});\n\t}\n\n\treturn spawned;\n};\n\n// Use promises instead of `child_process` events\nconst getSpawnedPromise = spawned => {\n\treturn new Promise((resolve, reject) => {\n\t\tspawned.on('exit', (exitCode, signal) => {\n\t\t\tresolve({exitCode, signal});\n\t\t});\n\n\t\tspawned.on('error', error => {\n\t\t\treject(error);\n\t\t});\n\n\t\tif (spawned.stdin) {\n\t\t\tspawned.stdin.on('error', error => {\n\t\t\t\treject(error);\n\t\t\t});\n\t\t}\n\t});\n};\n\nmodule.exports = {\n\tmergePromise,\n\tgetSpawnedPromise\n};\n\n", "'use strict';\nconst SPACES_REGEXP = / +/g;\n\nconst joinCommand = (file, args = []) => {\n\tif (!Array.isArray(args)) {\n\t\treturn file;\n\t}\n\n\treturn [file, ...args].join(' ');\n};\n\n// Allow spaces to be escaped by a backslash if not meant as a delimiter\nconst handleEscaping = (tokens, token, index) => {\n\tif (index === 0) {\n\t\treturn [token];\n\t}\n\n\tconst previousToken = tokens[tokens.length - 1];\n\n\tif (previousToken.endsWith('\\\\')) {\n\t\treturn [...tokens.slice(0, -1), `${previousToken.slice(0, -1)} ${token}`];\n\t}\n\n\treturn [...tokens, token];\n};\n\n// Handle `execa.command()`\nconst parseCommand = command => {\n\treturn command\n\t\t.trim()\n\t\t.split(SPACES_REGEXP)\n\t\t.reduce(handleEscaping, []);\n};\n\nmodule.exports = {\n\tjoinCommand,\n\tparseCommand\n};\n", "'use strict';\nconst path = require('path');\nconst childProcess = require('child_process');\nconst crossSpawn = require('cross-spawn');\nconst stripFinalNewline = require('strip-final-newline');\nconst npmRunPath = require('npm-run-path');\nconst onetime = require('onetime');\nconst makeError = require('./lib/error');\nconst normalizeStdio = require('./lib/stdio');\nconst {spawnedKill, spawnedCancel, setupTimeout, setExitHandler} = require('./lib/kill');\nconst {handleInput, getSpawnedResult, makeAllStream, validateInputSync} = require('./lib/stream.js');\nconst {mergePromise, getSpawnedPromise} = require('./lib/promise.js');\nconst {joinCommand, parseCommand} = require('./lib/command.js');\n\nconst DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;\n\nconst getEnv = ({env: envOption, extendEnv, preferLocal, localDir, execPath}) => {\n\tconst env = extendEnv ? {...process.env, ...envOption} : envOption;\n\n\tif (preferLocal) {\n\t\treturn npmRunPath.env({env, cwd: localDir, execPath});\n\t}\n\n\treturn env;\n};\n\nconst handleArgs = (file, args, options = {}) => {\n\tconst parsed = crossSpawn._parse(file, args, options);\n\tfile = parsed.command;\n\targs = parsed.args;\n\toptions = parsed.options;\n\n\toptions = {\n\t\tmaxBuffer: DEFAULT_MAX_BUFFER,\n\t\tbuffer: true,\n\t\tstripFinalNewline: true,\n\t\textendEnv: true,\n\t\tpreferLocal: false,\n\t\tlocalDir: options.cwd || process.cwd(),\n\t\texecPath: process.execPath,\n\t\tencoding: 'utf8',\n\t\treject: true,\n\t\tcleanup: true,\n\t\tall: false,\n\t\twindowsHide: true,\n\t\t...options\n\t};\n\n\toptions.env = getEnv(options);\n\n\toptions.stdio = normalizeStdio(options);\n\n\tif (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {\n\t\t// #116\n\t\targs.unshift('/q');\n\t}\n\n\treturn {file, args, options, parsed};\n};\n\nconst handleOutput = (options, value, error) => {\n\tif (typeof value !== 'string' && !Buffer.isBuffer(value)) {\n\t\t// When `execa.sync()` errors, we normalize it to '' to mimic `execa()`\n\t\treturn error === undefined ? undefined : '';\n\t}\n\n\tif (options.stripFinalNewline) {\n\t\treturn stripFinalNewline(value);\n\t}\n\n\treturn value;\n};\n\nconst execa = (file, args, options) => {\n\tconst parsed = handleArgs(file, args, options);\n\tconst command = joinCommand(file, args);\n\n\tlet spawned;\n\ttry {\n\t\tspawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);\n\t} catch (error) {\n\t\t// Ensure the returned error is always both a promise and a child process\n\t\tconst dummySpawned = new childProcess.ChildProcess();\n\t\tconst errorPromise = Promise.reject(makeError({\n\t\t\terror,\n\t\t\tstdout: '',\n\t\t\tstderr: '',\n\t\t\tall: '',\n\t\t\tcommand,\n\t\t\tparsed,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false\n\t\t}));\n\t\treturn mergePromise(dummySpawned, errorPromise);\n\t}\n\n\tconst spawnedPromise = getSpawnedPromise(spawned);\n\tconst timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);\n\tconst processDone = setExitHandler(spawned, parsed.options, timedPromise);\n\n\tconst context = {isCanceled: false};\n\n\tspawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));\n\tspawned.cancel = spawnedCancel.bind(null, spawned, context);\n\n\tconst handlePromise = async () => {\n\t\tconst [{error, exitCode, signal, timedOut}, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);\n\t\tconst stdout = handleOutput(parsed.options, stdoutResult);\n\t\tconst stderr = handleOutput(parsed.options, stderrResult);\n\t\tconst all = handleOutput(parsed.options, allResult);\n\n\t\tif (error || exitCode !== 0 || signal !== null) {\n\t\t\tconst returnedError = makeError({\n\t\t\t\terror,\n\t\t\t\texitCode,\n\t\t\t\tsignal,\n\t\t\t\tstdout,\n\t\t\t\tstderr,\n\t\t\t\tall,\n\t\t\t\tcommand,\n\t\t\t\tparsed,\n\t\t\t\ttimedOut,\n\t\t\t\tisCanceled: context.isCanceled,\n\t\t\t\tkilled: spawned.killed\n\t\t\t});\n\n\t\t\tif (!parsed.options.reject) {\n\t\t\t\treturn returnedError;\n\t\t\t}\n\n\t\t\tthrow returnedError;\n\t\t}\n\n\t\treturn {\n\t\t\tcommand,\n\t\t\texitCode: 0,\n\t\t\tstdout,\n\t\t\tstderr,\n\t\t\tall,\n\t\t\tfailed: false,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false\n\t\t};\n\t};\n\n\tconst handlePromiseOnce = onetime(handlePromise);\n\n\tcrossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);\n\n\thandleInput(spawned, parsed.options.input);\n\n\tspawned.all = makeAllStream(spawned, parsed.options);\n\n\treturn mergePromise(spawned, handlePromiseOnce);\n};\n\nmodule.exports = execa;\n\nmodule.exports.sync = (file, args, options) => {\n\tconst parsed = handleArgs(file, args, options);\n\tconst command = joinCommand(file, args);\n\n\tvalidateInputSync(parsed.options);\n\n\tlet result;\n\ttry {\n\t\tresult = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);\n\t} catch (error) {\n\t\tthrow makeError({\n\t\t\terror,\n\t\t\tstdout: '',\n\t\t\tstderr: '',\n\t\t\tall: '',\n\t\t\tcommand,\n\t\t\tparsed,\n\t\t\ttimedOut: false,\n\t\t\tisCanceled: false,\n\t\t\tkilled: false\n\t\t});\n\t}\n\n\tconst stdout = handleOutput(parsed.options, result.stdout, result.error);\n\tconst stderr = handleOutput(parsed.options, result.stderr, result.error);\n\n\tif (result.error || result.status !== 0 || result.signal !== null) {\n\t\tconst error = makeError({\n\t\t\tstdout,\n\t\t\tstderr,\n\t\t\terror: result.error,\n\t\t\tsignal: result.signal,\n\t\t\texitCode: result.status,\n\t\t\tcommand,\n\t\t\tparsed,\n\t\t\ttimedOut: result.error && result.error.code === 'ETIMEDOUT',\n\t\t\tisCanceled: false,\n\t\t\tkilled: result.signal !== null\n\t\t});\n\n\t\tif (!parsed.options.reject) {\n\t\t\treturn error;\n\t\t}\n\n\t\tthrow error;\n\t}\n\n\treturn {\n\t\tcommand,\n\t\texitCode: 0,\n\t\tstdout,\n\t\tstderr,\n\t\tfailed: false,\n\t\ttimedOut: false,\n\t\tisCanceled: false,\n\t\tkilled: false\n\t};\n};\n\nmodule.exports.command = (command, options) => {\n\tconst [file, ...args] = parseCommand(command);\n\treturn execa(file, args, options);\n};\n\nmodule.exports.commandSync = (command, options) => {\n\tconst [file, ...args] = parseCommand(command);\n\treturn execa.sync(file, args, options);\n};\n\nmodule.exports.node = (scriptPath, args, options = {}) => {\n\tif (args && !Array.isArray(args) && typeof args === 'object') {\n\t\toptions = args;\n\t\targs = [];\n\t}\n\n\tconst stdio = normalizeStdio.node(options);\n\n\tconst {nodePath = process.execPath, nodeOptions = process.execArgv} = options;\n\n\treturn execa(\n\t\tnodePath,\n\t\t[\n\t\t\t...nodeOptions,\n\t\t\tscriptPath,\n\t\t\t...(Array.isArray(args) ? args : [])\n\t\t],\n\t\t{\n\t\t\t...options,\n\t\t\tstdin: undefined,\n\t\t\tstdout: undefined,\n\t\t\tstderr: undefined,\n\t\t\tstdio,\n\t\t\tshell: false\n\t\t}\n\t);\n};\n", null, "'use strict';\nconst {PassThrough: PassThroughStream} = require('stream');\n\nmodule.exports = options => {\n\toptions = {...options};\n\n\tconst {array} = options;\n\tlet {encoding} = options;\n\tconst isBuffer = encoding === 'buffer';\n\tlet objectMode = false;\n\n\tif (array) {\n\t\tobjectMode = !(encoding || isBuffer);\n\t} else {\n\t\tencoding = encoding || 'utf8';\n\t}\n\n\tif (isBuffer) {\n\t\tencoding = null;\n\t}\n\n\tconst stream = new PassThroughStream({objectMode});\n\n\tif (encoding) {\n\t\tstream.setEncoding(encoding);\n\t}\n\n\tlet length = 0;\n\tconst chunks = [];\n\n\tstream.on('data', chunk => {\n\t\tchunks.push(chunk);\n\n\t\tif (objectMode) {\n\t\t\tlength = chunks.length;\n\t\t} else {\n\t\t\tlength += chunk.length;\n\t\t}\n\t});\n\n\tstream.getBufferedValue = () => {\n\t\tif (array) {\n\t\t\treturn chunks;\n\t\t}\n\n\t\treturn isBuffer ? Buffer.concat(chunks, length) : chunks.join('');\n\t};\n\n\tstream.getBufferedLength = () => length;\n\n\treturn stream;\n};\n", "'use strict';\nconst {constants: BufferConstants} = require('buffer');\nconst stream = require('stream');\nconst {promisify} = require('util');\nconst bufferStream = require('./buffer-stream');\n\nconst streamPipelinePromisified = promisify(stream.pipeline);\n\nclass MaxBufferError extends Error {\n\tconstructor() {\n\t\tsuper('maxBuffer exceeded');\n\t\tthis.name = 'MaxBufferError';\n\t}\n}\n\nasync function getStream(inputStream, options) {\n\tif (!inputStream) {\n\t\tthrow new Error('Expected a stream');\n\t}\n\n\toptions = {\n\t\tmaxBuffer: Infinity,\n\t\t...options\n\t};\n\n\tconst {maxBuffer} = options;\n\tconst stream = bufferStream(options);\n\n\tawait new Promise((resolve, reject) => {\n\t\tconst rejectPromise = error => {\n\t\t\t// Don't retrieve an oversized buffer.\n\t\t\tif (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {\n\t\t\t\terror.bufferedData = stream.getBufferedValue();\n\t\t\t}\n\n\t\t\treject(error);\n\t\t};\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tawait streamPipelinePromisified(inputStream, stream);\n\t\t\t\tresolve();\n\t\t\t} catch (error) {\n\t\t\t\trejectPromise(error);\n\t\t\t}\n\t\t})();\n\n\t\tstream.on('data', () => {\n\t\t\tif (stream.getBufferedLength() > maxBuffer) {\n\t\t\t\trejectPromise(new MaxBufferError());\n\t\t\t}\n\t\t});\n\t});\n\n\treturn stream.getBufferedValue();\n}\n\nmodule.exports = getStream;\nmodule.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});\nmodule.exports.array = (stream, options) => getStream(stream, {...options, array: true});\nmodule.exports.MaxBufferError = MaxBufferError;\n", "'use strict'\n\n// TODO: This is not really allowed by Node but it works for now.\nconst { HTTPParser } = process.binding('http_parser') // eslint-disable-line\n\nmodule.exports = HTTPParser\n", "module.exports = {\n  kUrl: Symbol('url'),\n  kWriting: Symbol('writing'),\n  kResuming: Symbol('resuming'),\n  kQueue: Symbol('queue'),\n  kConnect: Symbol('connect'),\n  kResume: Symbol('resume'),\n  kPause: Symbol('pause'),\n  kSocketTimeout: Symbol('socket timeout'),\n  kIdleTimeout: Symbol('idle timeout'),\n  kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),\n  kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),\n  kKeepAliveTimeout: Symbol('keep alive timeout'),\n  kKeepAlive: Symbol('keep alive'),\n  kTLSServerName: Symbol('server name'),\n  kHost: Symbol('host'),\n  kTLSOpts: Symbol('TLS Options'),\n  kClosed: Symbol('closed'),\n  kNeedDrain: Symbol('need drain'),\n  kReset: Symbol('reset'),\n  kDestroyed: Symbol('destroyed'),\n  kMaxHeadersSize: Symbol('max headers size'),\n  kHeadersTimeout: Symbol('headers timeout'),\n  kRunningIdx: Symbol('running index'),\n  kPendingIdx: Symbol('pending index'),\n  kError: Symbol('error'),\n  kClient: Symbol('client'),\n  kParser: Symbol('parser'),\n  kOnDestroyed: Symbol('destroy callbacks'),\n  kPipelining: Symbol('pipelinig'),\n  kRetryDelay: Symbol('retry delay'),\n  kSocketPath: Symbol('socket path'),\n  kSocket: Symbol('socket'),\n  kRetryTimeout: Symbol('retry timeout'),\n  kTLSSession: Symbol('tls session cache')\n}\n", "'use strict'\n\nconst assert = require('assert')\nconst { kDestroyed } = require('./symbols')\nconst { IncomingMessage } = require('http')\nconst util = require('util')\n\nfunction nop () {}\n\nfunction isStream (body) {\n  return !!(body && typeof body.on === 'function')\n}\n\nfunction bodyLength (body) {\n  if (body && typeof body.on === 'function') {\n    const state = body._readableState\n    return state && state.ended === true && Number.isFinite(state.length)\n      ? state.length\n      : null\n  }\n\n  assert(!body || Number.isFinite(body.byteLength))\n\n  return body ? body.length : 0\n}\n\nfunction isDestroyed (stream) {\n  return !stream || !!(stream.destroyed || stream[kDestroyed])\n}\n\nfunction destroy (stream, err) {\n  if (!isStream(stream) || isDestroyed(stream)) {\n    return\n  }\n\n  if (typeof stream.destroy === 'function') {\n    if (err || Object.getPrototypeOf(stream).constructor !== IncomingMessage) {\n      stream.destroy(err)\n    }\n  } else if (err) {\n    process.nextTick((stream, err) => {\n      stream.emit('error', err)\n    }, stream, err)\n  }\n\n  if (stream.destroyed !== true) {\n    stream[kDestroyed] = true\n  }\n}\n\nconst KEEPALIVE_TIMEOUT_EXPR = /timeout=(\\d+)s/\nfunction parseKeepAliveTimeout (val) {\n  const m = val.match(KEEPALIVE_TIMEOUT_EXPR)\n  return m ? parseInt(m[1]) * 1000 : null\n}\n\nfunction parseHeaders (headers) {\n  const obj = {}\n  for (var i = 0; i < headers.length; i += 2) {\n    var key = headers[i].toLowerCase()\n    var val = obj[key]\n    if (!val) {\n      obj[key] = headers[i + 1]\n    } else {\n      if (!Array.isArray(val)) {\n        val = [val]\n        obj[key] = val\n      }\n      val.push(headers[i + 1])\n    }\n  }\n  return obj\n}\n\nfunction isBuffer (buffer) {\n  // See, https://github.com/mcollina/undici/pull/319\n  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer)\n}\n\nfunction errnoException (code, syscall) {\n  const name = util.getSystemErrorName(code)\n\n  const err = new Error(`${syscall} ${name}`)\n  err.errno = err\n  err.code = code\n  err.syscall = syscall\n\n  return err\n}\n\nmodule.exports = {\n  nop,\n  errnoException,\n  isStream,\n  isDestroyed,\n  parseHeaders,\n  parseKeepAliveTimeout,\n  destroy,\n  bodyLength,\n  isBuffer\n}\n", "'use strict'\n\nclass UndiciError extends Error {\n  constructor (message) {\n    super(message)\n    this.name = 'UndiciError'\n    this.code = 'UND_ERR'\n  }\n}\n\nclass HeadersTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, HeadersTimeoutError)\n    this.name = 'HeadersTimeoutError'\n    this.message = message || 'Headers Timeout Error'\n    this.code = 'UND_ERR_HEADERS_TIMEOUT'\n  }\n}\n\nclass SocketTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, SocketTimeoutError)\n    this.name = 'SocketTimeoutError'\n    this.message = message || 'Socket Timeout Error'\n    this.code = 'UND_ERR_SOCKET_TIMEOUT'\n  }\n}\n\nclass RequestTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, RequestTimeoutError)\n    this.name = 'RequestTimeoutError'\n    this.message = message || 'Request Timeout Error'\n    this.code = 'UND_ERR_REQUEST_TIMEOUT'\n  }\n}\n\nclass InvalidArgumentError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, InvalidArgumentError)\n    this.name = 'InvalidArgumentError'\n    this.message = message || /* istanbul ignore next */ 'Invalid Argument Error'\n    this.code = 'UND_ERR_INVALID_ARG'\n  }\n}\n\nclass InvalidReturnValueError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, InvalidReturnValueError)\n    this.name = 'InvalidReturnValueError'\n    this.message = message || /* istanbul ignore next */ 'Invalid Return Value Error'\n    this.code = 'UND_ERR_INVALID_RETURN_VALUE'\n  }\n}\n\nclass RequestAbortedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, RequestAbortedError)\n    this.name = 'RequestAbortedError'\n    this.message = message || /* istanbul ignore next */ 'Request aborted'\n    this.code = 'UND_ERR_ABORTED'\n  }\n}\n\nclass InformationalError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, InformationalError)\n    this.name = 'InformationalError'\n    this.message = message || /* istanbul ignore next */ 'Request information'\n    this.code = 'UND_ERR_INFO'\n  }\n}\n\nclass ContentLengthMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, ContentLengthMismatchError)\n    this.name = 'ContentLengthMismatchError'\n    this.message = message || /* istanbul ignore next */ 'Request body length does not match content-length header'\n    this.code = 'UND_ERR_CONTENT_LENGTH_MISMATCH'\n  }\n}\n\nclass TrailerMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, TrailerMismatchError)\n    this.name = 'TrailerMismatchError'\n    this.message = message || /* istanbul ignore next */ 'Trailers does not match trailer header'\n    this.code = 'UND_ERR_TRAILER_MISMATCH'\n  }\n}\n\nclass ClientDestroyedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, ClientDestroyedError)\n    this.name = 'ClientDestroyedError'\n    this.message = message || /* istanbul ignore next */ 'The client is destroyed'\n    this.code = 'UND_ERR_DESTROYED'\n  }\n}\n\nclass ClientClosedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, ClientClosedError)\n    this.name = 'ClientClosedError'\n    this.message = message || /* istanbul ignore next */ 'The client is closed'\n    this.code = 'UND_ERR_CLOSED'\n  }\n}\n\nclass SocketError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, SocketError)\n    this.name = 'SocketError'\n    this.message = message || /* istanbul ignore next */ 'Socket error'\n    this.code = 'UND_ERR_SOCKET'\n  }\n}\n\nclass NotSupportedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, NotSupportedError)\n    this.name = 'NotSupportedError'\n    this.message = message || /* istanbul ignore next */ 'Not supported error'\n    this.code = 'UND_ERR_NOT_SUPPORTED'\n  }\n}\n\nmodule.exports = {\n  UndiciError,\n  SocketTimeoutError,\n  HeadersTimeoutError,\n  RequestTimeoutError,\n  ContentLengthMismatchError,\n  TrailerMismatchError,\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError,\n  ClientDestroyedError,\n  ClientClosedError,\n  InformationalError,\n  SocketError,\n  NotSupportedError\n}\n", "'use strict'\n\nconst {\n  InvalidArgumentError,\n  RequestAbortedError,\n  RequestTimeoutError,\n  NotSupportedError\n} = require('./errors')\nconst util = require('./util')\nconst assert = require('assert')\n\nconst kRequestTimeout = Symbol('request timeout')\nconst kTimeout = Symbol('timeout')\nconst kHandler = Symbol('handler')\n\nclass Request {\n  constructor ({\n    path,\n    method,\n    body,\n    headers,\n    idempotent,\n    upgrade,\n    requestTimeout\n  }, handler) {\n    if (typeof path !== 'string' || path[0] !== '/') {\n      throw new InvalidArgumentError('path must be a valid path')\n    }\n\n    if (typeof method !== 'string') {\n      throw new InvalidArgumentError('method must be a string')\n    }\n\n    if (upgrade && typeof upgrade !== 'string') {\n      throw new InvalidArgumentError('upgrade must be a string')\n    }\n\n    if (requestTimeout != null && (!Number.isInteger(requestTimeout) || requestTimeout < 0)) {\n      throw new InvalidArgumentError('requestTimeout must be a positive integer or zero')\n    }\n\n    this.method = method\n\n    if (body == null) {\n      this.body = null\n    } else if (util.isStream(body)) {\n      this.body = body\n    } else if (util.isBuffer(body)) {\n      this.body = body.length ? body : null\n    } else if (typeof body === 'string') {\n      this.body = body.length ? Buffer.from(body) : null\n    } else {\n      throw new InvalidArgumentError('body must be a string, a Buffer or a Readable stream')\n    }\n\n    this.aborted = false\n\n    this.upgrade = upgrade\n\n    this.path = path\n\n    this.idempotent = idempotent == null\n      ? method === 'HEAD' || method === 'GET'\n      : idempotent\n\n    this.host = null\n\n    this.contentLength = null\n\n    this.headers = ''\n\n    if (Array.isArray(headers)) {\n      if (headers.length % 2 !== 0) {\n        throw new InvalidArgumentError('headers array must be even')\n      }\n      for (let i = 0; i < headers.length; i += 2) {\n        processHeader(this, headers[i], headers[i + 1])\n      }\n    } else if (headers && typeof headers === 'object') {\n      for (const [key, val] of Object.entries(headers)) {\n        processHeader(this, key, val)\n      }\n    } else if (headers != null) {\n      throw new InvalidArgumentError('headers must be an object or an array')\n    }\n\n    this[kRequestTimeout] = requestTimeout != null ? requestTimeout : 30e3\n    this[kTimeout] = null\n    this[kHandler] = handler\n  }\n\n  onConnect (resume) {\n    assert(!this.aborted)\n\n    const abort = (err) => {\n      if (!this.aborted) {\n        this.onError(err || new RequestAbortedError())\n        resume()\n      }\n    }\n\n    if (this[kRequestTimeout]) {\n      if (this[kTimeout]) {\n        clearTimeout(this[kTimeout])\n      }\n\n      this[kTimeout] = setTimeout((abort) => {\n        abort(new RequestTimeoutError())\n      }, this[kRequestTimeout], abort)\n    }\n\n    this[kHandler].onConnect(abort)\n  }\n\n  onHeaders (statusCode, headers, resume) {\n    assert(!this.aborted)\n\n    clearRequestTimeout(this)\n\n    this[kHandler].onHeaders(statusCode, headers, resume)\n  }\n\n  onBody (chunk, offset, length) {\n    assert(!this.aborted)\n\n    return this[kHandler].onData(chunk.slice(offset, offset + length))\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    assert(!this.aborted)\n\n    clearRequestTimeout(this)\n\n    this[kHandler].onUpgrade(statusCode, headers, socket)\n  }\n\n  onComplete (trailers) {\n    assert(!this.aborted)\n\n    clearRequestTimeout(this)\n\n    this[kHandler].onComplete(trailers)\n  }\n\n  onError (err) {\n    if (this.aborted) {\n      return\n    }\n    this.aborted = true\n\n    clearRequestTimeout(this)\n\n    this[kHandler].onError(err)\n  }\n}\n\nfunction processHeader (request, key, val) {\n  if (typeof val === 'object') {\n    throw new InvalidArgumentError(`invalid ${key} header`)\n  } else if (val === undefined) {\n    return\n  }\n\n  if (\n    request.host === null &&\n    key.length === 4 &&\n    key.toLowerCase() === 'host'\n  ) {\n    request.host = val\n    request.headers += `${key}: ${val}\\r\\n`\n  } else if (\n    request.contentLength === null &&\n    key.length === 14 &&\n    key.toLowerCase() === 'content-length'\n  ) {\n    request.contentLength = parseInt(val)\n    if (!Number.isFinite(request.contentLength)) {\n      throw new InvalidArgumentError('invalid content-length header')\n    }\n  } else if (\n    key.length === 17 &&\n    key.toLowerCase() === 'transfer-encoding'\n  ) {\n    throw new InvalidArgumentError('invalid transfer-encoding header')\n  } else if (\n    key.length === 10 &&\n    key.toLowerCase() === 'connection'\n  ) {\n    throw new InvalidArgumentError('invalid connection header')\n  } else if (\n    key.length === 10 &&\n    key.toLowerCase() === 'keep-alive'\n  ) {\n    throw new InvalidArgumentError('invalid keep-alive header')\n  } else if (\n    key.length === 7 &&\n    key.toLowerCase() === 'upgrade'\n  ) {\n    throw new InvalidArgumentError('invalid upgrade header')\n  } else if (\n    key.length === 6 &&\n    key.toLowerCase() === 'expect'\n  ) {\n    throw new NotSupportedError('expect header not supported')\n  } else {\n    request.headers += `${key}: ${val}\\r\\n`\n  }\n}\n\nfunction clearRequestTimeout (request) {\n  const { [kTimeout]: timeout } = request\n  if (timeout) {\n    request[kTimeout] = null\n    clearTimeout(timeout)\n  }\n}\n\nmodule.exports = Request\n", "'use strict'\n\nconst { URL } = require('url')\nconst net = require('net')\nconst tls = require('tls')\nconst HTTPParser = require('../node/http-parser')\nconst EventEmitter = require('events')\nconst assert = require('assert')\nconst util = require('./util')\nconst Request = require('./request')\nconst {\n  ContentLengthMismatchError,\n  SocketTimeoutError,\n  TrailerMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  ClientDestroyedError,\n  ClientClosedError,\n  HeadersTimeoutError,\n  SocketError,\n  InformationalError\n} = require('./errors')\nconst {\n  kUrl,\n  kReset,\n  kPause,\n  kHost,\n  kResume,\n  kClient,\n  kParser,\n  kConnect,\n  kResuming,\n  kWriting,\n  kQueue,\n  kNeedDrain,\n  kTLSServerName,\n  kIdleTimeout,\n  kSocketTimeout,\n  kTLSOpts,\n  kClosed,\n  kDestroyed,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kOnDestroyed,\n  kPipelining,\n  kRetryDelay,\n  kRetryTimeout,\n  kSocket,\n  kSocketPath,\n  kKeepAliveTimeout,\n  kMaxHeadersSize,\n  kHeadersTimeout,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kKeepAlive,\n  kTLSSession\n} = require('./symbols')\n\nconst kHostHeader = Symbol('host header')\n\nconst nodeMajorVersion = parseInt(process.version.split('.')[0].slice(1))\nconst insecureHTTPParser = process.execArgv.includes('--insecure-http-parser')\n\nclass Client extends EventEmitter {\n  constructor (url, {\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    idleTimeout,\n    maxKeepAliveTimeout,\n    keepAlive,\n    keepAliveMaxTimeout = maxKeepAliveTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls\n  } = {}) {\n    super()\n\n    if (typeof url === 'string') {\n      url = new URL(url)\n    }\n\n    if (!url || typeof url !== 'object') {\n      throw new InvalidArgumentError('invalid url')\n    }\n\n    if (url.port != null && url.port !== '' && !Number.isFinite(parseInt(url.port))) {\n      throw new InvalidArgumentError('invalid port')\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (url.hostname != null && typeof url.hostname !== 'string') {\n      throw new InvalidArgumentError('invalid hostname')\n    }\n\n    if (!/https?/.test(url.protocol)) {\n      throw new InvalidArgumentError('invalid protocol')\n    }\n\n    if (/\\/.+/.test(url.pathname) || url.search || url.hash) {\n      throw new InvalidArgumentError('invalid url')\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize')\n    }\n\n    if (socketTimeout != null && !Number.isFinite(socketTimeout)) {\n      throw new InvalidArgumentError('invalid socketTimeout')\n    }\n\n    if (idleTimeout != null && (!Number.isFinite(idleTimeout) || idleTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid idleTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAlive != null && typeof keepAlive !== 'boolean') {\n      throw new InvalidArgumentError('invalid keepAlive')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && !Number.isFinite(headersTimeout)) {\n      throw new InvalidArgumentError('invalid headersTimeout')\n    }\n\n    this[kSocket] = null\n    this[kReset] = false\n    this[kPipelining] = pipelining || 1\n    this[kMaxHeadersSize] = maxHeaderSize || 16384\n    this[kHeadersTimeout] = headersTimeout == null ? 30e3 : headersTimeout\n    this[kUrl] = url\n    this[kSocketPath] = socketPath\n    this[kSocketTimeout] = socketTimeout == null ? 30e3 : socketTimeout\n    this[kIdleTimeout] = idleTimeout == null ? 4e3 : idleTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeout] = this[kIdleTimeout]\n    this[kKeepAlive] = keepAlive == null ? true : keepAlive\n    this[kClosed] = false\n    this[kDestroyed] = false\n    this[kTLSServerName] = (tls && tls.servername) || null\n    this[kHost] = null\n    this[kTLSOpts] = tls\n    this[kRetryDelay] = 0\n    this[kRetryTimeout] = null\n    this[kOnDestroyed] = []\n    this[kWriting] = false\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kResume] = () => {\n      if (this[kResuming] === 0) {\n        resume(this, true)\n      }\n    }\n    this[kTLSSession] = null\n    this[kHostHeader] = `host: ${this[kUrl].hostname}\\r\\n`\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n  }\n\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  set pipelining (value) {\n    this[kPipelining] = value\n    resume(this, true)\n  }\n\n  get connected () {\n    return (\n      this[kSocket] &&\n      this[kSocket].connecting !== true &&\n      // Older versions of Node don't set secureConnecting to false.\n      (this[kSocket].authorized !== false ||\n       this[kSocket].authorizationError\n      ) &&\n      !this[kSocket].destroyed\n    )\n  }\n\n  get pending () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get running () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get size () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get busy () {\n    return this[kReset] || this[kWriting] || this.pending > 0\n  }\n\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  get closed () {\n    return this[kClosed]\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  dispatch (opts, handler) {\n    try {\n      const request = new Request(opts, handler)\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError()\n      }\n\n      this[kQueue].push(request)\n      if (this[kResuming]) {\n        // Do nothing.\n      } else if (util.isStream(request.body)) {\n        // Wait a tick in case stream is ended in the same tick.\n        this[kResuming] = 1\n        process.nextTick(resume, this)\n      } else {\n        resume(this, true)\n      }\n    } catch (err) {\n      handler.onError(err)\n    }\n  }\n\n  close (callback) {\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.close((err, data) => {\n          return err ? reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      process.nextTick(callback, new ClientDestroyedError(), null)\n      return\n    }\n\n    this[kClosed] = true\n\n    if (!this.size) {\n      this.destroy(callback)\n    } else {\n      this[kOnDestroyed].push(callback)\n    }\n  }\n\n  destroy (err, callback) {\n    if (typeof err === 'function') {\n      callback = err\n      err = null\n    }\n\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.destroy(err, (err, data) => {\n          return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      if (this[kOnDestroyed]) {\n        this[kOnDestroyed].push(callback)\n      } else {\n        process.nextTick(callback, null, null)\n      }\n      return\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError()\n    }\n\n    for (const request of this[kQueue].splice(this[kPendingIdx])) {\n      request.onError(err)\n    }\n\n    clearTimeout(this[kRetryTimeout])\n    this[kRetryTimeout] = null\n    this[kClosed] = true\n    this[kDestroyed] = true\n    this[kOnDestroyed].push(callback)\n\n    const onDestroyed = () => {\n      const callbacks = this[kOnDestroyed]\n      this[kOnDestroyed] = null\n      for (const callback of callbacks) {\n        callback(null, null)\n      }\n    }\n\n    if (!this[kSocket]) {\n      process.nextTick(onDestroyed)\n    } else {\n      util.destroy(this[kSocket].on('close', onDestroyed), err)\n    }\n\n    resume(this)\n  }\n}\n\nclass Parser extends HTTPParser {\n  constructor (client, socket) {\n    /* istanbul ignore next */\n    if (nodeMajorVersion === 12) {\n      super()\n      this.initialize(\n        HTTPParser.RESPONSE,\n        {},\n        client[kHeadersTimeout]\n      )\n    } else if (nodeMajorVersion > 12) {\n      super()\n      this.initialize(\n        HTTPParser.RESPONSE,\n        {},\n        client[kMaxHeadersSize],\n        insecureHTTPParser,\n        client[kHeadersTimeout]\n      )\n    } else {\n      super(HTTPParser.RESPONSE, false)\n    }\n\n    this.client = client\n    this.socket = socket\n\n    this.statusCode = null\n    this.upgrade = false\n    this.headers = null\n    this.shouldKeepAlive = false\n    this.read = 0\n    this.request = null\n  }\n\n  [HTTPParser.kOnTimeout] () {\n    /* istanbul ignore next: https://github.com/nodejs/node/pull/34578 */\n    if (this.statusCode) {\n      this.socket._unrefTimer()\n    } else {\n      util.destroy(this.socket, new HeadersTimeoutError())\n    }\n  }\n\n  [HTTPParser.kOnHeaders] (rawHeaders) {\n    if (this.headers) {\n      Array.prototype.push.apply(this.headers, rawHeaders)\n    } else {\n      this.headers = rawHeaders\n    }\n  }\n\n  [HTTPParser.kOnExecute] (ret) {\n    const { upgrade, socket } = this\n\n    if (!Number.isFinite(ret)) {\n      assert(ret instanceof Error)\n      util.destroy(socket, ret)\n      return\n    }\n\n    // When the underlying `net.Socket` instance is consumed - no\n    // `data` events are emitted, and thus `socket.setTimeout` fires the\n    // callback even if the data is constantly flowing into the socket.\n    // See, https://github.com/nodejs/node/commit/ec2822adaad76b126b5cccdeaa1addf2376c9aa6\n    socket._unrefTimer()\n\n    // This logic cannot live in kOnHeadersComplete since we\n    // have no way of slicing the parsing buffer without knowing\n    // the offset which is only provided in kOnExecute.\n    if (upgrade && !socket.destroyed) {\n      const { client, headers, statusCode, request } = this\n\n      assert(!socket.destroyed)\n      assert(socket === client[kSocket])\n      assert(!socket.isPaused())\n      assert(request.upgrade || request.method === 'CONNECT')\n\n      this.headers = null\n      this.statusCode = null\n      this.request = null\n\n      // _readableState.flowing might be `true` if the socket has been\n      // explicitly `resume()`:d even if we never registered a 'data'\n      // listener.\n\n      // We need to stop unshift from emitting 'data'. However, we cannot\n      // call pause()  as that will stop socket from automatically resuming\n      // when 'data' listener is registered.\n\n      // Reset socket state to non flowing:\n      socket._readableState.flowing = null\n\n      socket.unshift(this.getCurrentBuffer().slice(ret))\n\n      try {\n        request.onUpgrade(statusCode, headers, socket)\n      } catch (err) {\n        util.destroy(socket, err)\n        request.onError(err)\n      }\n\n      if (!socket.destroyed && !request.aborted) {\n        detachSocket(socket)\n\n        client[kSocket] = null\n        client[kQueue][client[kRunningIdx]++] = null\n        client.emit('disconnect', new InformationalError('upgrade'))\n\n        setImmediate(() => this.close())\n\n        resume(client)\n      }\n    }\n  }\n\n  [HTTPParser.kOnHeadersComplete] (versionMajor, versionMinor, rawHeaders, method,\n    url, statusCode, statusMessage, upgrade, shouldKeepAlive) {\n    const { client, socket } = this\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return\n    }\n\n    // TODO: Check for content-length mismatch from server?\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    // TODO: More statusCode validation?\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response'))\n      return 1\n    }\n\n    if (upgrade !== Boolean(request.upgrade)) {\n      util.destroy(socket, new SocketError('bad upgrade'))\n      return 1\n    }\n\n    if (this.headers) {\n      Array.prototype.push.apply(this.headers, rawHeaders)\n    } else {\n      this.headers = rawHeaders\n    }\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = shouldKeepAlive\n    this.request = request\n\n    if (upgrade || request.method === 'CONNECT') {\n      this.unconsume()\n      this.upgrade = true\n      return 2\n    }\n\n    let keepAlive\n    let trailers\n\n    for (let n = 0; n < this.headers.length; n += 2) {\n      const key = this.headers[n + 0]\n      const val = this.headers[n + 1]\n\n      if (!keepAlive && key.length === 10 && key.toLowerCase() === 'keep-alive') {\n        keepAlive = val\n      } else if (!trailers && key.length === 7 && key.toLowerCase() === 'trailer') {\n        trailers = val\n      }\n    }\n\n    const { headers } = this\n    this.headers = null\n    this.trailers = trailers ? trailers.toLowerCase().split(/,\\s*/) : null\n\n    if (shouldKeepAlive && client[kKeepAlive]) {\n      const keepAliveTimeout = keepAlive ? util.parseKeepAliveTimeout(keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout < 1e3) {\n          client[kReset] = true\n        } else {\n          client[kKeepAliveTimeout] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeout] = client[kIdleTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      client[kReset] = true\n    }\n\n    try {\n      request.onHeaders(statusCode, headers, statusCode < 200 ? null : socket[kResume])\n    } catch (err) {\n      util.destroy(socket, err)\n      return 1\n    }\n\n    return request.method === 'HEAD' || statusCode < 200 ? 1 : 0\n  }\n\n  [HTTPParser.kOnBody] (chunk, offset, length) {\n    const { socket, statusCode, request } = this\n\n    if (socket.destroyed) {\n      return\n    }\n\n    assert(statusCode >= 200)\n\n    try {\n      if (request.onBody(chunk, offset, length) === false) {\n        socket[kPause]()\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  [HTTPParser.kOnMessageComplete] () {\n    const { client, socket, statusCode, headers, upgrade, request, trailers } = this\n\n    if (socket.destroyed) {\n      return\n    }\n\n    assert(statusCode >= 100)\n\n    if (upgrade) {\n      // TODO: When, how and why does this happen?\n      assert(statusCode < 300 || request.method === 'CONNECT')\n      return\n    }\n\n    this.statusCode = null\n    this.headers = null\n    this.request = null\n    this.trailers = null\n\n    if (statusCode < 200) {\n      assert(!socket.isPaused())\n      return\n    }\n\n    try {\n      if (trailers) {\n        if (!headers) {\n          throw new TrailerMismatchError()\n        }\n\n        for (const trailer of trailers) {\n          let found = false\n          for (let n = 0; n < headers.length; n += 2) {\n            const key = headers[n + 0]\n            if (key.length === trailer.length && key.toLowerCase() === trailer.toLowerCase()) {\n              found = true\n              break\n            }\n          }\n          if (!found) {\n            throw new TrailerMismatchError()\n          }\n        }\n      }\n\n      request.onComplete(headers)\n    } catch (err) {\n      util.destroy(socket, err)\n      return\n    }\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (client[kWriting]) {\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n    } else if (!this.shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'))\n    } else if (client[kReset] && !client.running) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n    } else {\n      socket[kResume]()\n      resume(client)\n    }\n  }\n}\n\nfunction onSocketConnect () {\n  const { [kClient]: client } = this\n\n  assert(!this.destroyed)\n  assert(!client[kWriting])\n  assert(!client[kRetryTimeout])\n\n  client[kReset] = false\n  client[kRetryDelay] = 0\n  client.emit('connect')\n  resume(client)\n}\n\nfunction onSocketTimeout () {\n  util.destroy(this, new SocketTimeoutError())\n}\n\nfunction onSocketError (err) {\n  const { [kClient]: client } = this\n\n  this[kError] = err\n\n  if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n    assert(!client.running)\n    while (client.pending && client[kQueue][client[kPendingIdx]].host === client[kHost]) {\n      client[kQueue][client[kPendingIdx]++].onError(err)\n    }\n  } else if (\n    !client.running &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    assert(client[kPendingIdx] === client[kRunningIdx])\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n    for (const request of client[kQueue].splice(client[kRunningIdx])) {\n      request.onError(err)\n    }\n  }\n}\n\nfunction onSocketEnd () {\n  util.destroy(this, new SocketError('other side closed'))\n}\n\nfunction onSocketClose () {\n  const { [kClient]: client, [kParser]: parser } = this\n\n  const err = this[kError] || new SocketError('closed')\n\n  client[kSocket] = null\n\n  parser.unconsume()\n  setImmediate(() => parser.close())\n\n  if (err.code !== 'UND_ERR_INFO') {\n    // Evict session on errors.\n    client[kTLSSession] = null\n  }\n\n  if (client[kDestroyed]) {\n    assert(!client.pending)\n\n    for (const request of client[kQueue].splice(client[kRunningIdx])) {\n      request.onError(err)\n    }\n    client[kPendingIdx] = client[kRunningIdx]\n  } else {\n    if (client.running && err.code !== 'UND_ERR_INFO') {\n      // Fail head of pipeline.\n      client[kQueue][client[kRunningIdx]].onError(err)\n      client[kQueue][client[kRunningIdx]++] = null\n    }\n\n    // Retry remaining requests.\n    client[kPendingIdx] = client[kRunningIdx]\n\n    client.emit('disconnect', err)\n  }\n\n  resume(client)\n}\n\nfunction onSocketSession (session) {\n  const { [kClient]: client } = this\n\n  // Cache new session for reuse.\n  client[kTLSSession] = session\n}\n\nfunction detachSocket (socket) {\n  socket[kPause] = null\n  socket[kResume] = null\n  socket[kClient] = null\n  socket[kParser] = null\n  socket[kError] = null\n  socket\n    .removeListener('timeout', onSocketTimeout)\n    .removeListener('session', onSocketSession)\n    .removeListener('error', onSocketError)\n    .removeListener('end', onSocketEnd)\n    .removeListener('close', onSocketClose)\n}\n\nfunction connect (client) {\n  assert(!client[kSocket])\n  assert(!client[kRetryTimeout])\n\n  const { protocol, port, hostname } = client[kUrl]\n\n  let socket\n  if (protocol === 'https:') {\n    const tlsOpts = {\n      ...client[kTLSOpts],\n      servername: client[kTLSServerName],\n      session: client[kTLSSession]\n    }\n\n    /* istanbul ignore next: https://github.com/mcollina/undici/issues/267 */\n    socket = client[kSocketPath]\n      ? tls.connect(client[kSocketPath], tlsOpts)\n      : tls.connect(port || /* istanbul ignore next */ 443, hostname, tlsOpts)\n\n    socket.on('session', onSocketSession)\n  } else {\n    socket = client[kSocketPath]\n      ? net.connect(client[kSocketPath])\n      : net.connect(port || /* istanbul ignore next */ 80, hostname)\n  }\n\n  client[kSocket] = socket\n\n  const parser = new Parser(client, socket)\n\n  /* istanbul ignore next */\n  if (nodeMajorVersion >= 12) {\n    assert(socket._handle)\n    parser.consume(socket._handle)\n  } else {\n    assert(socket._handle && socket._handle._externalStream)\n    parser.consume(socket._handle._externalStream)\n  }\n\n  socket[kPause] = socketPause.bind(socket)\n  socket[kResume] = socketResume.bind(socket)\n  socket[kError] = null\n  socket[kParser] = parser\n  socket[kClient] = client\n  socket\n    .setNoDelay(true)\n    .setTimeout(client[kIdleTimeout])\n    .on(protocol === 'https:' ? 'secureConnect' : 'connect', onSocketConnect)\n    .on('timeout', onSocketTimeout)\n    .on('error', onSocketError)\n    .on('end', onSocketEnd)\n    .on('close', onSocketClose)\n}\n\nfunction socketPause () {\n  // TODO: Pause parser.\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false\n    const err = this._handle.readStop()\n    if (err) {\n      this.destroy(util.errnoException(err, 'read'))\n    }\n  }\n}\n\nfunction socketResume () {\n  // TODO: Resume parser.\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true\n    const err = this._handle.readStart()\n    if (err) {\n      this.destroy(util.errnoException(err, 'read'))\n    }\n  }\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain')\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client[kDestroyed]) {\n      assert(!client.pending)\n      return\n    }\n\n    if (client[kClosed] && !client.size) {\n      client.destroy(util.nop)\n      continue\n    }\n\n    if (client[kSocket]) {\n      const timeout = client.running\n        ? client[kSocketTimeout]\n        : client[kKeepAliveTimeout]\n\n      if (client[kSocket].timeout !== timeout) {\n        client[kSocket].setTimeout(timeout)\n      }\n    }\n\n    if (client.running) {\n      const { aborted } = client[kQueue][client[kRunningIdx]]\n      if (aborted) {\n        util.destroy(client[kSocket])\n        return\n      }\n    }\n\n    if (!client.pending) {\n      if (client[kNeedDrain] === 2 && !client.busy) {\n        if (sync) {\n          client[kNeedDrain] = 1\n          process.nextTick(emitDrain, client)\n        } else {\n          emitDrain(client)\n        }\n        continue\n      }\n      return\n    } else {\n      client[kNeedDrain] = 2\n    }\n\n    if (client.running >= client[kPipelining]) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kHost] !== request.host) {\n      if (client.running) {\n        return\n      }\n\n      client[kHost] = request.host\n\n      const servername = (\n        request.host &&\n        !/^\\[/.test(request.host) &&\n        !net.isIP(request.host)\n      ) ? request.host : (client[kTLSOpts] && client[kTLSOpts].servername)\n\n      if (client[kTLSServerName] !== servername) {\n        client[kTLSServerName] = servername\n        client[kTLSSession] = null\n\n        if (client[kSocket]) {\n          util.destroy(client[kSocket], new InformationalError('servername changed'))\n          return\n        }\n      }\n    }\n\n    if (!client[kSocket] && !client[kRetryTimeout]) {\n      if (client[kRetryDelay]) {\n        client[kRetryTimeout] = setTimeout(() => {\n          client[kRetryTimeout] = null\n          connect(client)\n        }, client[kRetryDelay])\n        client[kRetryDelay] = Math.min(client[kRetryDelay] * 2, client[kSocketTimeout])\n      } else {\n        connect(client)\n        client[kRetryDelay] = 1e3\n      }\n      return\n    }\n\n    if (!client.connected) {\n      return\n    }\n\n    if (client[kWriting] || client[kReset]) {\n      return\n    }\n\n    if (client.running && !client[kKeepAlive]) {\n      // Don't schedule more if we know connection will reset.\n      return\n    }\n\n    if (client.running && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (client.running && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceeding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return\n    }\n\n    if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {\n      request.body\n        .on('data', /* istanbul ignore next */ function () {\n          /* istanbul ignore next */\n          assert(false)\n        })\n        .on('error', function (err) {\n          request.onError(err)\n        })\n        .on('end', function () {\n          util.destroy(this)\n        })\n\n      request.body = null\n    }\n\n    if (client.running && util.isStream(request.body)) {\n      // Request with stream body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n\n      // Request with stream body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (write(client, request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\nfunction write (client, request) {\n  const { body, method, path, host, upgrade, headers } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  if (request.contentLength !== null && request.contentLength !== contentLength) {\n    request.onError(new ContentLengthMismatchError())\n    return false\n  }\n\n  try {\n    request.onConnect(client[kResume])\n  } catch (err) {\n    request.onError(err)\n    return false\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    client[kReset] = true\n  }\n\n  if (method === 'CONNECT' || upgrade) {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    client[kReset] = true\n  }\n\n  // TODO: Expect: 100-continue\n\n  // TODO: An HTTP/1.1 user agent MUST NOT preface\n  // or follow a request with an extra CRLF.\n  // https://tools.ietf.org/html/rfc7230#section-3.5\n\n  let header\n\n  if (upgrade) {\n    header = `${method} ${path} HTTP/1.1\\r\\nconnection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kKeepAlive]) {\n    header = `${method} ${path} HTTP/1.1\\r\\nconnection: keep-alive\\r\\n`\n  } else {\n    header = `${method} ${path} HTTP/1.1\\r\\nconnection: close\\r\\n`\n  }\n\n  if (!host) {\n    header += client[kHostHeader]\n  }\n\n  if (headers) {\n    header += headers\n  }\n\n  const socket = client[kSocket]\n\n  if (!body) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n\\r\\n`, 'ascii')\n    } else {\n      assert(contentLength === null, 'no body must not have content length')\n      socket.write(`${header}\\r\\n`, 'ascii')\n    }\n  } else if (util.isBuffer(body)) {\n    assert(contentLength !== null, 'buffer body must have content length')\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n    socket.write(body)\n    socket.write('\\r\\n', 'ascii')\n    socket.uncork()\n\n    if (!expectsPayload) {\n      client[kReset] = true\n    }\n\n    request.body = null\n  } else {\n    client[kWriting] = true\n\n    assert(util.isStream(body))\n    assert(contentLength !== 0 || !client.running, 'stream body cannot be pipelined')\n\n    let finished = false\n    let bytesWritten = 0\n\n    const onData = function (chunk) {\n      try {\n        assert(!finished)\n\n        const len = Buffer.byteLength(chunk)\n        if (!len) {\n          return\n        }\n\n        // TODO: What if not ended and bytesWritten === contentLength?\n        // We should defer writing chunks.\n        if (contentLength !== null && bytesWritten + len > contentLength) {\n          util.destroy(socket, new ContentLengthMismatchError())\n          return\n        }\n\n        if (bytesWritten === 0) {\n          if (!expectsPayload) {\n            client[kReset] = true\n          }\n\n          if (contentLength === null) {\n            socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'ascii')\n          } else {\n            socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n          }\n        }\n\n        if (contentLength === null) {\n          socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'ascii')\n        }\n\n        bytesWritten += len\n\n        if (!socket.write(chunk) && this.pause) {\n          this.pause()\n        }\n      } catch (err) {\n        util.destroy(this, err)\n      }\n    }\n    const onDrain = function () {\n      assert(!finished)\n\n      if (body.resume) {\n        body.resume()\n      }\n    }\n    const onAbort = function () {\n      onFinished(new RequestAbortedError())\n    }\n    const onFinished = function (err) {\n      if (finished) {\n        return\n      }\n\n      finished = true\n\n      assert(client[kWriting] && client.running <= 1)\n      client[kWriting] = false\n\n      if (!err && contentLength !== null && bytesWritten !== contentLength) {\n        err = new ContentLengthMismatchError()\n      }\n\n      socket\n        .removeListener('drain', onDrain)\n        .removeListener('error', onFinished)\n      body\n        .removeListener('data', onData)\n        .removeListener('end', onFinished)\n        .removeListener('error', onFinished)\n        .removeListener('close', onAbort)\n\n      request.body = null\n      util.destroy(body, err)\n\n      if (err) {\n        util.destroy(socket, err)\n        return\n      }\n\n      if (bytesWritten === 0) {\n        if (expectsPayload) {\n          // https://tools.ietf.org/html/rfc7230#section-3.3.2\n          // A user agent SHOULD send a Content-Length in a request message when\n          // no Transfer-Encoding is sent and the request method defines a meaning\n          // for an enclosed payload body.\n\n          socket.write(`${header}content-length: 0\\r\\n\\r\\n\\r\\n`, 'ascii')\n        } else {\n          socket.write(`${header}\\r\\n`, 'ascii')\n        }\n      } else if (contentLength === null) {\n        socket.write('\\r\\n0\\r\\n\\r\\n', 'ascii')\n      }\n\n      resume(client)\n    }\n\n    body\n      .on('data', onData)\n      .on('end', onFinished)\n      .on('error', onFinished)\n      .on('close', onAbort)\n\n    socket\n      .on('drain', onDrain)\n      .on('error', onFinished)\n  }\n\n  return true\n}\n\nmodule.exports = Client\n", "/* eslint-disable */\n\n'use strict'\n\n// Extracted from node/lib/internal/fixed_queue.js\n\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined)\n      return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next;\n    }\n    return next;\n  }\n};\n", "'use strict'\n\nconst Client = require('./core/client')\nconst {\n  ClientClosedError,\n  InvalidArgumentError,\n  ClientDestroyedError\n} = require('./core/errors')\nconst FixedQueue = require('./node/fixed-queue')\n\nconst kClients = Symbol('clients')\nconst kQueue = Symbol('queue')\nconst kDestroyed = Symbol('destroyed')\nconst kClosedPromise = Symbol('closed promise')\nconst kClosedResolve = Symbol('closed resolve')\n\nclass Pool {\n  constructor (url, {\n    connections,\n    ...options\n  } = {}) {\n    if (connections != null && (!Number.isFinite(connections) || connections <= 0)) {\n      throw new InvalidArgumentError('invalid connections')\n    }\n\n    this[kQueue] = new FixedQueue()\n    this[kClosedPromise] = null\n    this[kClosedResolve] = null\n    this[kDestroyed] = false\n    this[kClients] = Array.from({\n      length: connections || 10\n    }, () => new Client(url, options))\n\n    const pool = this\n    function onDrain () {\n      const queue = pool[kQueue]\n\n      while (!this.busy) {\n        const item = queue.shift()\n        if (!item) {\n          break\n        }\n        this.dispatch(item.opts, item.handler)\n      }\n\n      if (pool[kClosedResolve] && queue.isEmpty()) {\n        Promise\n          .all(pool[kClients].map(c => c.close()))\n          .then(pool[kClosedResolve])\n      }\n    }\n\n    for (const client of this[kClients]) {\n      client.on('drain', onDrain)\n    }\n  }\n\n  dispatch (opts, handler) {\n    try {\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosedPromise]) {\n        throw new ClientClosedError()\n      }\n\n      const client = this[kClients].find(client => !client.busy)\n      if (!client) {\n        this[kQueue].push({ opts, handler })\n      } else {\n        client.dispatch(opts, handler)\n      }\n    } catch (err) {\n      handler.onError(err)\n    }\n  }\n\n  close (cb) {\n    try {\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (!this[kClosedPromise]) {\n        if (this[kQueue].isEmpty()) {\n          this[kClosedPromise] = Promise.all(this[kClients].map(c => c.close()))\n        } else {\n          this[kClosedPromise] = new Promise((resolve) => {\n            this[kClosedResolve] = resolve\n          })\n        }\n      }\n\n      if (cb) {\n        this[kClosedPromise].then(() => cb(null, null))\n      } else {\n        return this[kClosedPromise]\n      }\n    } catch (err) {\n      if (cb) {\n        cb(err)\n      } else {\n        return Promise.reject(err)\n      }\n    }\n  }\n\n  destroy (err, cb) {\n    this[kDestroyed] = true\n\n    if (typeof err === 'function') {\n      cb = err\n      err = null\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError()\n    }\n\n    while (true) {\n      const item = this[kQueue].shift()\n      if (!item) {\n        break\n      }\n      item.handler.onError(err)\n    }\n\n    const promise = Promise.all(this[kClients].map(c => c.destroy(err)))\n    if (cb) {\n      promise.then(() => cb(null, null))\n    } else {\n      return promise\n    }\n  }\n}\n\nmodule.exports = Pool\n", "const { RequestAbortedError } = require('./core/errors')\n\nconst kListener = Symbol('kListener')\nconst kSignal = Symbol('kSignal')\n\nfunction addSignal (self, signal) {\n  self[kSignal] = signal\n  self[kListener] = null\n\n  if (!signal) {\n    return\n  }\n\n  self[kListener] = () => {\n    if (self.abort) {\n      self.abort()\n    } else {\n      self.onError(new RequestAbortedError())\n    }\n  }\n\n  if ('addEventListener' in self[kSignal]) {\n    self[kSignal].addEventListener('abort', self[kListener])\n  } else {\n    self[kSignal].addListener('abort', self[kListener])\n  }\n}\n\nfunction removeSignal (self) {\n  if (!self[kSignal]) {\n    return\n  }\n\n  if ('removeEventListener' in self[kSignal]) {\n    self[kSignal].removeEventListener('abort', self[kListener])\n  } else {\n    self[kSignal].removeListener('abort', self[kListener])\n  }\n\n  self[kSignal] = null\n  self[kListener] = null\n}\n\nmodule.exports = {\n  addSignal,\n  removeSignal\n}\n", "'use strict'\n\nconst { Readable } = require('stream')\nconst {\n  InvalidArgumentError,\n  RequestAbortedError\n} = require('./core/errors')\nconst util = require('./core/util')\nconst { AsyncResource } = require('async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nconst kAbort = Symbol('abort')\n\nclass RequestResponse extends Readable {\n  constructor (resume, abort) {\n    super({ autoDestroy: true, read: resume })\n    this[kAbort] = abort\n  }\n\n  _destroy (err, callback) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    if (err) {\n      this[kAbort]()\n    }\n\n    callback(err)\n  }\n}\n\nclass RequestHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      super('UNDICI_REQUEST')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.opaque = opaque || null\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.body = body\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort) {\n    if (!this.callback) {\n      abort()\n    } else {\n      this.abort = abort\n    }\n  }\n\n  onHeaders (statusCode, headers, resume) {\n    const { callback, opaque, abort } = this\n\n    if (statusCode < 200) {\n      return\n    }\n\n    const body = new RequestResponse(resume, abort)\n\n    this.callback = null\n    this.res = body\n\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers: util.parseHeaders(headers),\n      opaque,\n      body\n    })\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    res.push(null)\n  }\n\n  onError (err) {\n    const { res, callback, body, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      process.nextTick((self, callback, err, opaque) => {\n        self.runInAsyncScope(callback, null, err, { opaque })\n      }, this, callback, err, opaque)\n    }\n\n    if (res) {\n      this.res = null\n      util.destroy(res, err)\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction request (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback))\n  } catch (err) {\n    if (typeof callback === 'function') {\n      process.nextTick(callback, err, { opaque: opts && opts.opaque })\n    } else {\n      throw err\n    }\n  }\n}\n\nmodule.exports = request\n", "'use strict'\n\nconst { finished } = require('stream')\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError\n} = require('./core/errors')\nconst util = require('./core/util')\nconst { AsyncResource } = require('async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass StreamHandler extends AsyncResource {\n  constructor (opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      super('UNDICI_STREAM')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.opaque = opaque || null\n    this.factory = factory\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.trailers = null\n    this.body = body\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort) {\n    if (!this.callback) {\n      abort()\n    } else {\n      this.abort = abort\n    }\n  }\n\n  onHeaders (statusCode, headers, resume) {\n    const { factory, opaque } = this\n\n    if (statusCode < 200) {\n      return\n    }\n\n    this.factory = null\n    const res = this.runInAsyncScope(factory, null, {\n      statusCode,\n      headers: util.parseHeaders(headers),\n      opaque\n    })\n\n    if (\n      !res ||\n      typeof res.write !== 'function' ||\n      typeof res.end !== 'function' ||\n      typeof res.on !== 'function'\n    ) {\n      throw new InvalidReturnValueError('expected Writable')\n    }\n\n    res.on('drain', resume)\n    // TODO: Avoid finished. It registers an unecessary amount of listeners.\n    finished(res, { readable: false }, (err) => {\n      const { callback, res, opaque, trailers, abort } = this\n\n      this.res = null\n      if (err || !res.readable) {\n        util.destroy(res, err)\n      }\n\n      this.callback = null\n      this.runInAsyncScope(callback, null, err || null, { opaque, trailers })\n\n      if (err) {\n        abort()\n      }\n    })\n\n    this.res = res\n  }\n\n  onData (chunk) {\n    const { res } = this\n\n    return res.write(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    this.trailers = trailers ? util.parseHeaders(trailers) : {}\n\n    res.end()\n  }\n\n  onError (err) {\n    const { res, callback, opaque, body } = this\n\n    removeSignal(this)\n\n    this.factory = null\n\n    if (res) {\n      this.res = null\n      util.destroy(res, err)\n    } else if (callback) {\n      this.callback = null\n      process.nextTick((self, callback, err, opaque) => {\n        self.runInAsyncScope(callback, null, err, { opaque })\n      }, this, callback, err, opaque)\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction stream (opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new StreamHandler(opts, factory, callback))\n  } catch (err) {\n    if (typeof callback === 'function') {\n      process.nextTick(callback, err, { opaque: opts && opts.opaque })\n    } else {\n      throw err\n    }\n  }\n}\n\nmodule.exports = stream\n", "'use strict'\n\nconst {\n  Readable,\n  Duplex,\n  PassThrough\n} = require('stream')\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = require('./core/errors')\nconst util = require('./core/util')\nconst { AsyncResource } = require('async_hooks')\nconst { assert } = require('console')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nconst kResume = Symbol('resume')\n\nclass PipelineRequest extends Readable {\n  constructor () {\n    super({ autoDestroy: true })\n\n    this[kResume] = null\n  }\n\n  _read () {\n    const { [kResume]: resume } = this\n\n    if (resume) {\n      this[kResume] = null\n      resume()\n    }\n  }\n\n  _destroy (err, callback) {\n    this._read()\n\n    assert(err || this._readableState.endEmitted)\n\n    callback(err)\n  }\n}\n\nclass PipelineResponse extends Readable {\n  constructor (resume) {\n    super({ autoDestroy: true })\n    this[kResume] = resume\n  }\n\n  _read () {\n    this[kResume]()\n  }\n\n  _destroy (err, callback) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    callback(err)\n  }\n}\n\nclass PipelineHandler extends AsyncResource {\n  constructor (opts, handler) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof handler !== 'function') {\n      throw new InvalidArgumentError('invalid handler')\n    }\n\n    const { signal, method, opaque } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    if (method === 'CONNECT') {\n      throw new InvalidArgumentError('invalid method')\n    }\n\n    super('UNDICI_PIPELINE')\n\n    this.opaque = opaque || null\n    this.handler = handler\n    this.abort = null\n\n    addSignal(this, signal)\n\n    this.req = new PipelineRequest().on('error', util.nop)\n\n    this.ret = new Duplex({\n      readableObjectMode: opts.objectMode,\n      autoDestroy: true,\n      read: () => {\n        const { body } = this\n\n        if (body && body.resume) {\n          body.resume()\n        }\n      },\n      write: (chunk, encoding, callback) => {\n        const { req } = this\n\n        if (req.push(chunk, encoding) || req._readableState.destroyed) {\n          callback()\n        } else {\n          req[kResume] = callback\n        }\n      },\n      destroy: (err, callback) => {\n        const { body, req, res, ret, abort } = this\n\n        if (!err && !ret._readableState.endEmitted) {\n          err = new RequestAbortedError()\n        }\n\n        if (abort && err) {\n          abort()\n        }\n\n        util.destroy(body, err)\n        util.destroy(req, err)\n        util.destroy(res, err)\n\n        removeSignal(this)\n\n        callback(err)\n      }\n    }).on('prefinish', () => {\n      const { req } = this\n\n      // Node < 15 does not call _final in same tick.\n      req.push(null)\n    })\n\n    this.res = null\n  }\n\n  onConnect (abort) {\n    const { ret } = this\n\n    if (ret.destroyed) {\n      abort()\n    } else {\n      this.abort = abort\n    }\n  }\n\n  onHeaders (statusCode, headers, resume) {\n    const { opaque, handler } = this\n\n    if (statusCode < 200) {\n      return\n    }\n\n    this.res = new PipelineResponse(resume)\n\n    let body\n    try {\n      this.handler = null\n      body = this.runInAsyncScope(handler, null, {\n        statusCode,\n        headers: util.parseHeaders(headers),\n        opaque,\n        body: this.res\n      })\n    } catch (err) {\n      this.res.on('error', util.nop)\n      throw err\n    }\n\n    if (!body || typeof body.on !== 'function') {\n      throw new InvalidReturnValueError('expected Readable')\n    }\n\n    body\n      .on('data', (chunk) => {\n        const { ret, body } = this\n\n        if (!ret.push(chunk) && body.pause) {\n          body.pause()\n        }\n      })\n      .on('error', (err) => {\n        const { ret } = this\n\n        util.destroy(ret, err)\n      })\n      .on('end', () => {\n        const { ret } = this\n\n        ret.push(null)\n      })\n      .on('close', () => {\n        const { ret } = this\n\n        if (!ret._readableState.ended) {\n          util.destroy(ret, new RequestAbortedError())\n        }\n      })\n\n    this.body = body\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n    res.push(null)\n  }\n\n  onError (err) {\n    const { ret } = this\n    this.handler = null\n    util.destroy(ret, err)\n  }\n}\n\nfunction pipeline (opts, handler) {\n  try {\n    const pipelineHandler = new PipelineHandler(opts, handler)\n    const {\n      path,\n      method,\n      headers,\n      idempotent,\n      servername,\n      signal,\n      requestTimeout\n    } = opts\n    this.dispatch({\n      path,\n      method,\n      body: pipelineHandler.req,\n      headers,\n      idempotent,\n      servername,\n      signal,\n      requestTimeout\n    }, pipelineHandler)\n    return pipelineHandler.ret\n  } catch (err) {\n    return new PassThrough().destroy(err)\n  }\n}\n\nmodule.exports = pipeline\n", "'use strict'\n\nconst { InvalidArgumentError } = require('./core/errors')\nconst { AsyncResource } = require('async_hooks')\nconst util = require('./core/util')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass UpgradeHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, opaque } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_UPGRADE')\n\n    this.opaque = opaque || null\n    this.callback = callback\n    this.abort = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort) {\n    if (!this.callback) {\n      abort()\n    } else {\n      this.abort = abort\n    }\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    this.callback = null\n    this.runInAsyncScope(callback, null, null, {\n      headers: util.parseHeaders(headers),\n      socket,\n      opaque\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      process.nextTick((self, callback, err, opaque) => {\n        self.runInAsyncScope(callback, null, err, { opaque })\n      }, this, callback, err, opaque)\n    }\n  }\n}\n\nfunction upgrade (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      upgrade.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  if (typeof callback !== 'function') {\n    throw new InvalidArgumentError('invalid callback')\n  }\n\n  try {\n    const upgradeHandler = new UpgradeHandler(opts, callback)\n    const {\n      path,\n      method,\n      headers,\n      servername,\n      signal,\n      requestTimeout,\n      protocol\n    } = opts\n    this.dispatch({\n      path,\n      method: method || 'GET',\n      headers,\n      servername,\n      signal,\n      requestTimeout,\n      upgrade: protocol || 'Websocket'\n    }, upgradeHandler)\n  } catch (err) {\n    process.nextTick(callback, err, { opaque: opts && opts.opaque })\n  }\n}\n\nmodule.exports = upgrade\n", "'use strict'\n\nconst { InvalidArgumentError } = require('./core/errors')\nconst { AsyncResource } = require('async_hooks')\nconst util = require('./core/util')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass ConnectHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, opaque } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_CONNECT')\n\n    this.opaque = opaque || null\n    this.callback = callback\n    this.abort = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort) {\n    if (!this.callback) {\n      abort()\n    } else {\n      this.abort = abort\n    }\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    this.callback = null\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers: util.parseHeaders(headers),\n      socket,\n      opaque\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      process.nextTick((self, callback, err, opaque) => {\n        self.runInAsyncScope(callback, null, err, { opaque })\n      }, this, callback, err, opaque)\n    }\n  }\n}\n\nfunction connect (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      connect.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  if (typeof callback !== 'function') {\n    throw new InvalidArgumentError('invalid callback')\n  }\n\n  try {\n    const connectHandler = new ConnectHandler(opts, callback)\n    const {\n      path,\n      headers,\n      servername,\n      signal,\n      requestTimeout\n    } = opts\n    this.dispatch({\n      path,\n      method: 'CONNECT',\n      headers,\n      servername,\n      signal,\n      requestTimeout\n    }, connectHandler)\n  } catch (err) {\n    process.nextTick(callback, err, { opaque: opts && opts.opaque })\n  }\n}\n\nmodule.exports = connect\n", "'use strict'\n\nconst Client = require('./lib/core/client')\nconst errors = require('./lib/core/errors')\nconst Pool = require('./lib/pool')\n\nClient.prototype.request = require('./lib/client-request')\nClient.prototype.stream = require('./lib/client-stream')\nClient.prototype.pipeline = require('./lib/client-pipeline')\nClient.prototype.upgrade = require('./lib/client-upgrade')\nClient.prototype.connect = require('./lib/client-connect')\n\nPool.prototype.request = require('./lib/client-request')\nPool.prototype.stream = require('./lib/client-stream')\nPool.prototype.pipeline = require('./lib/client-pipeline')\nPool.prototype.upgrade = require('./lib/client-upgrade')\nPool.prototype.connect = require('./lib/client-connect')\n\nfunction undici (url, opts) {\n  return new Pool(url, opts)\n}\n\nundici.Pool = Pool\nundici.Client = Client\nundici.errors = errors\n\nmodule.exports = undici\n", null, null, null, null, "import { inspect } from \"util\";\n\nexport type Value = string | number | boolean | object | null | undefined;\nexport type RawValue = Value | Sql;\n\n/**\n * A SQL instance can be nested within each other to build SQL strings.\n */\nexport class Sql {\n  values: Value[];\n  strings: string[];\n\n  constructor(\n    rawStrings: ReadonlyArray<string>,\n    rawValues: ReadonlyArray<RawValue>\n  ) {\n    if (rawStrings.length === 0) {\n      throw new TypeError(\"Expected at least 1 string\");\n    }\n\n    if (rawStrings.length - 1 !== rawValues.length) {\n      throw new TypeError(\n        `Expected ${rawStrings.length} strings to have ${\n          rawStrings.length - 1\n        } values`\n      );\n    }\n\n    let valuesLength = rawValues.length;\n    let stringsLength = rawStrings.length;\n\n    for (const child of rawValues) {\n      if (child instanceof Sql) {\n        valuesLength += child.values.length - 1;\n        stringsLength += child.strings.length - 2;\n      }\n    }\n\n    this.values = new Array(valuesLength);\n    this.strings = new Array(stringsLength);\n\n    this.strings[0] = rawStrings[0];\n\n    // Iterate over raw values, strings, and children. The value is always\n    // positioned between two strings, e.g. `index + 1`.\n    let index = 1;\n    let position = 0;\n    while (index < rawStrings.length) {\n      const child = rawValues[index - 1];\n      const rawString = rawStrings[index++];\n\n      // Check for nested `sql` queries.\n      if (child instanceof Sql) {\n        // Append child prefix text to current string.\n        this.strings[position] += child.strings[0];\n\n        let childIndex = 0;\n        while (childIndex < child.values.length) {\n          this.values[position++] = child.values[childIndex++];\n          this.strings[position] = child.strings[childIndex];\n        }\n\n        // Append raw string to current string.\n        this.strings[position] += rawString;\n      } else {\n        this.values[position++] = child;\n        this.strings[position] = rawString;\n      }\n    }\n  }\n\n  get text() {\n    return this.strings.reduce(\n      (text, part, index) => `${text}$${index}${part}`\n    );\n  }\n\n  get sql() {\n    return this.strings.join(\"?\");\n  }\n\n  [inspect.custom]() {\n    return {\n      text: this.text,\n      sql: this.sql,\n      values: this.values,\n    };\n  }\n}\n\n// Work around MySQL enumerable keys in issue #2.\nObject.defineProperty(Sql.prototype, \"sql\", { enumerable: true });\nObject.defineProperty(Sql.prototype, \"text\", { enumerable: true });\n\n/**\n * Create a SQL query for a list of values.\n */\nexport function join(values: RawValue[], separator = \",\") {\n  if (values.length === 0) {\n    throw new TypeError(\n      \"Expected `join([])` to be called with an array of multiple elements, but got an empty array\"\n    );\n  }\n\n  return new Sql([\"\", ...Array(values.length - 1).fill(separator), \"\"], values);\n}\n\n/**\n * Create raw SQL statement.\n */\nexport function raw(value: string) {\n  return new Sql([value], []);\n}\n\n/**\n * Placeholder value for \"no text\".\n */\nexport const empty = raw(\"\");\n\n/**\n * Create a SQL object from a template string.\n */\nexport function sqltag(strings: TemplateStringsArray, ...values: RawValue[]) {\n  return new Sql(strings.raw, values);\n}\n\n/**\n * Standard `sql` tag.\n */\nexport default sqltag;\n", "/* @flow */\n/*::\n\ntype DotenvParseOptions = {\n  debug?: boolean\n}\n\n// keys and values from src\ntype DotenvParseOutput = { [string]: string }\n\ntype DotenvConfigOptions = {\n  path?: string, // path to .env file\n  encoding?: string, // encoding of .env file\n  debug?: string // turn on logging for debugging purposes\n}\n\ntype DotenvConfigOutput = {\n  parsed?: DotenvParseOutput,\n  error?: Error\n}\n\n*/\n\nconst fs = require('fs')\nconst path = require('path')\n\nfunction log (message /*: string */) {\n  console.log(`[dotenv][DEBUG] ${message}`)\n}\n\nconst NEWLINE = '\\n'\nconst RE_INI_KEY_VAL = /^\\s*([\\w.-]+)\\s*=\\s*(.*)?\\s*$/\nconst RE_NEWLINES = /\\\\n/g\nconst NEWLINES_MATCH = /\\n|\\r|\\r\\n/\n\n// Parses src into an Object\nfunction parse (src /*: string | Buffer */, options /*: ?DotenvParseOptions */) /*: DotenvParseOutput */ {\n  const debug = Boolean(options && options.debug)\n  const obj = {}\n\n  // convert Buffers before splitting into lines and processing\n  src.toString().split(NEWLINES_MATCH).forEach(function (line, idx) {\n    // matching \"KEY' and 'VAL' in 'KEY=VAL'\n    const keyValueArr = line.match(RE_INI_KEY_VAL)\n    // matched?\n    if (keyValueArr != null) {\n      const key = keyValueArr[1]\n      // default undefined or missing values to empty string\n      let val = (keyValueArr[2] || '')\n      const end = val.length - 1\n      const isDoubleQuoted = val[0] === '\"' && val[end] === '\"'\n      const isSingleQuoted = val[0] === \"'\" && val[end] === \"'\"\n\n      // if single or double quoted, remove quotes\n      if (isSingleQuoted || isDoubleQuoted) {\n        val = val.substring(1, end)\n\n        // if double quoted, expand newlines\n        if (isDoubleQuoted) {\n          val = val.replace(RE_NEWLINES, NEWLINE)\n        }\n      } else {\n        // remove surrounding whitespace\n        val = val.trim()\n      }\n\n      obj[key] = val\n    } else if (debug) {\n      log(`did not match key and value when parsing line ${idx + 1}: ${line}`)\n    }\n  })\n\n  return obj\n}\n\n// Populates process.env from .env file\nfunction config (options /*: ?DotenvConfigOptions */) /*: DotenvConfigOutput */ {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding /*: string */ = 'utf8'\n  let debug = false\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = options.path\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n    if (options.debug != null) {\n      debug = true\n    }\n  }\n\n  try {\n    // specifying an encoding returns a string instead of a buffer\n    const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), { debug })\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key]\n      } else if (debug) {\n        log(`\"${key}\" is already defined in \\`process.env\\` and will not be overwritten`)\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    return { error: e }\n  }\n}\n\nmodule.exports.config = config\nmodule.exports.parse = parse\n", null, null, "export { DMMF } from './dmmf-types'\nexport { DMMFClass } from './dmmf'\nexport {\n  makeDocument,\n  transformDocument,\n  unpack,\n  PrismaClientValidationError,\n} from './query'\nexport { default as debugLib } from '@prisma/debug'\n\nexport {\n  Engine,\n  PrismaClientKnownRequestError,\n  PrismaClientUnknownRequestError,\n  PrismaClientInitializationError,\n  PrismaClientRustPanicError,\n} from '@prisma/engine-core'\nexport { getPrismaClient, PrismaClientOptions } from './getPrismaClient'\n\nexport {\n  RawValue,\n  Sql,\n  Value,\n  empty,\n  join,\n  raw,\n  sqltag,\n} from 'sql-template-tag'\n\n\nexport { default as Decimal } from 'decimal.js'\n", "import { DMMF } from \"@prisma/generator-helper\";\n\nexport interface BaseField {\n  name: string\n  type: string | DMMF.SchemaEnum | DMMF.OutputType | DMMF.SchemaArg\n  isList: boolean\n  isRequired: boolean\n}\n\nexport { DMMF }\n", "import chalk from 'chalk'\nimport indent from 'indent-string'\nimport leven from 'js-levenshtein'\nimport { DMMF } from '../dmmf-types'\nimport Decimal from 'decimal.js'\n\nexport interface Dictionary<T> {\n  [key: string]: T\n}\n\nexport const keyBy: <T>(collection: T[], prop: string) => Dictionary<T> = (\n  collection,\n  prop,\n) => {\n  const acc = {}\n\n  for (const obj of collection) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n  return acc\n}\n\nexport const keyBy2: <T>(\n  collection1: T[],\n  collection2: T[],\n  prop: string,\n) => Dictionary<T> = (collection1, collection2, prop) => {\n  const acc = {}\n\n  for (const obj of collection1) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n\n  for (const obj of collection2) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n  return acc\n}\n\nexport const ScalarTypeTable = {\n  String: true,\n  Int: true,\n  Float: true,\n  Boolean: true,\n  Long: true,\n  DateTime: true,\n  ID: true,\n  UUID: true,\n  Json: true,\n  Bytes: true,\n  Xml: true,\n  Decimal: true\n}\n\nexport function isScalar(str: string): boolean {\n  if (typeof str !== 'string') {\n    return false\n  }\n  return ScalarTypeTable[str] || false\n}\n\nexport const GraphQLScalarToJSTypeTable = {\n  String: 'string',\n  Int: 'number',\n  Float: 'number',\n  Boolean: 'boolean',\n  Long: 'number',\n  DateTime: ['Date', 'string'],\n  ID: 'string',\n  UUID: 'string',\n  Json: 'JsonValue',\n  Bytes: 'Buffer',\n  Xml: 'string',\n  Decimal: 'Decimal'\n}\n\nexport const JSOutputTypeToInputType = {\n  JsonValue: 'InputJsonValue',\n}\n\nexport const JSTypeToGraphQLType = {\n  string: 'String',\n  boolean: 'Boolean',\n  object: 'Json',\n}\n\nexport function stringifyGraphQLType(\n  type: string | DMMF.InputType | DMMF.SchemaEnum,\n) {\n  if (typeof type === 'string') {\n    return type\n  }\n  return type.name\n}\n\nexport function wrapWithList(str: string, isList: boolean) {\n  if (isList) {\n    return `List<${str}>`\n  }\n\n  return str\n}\n\nexport function getGraphQLType(\n  value: any,\n  potentialType?: string | DMMF.SchemaEnum | DMMF.InputType,\n): string {\n  if (value === null) {\n    return 'null'\n  }\n\n  // https://github.com/MikeMcl/decimal.js/blob/master/decimal.js#L4499\n  if (Decimal.isDecimal(value)) {\n    return 'Decimal'\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return 'Bytes'\n  }\n\n  if (potentialType && potentialType.toString() === 'Xml' && typeof value === 'string') {\n    return 'Xml'\n  }\n\n  if (Array.isArray(value)) {\n    let scalarTypes = value.reduce((acc, val) => {\n      const type = getGraphQLType(val, potentialType)\n      if (!acc.includes(type)) {\n        acc.push(type)\n      }\n      return acc\n    }, [])\n\n    // Merge Float and Int together\n    if (scalarTypes.includes('Float') && scalarTypes.includes('Int')) {\n      scalarTypes = ['Float']\n    }\n\n    return `List<${scalarTypes.join(' | ')}>`\n  }\n  const jsType = typeof value\n  if (jsType === 'number') {\n    if (Math.trunc(value) === value) {\n      return 'Int'\n    } else {\n      return 'Float'\n    }\n  }\n  if (Object.prototype.toString.call(value) === '[object Date]') {\n    return 'DateTime'\n  }\n  if (jsType === 'string') {\n    if (\n      /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(\n        value,\n      )\n    ) {\n      return 'UUID'\n    }\n    const date = new Date(value)\n    if (\n      potentialType &&\n      typeof potentialType === 'object' &&\n      (potentialType as DMMF.SchemaEnum).values &&\n      (potentialType as DMMF.SchemaEnum).values.includes(value)\n    ) {\n      return potentialType.name\n    }\n    if (date.toString() === 'Invalid Date') {\n      return 'String'\n    }\n    if (\n      /\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)/.test(\n        value,\n      )\n    ) {\n      return 'DateTime'\n    }\n  }\n  return JSTypeToGraphQLType[jsType]\n}\n\nexport function graphQLToJSType(gql: string) {\n  return GraphQLScalarToJSTypeTable[gql]\n}\n\nexport function getSuggestion(\n  str: string,\n  possibilities: string[],\n): string | null {\n  const bestMatch = possibilities.reduce<{\n    distance: number\n    str: string | null\n  }>(\n    (acc, curr) => {\n      const distance = leven(str, curr)\n      if (distance < acc.distance) {\n        return {\n          distance,\n          str: curr,\n        }\n      }\n\n      return acc\n    },\n    {\n      // heuristic to be not too strict, but allow some big mistakes (<= ~ 5)\n      distance: Math.min(\n        Math.floor(str.length) * 1.1,\n        ...possibilities.map((p) => p.length * 3),\n      ),\n      str: null,\n    },\n  )\n\n  return bestMatch.str\n}\n\nexport function stringifyInputType(\n  input: string | DMMF.InputType | DMMF.SchemaEnum,\n  greenKeys: boolean = false,\n): string {\n  if (typeof input === 'string') {\n    return input\n  }\n  if ((input as DMMF.SchemaEnum).values) {\n    return `enum ${input.name} {\\n${indent(\n      (input as DMMF.SchemaEnum).values.join(', '),\n      2,\n    )}\\n}`\n  } else {\n    const body = indent(\n      (input as DMMF.InputType).fields // TS doesn't discriminate based on existence of fields properly\n        .map((arg) => {\n          const key = `${arg.name}`\n          const str = `${greenKeys ? chalk.green(key) : key}${arg.isRequired ? '' : '?'\n            }: ${chalk.white(\n              arg.inputTypes\n                .map((argType) => {\n                  return wrapWithList(argIsInputType(argType.type)\n                    ? argType.type.name\n                    :\n                    stringifyGraphQLType(argType.type),\n                    argType.isList,\n                  )\n                }\n                )\n                .join(' | '),\n            )}`\n          if (!arg.isRequired) {\n            return chalk.dim(str)\n          }\n\n          return str\n        })\n        .join('\\n'),\n      2,\n    )\n    return `${chalk.dim('type')} ${chalk.bold.dim(input.name)} ${chalk.dim(\n      '{',\n    )}\\n${body}\\n${chalk.dim('}')}`\n  }\n}\n\nfunction argIsInputType(arg: DMMF.ArgType): arg is DMMF.InputType {\n  if (typeof arg === 'string') {\n    return false\n  }\n\n  return true\n}\n\nexport function getInputTypeName(\n  input: string | DMMF.InputType | DMMF.SchemaField | DMMF.SchemaEnum,\n) {\n  if (typeof input === 'string') {\n    if (input === 'Null') {\n      return 'null'\n    }\n    return input\n  }\n\n  return input.name\n}\n\nexport function getOutputTypeName(\n  input: string | DMMF.OutputType | DMMF.SchemaField | DMMF.SchemaEnum,\n) {\n  if (typeof input === 'string') {\n    return input\n  }\n\n  return input.name\n}\n\nexport function inputTypeToJson(\n  input: string | DMMF.InputType | DMMF.SchemaEnum,\n  isRequired: boolean,\n  nameOnly: boolean = false,\n): string | object {\n  if (typeof input === 'string') {\n    if (input === 'Null') {\n      return 'null'\n    }\n    return input\n  }\n\n  if ((input as DMMF.SchemaEnum).values) {\n    return (input as DMMF.SchemaEnum).values.join(' | ')\n  }\n\n  // TS \"Trick\" :/\n  const inputType: DMMF.InputType = input as DMMF.InputType\n\n\n  // If the parent type is required and all fields are non-scalars,\n  // it's very useful to show to the user, which options they actually have\n  const showDeepType =\n    isRequired &&\n    inputType.fields.every((arg) => arg.inputTypes[0].kind === 'object' || arg.inputTypes[1]?.kind === 'object')\n\n  if (nameOnly) {\n    return getInputTypeName(input)\n  }\n\n  return inputType.fields.reduce((acc, curr) => {\n    let str = ''\n\n    if (!showDeepType && !curr.isRequired) {\n      str = curr.inputTypes.map(argType => getInputTypeName(argType.type)).join(' | ')\n    } else {\n      str = curr.inputTypes.map(argInputType => inputTypeToJson(argInputType.type, curr.isRequired, true)).join(' | ')\n    }\n\n    acc[curr.name + (curr.isRequired ? '' : '?')] = str\n    return acc\n  }, {})\n}\n\nexport function destroyCircular(from, seen: any[] = []) {\n  const to: any = Array.isArray(from) ? [] : {}\n\n  seen.push(from)\n\n  for (const key of Object.keys(from)) {\n    const value = from[key]\n\n    if (typeof value === 'function') {\n      continue\n    }\n\n    if (!value || typeof value !== 'object') {\n      to[key] = value\n      continue\n    }\n\n    if (seen.indexOf(from[key]) === -1) {\n      to[key] = destroyCircular(from[key], seen.slice(0))\n      continue\n    }\n\n    to[key] = '[Circular]'\n  }\n\n  if (typeof from.name === 'string') {\n    to.name = from.name\n  }\n\n  if (typeof from.message === 'string') {\n    to.message = from.message\n  }\n\n  if (typeof from.stack === 'string') {\n    to.stack = from.stack\n  }\n\n  return to\n}\n\nexport function unionBy<T>(\n  arr1: T[],\n  arr2: T[],\n  iteratee: (element: T) => string | number,\n): T[] {\n  const map = {}\n\n  for (const element of arr1) {\n    map[iteratee(element)] = element\n  }\n\n  for (const element of arr2) {\n    const key = iteratee(element)\n    if (!map[key]) {\n      map[key] = element\n    }\n  }\n\n  return Object.values(map)\n}\n\nexport function uniqBy<T>(\n  arr: T[],\n  iteratee: (element: T) => string | number,\n): T[] {\n  const map = {}\n\n  for (const element of arr) {\n    map[iteratee(element)] = element\n  }\n\n  return Object.values(map)\n}\n\nexport function capitalize(str: string): string {\n  return str[0].toUpperCase() + str.slice(1)\n}\n\n/**\n * Converts the first character of a word to lower case\n * @param name\n */\nexport function lowerCase(name: string): string {\n  return name.substring(0, 1).toLowerCase() + name.substring(1)\n}\n", "/*\r\n *  decimal.js v10.2.1\r\n *  An arbitrary-precision Decimal type for JavaScript.\r\n *  https://github.com/MikeMcl/decimal.js\r\n *  Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *  MIT Licence\r\n */\r\n\r\n\r\n// -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\r\n\r\n\r\n  // The maximum exponent magnitude.\r\n  // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\r\nvar EXP_LIMIT = 9e15,                      // 0 to 9e15\r\n\r\n  // The limit on the value of `precision`, and on the value of the first argument to\r\n  // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\r\n  MAX_DIGITS = 1e9,                        // 0 to 1e9\r\n\r\n  // Base conversion alphabet.\r\n  NUMERALS = '0123456789abcdef',\r\n\r\n  // The natural logarithm of 10 (1025 digits).\r\n  LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',\r\n\r\n  // Pi (1025 digits).\r\n  PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',\r\n\r\n\r\n  // The initial configuration properties of the Decimal constructor.\r\n  DEFAULTS = {\r\n\r\n    // These values must be integers within the stated ranges (inclusive).\r\n    // Most of these values can be changed at run-time using the `Decimal.config` method.\r\n\r\n    // The maximum number of significant digits of the result of a calculation or base conversion.\r\n    // E.g. `Decimal.config({ precision: 20 });`\r\n    precision: 20,                         // 1 to MAX_DIGITS\r\n\r\n    // The rounding mode used when rounding to `precision`.\r\n    //\r\n    // ROUND_UP         0 Away from zero.\r\n    // ROUND_DOWN       1 Towards zero.\r\n    // ROUND_CEIL       2 Towards +Infinity.\r\n    // ROUND_FLOOR      3 Towards -Infinity.\r\n    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n    //\r\n    // E.g.\r\n    // `Decimal.rounding = 4;`\r\n    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\r\n    rounding: 4,                           // 0 to 8\r\n\r\n    // The modulo mode used when calculating the modulus: a mod n.\r\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n    // The remainder (r) is calculated as: r = a - n * q.\r\n    //\r\n    // UP         0 The remainder is positive if the dividend is negative, else is negative.\r\n    // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\r\n    // FLOOR      3 The remainder has the same sign as the divisor (Python %).\r\n    // HALF_EVEN  6 The IEEE 754 remainder function.\r\n    // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\r\n    //\r\n    // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\r\n    // division (9) are commonly used for the modulus operation. The other rounding modes can also\r\n    // be used, but they may not give useful results.\r\n    modulo: 1,                             // 0 to 9\r\n\r\n    // The exponent value at and beneath which `toString` returns exponential notation.\r\n    // JavaScript numbers: -7\r\n    toExpNeg: -7,                          // 0 to -EXP_LIMIT\r\n\r\n    // The exponent value at and above which `toString` returns exponential notation.\r\n    // JavaScript numbers: 21\r\n    toExpPos:  21,                         // 0 to EXP_LIMIT\r\n\r\n    // The minimum exponent value, beneath which underflow to zero occurs.\r\n    // JavaScript numbers: -324  (5e-324)\r\n    minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT\r\n\r\n    // The maximum exponent value, above which overflow to Infinity occurs.\r\n    // JavaScript numbers: 308  (1.7976931348623157e+308)\r\n    maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT\r\n\r\n    // Whether to use cryptographically-secure random number generation, if available.\r\n    crypto: false                          // true/false\r\n  },\r\n\r\n\r\n// ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\r\n\r\n\r\n  inexact, quadrant,\r\n  external = true,\r\n\r\n  decimalError = '[DecimalError] ',\r\n  invalidArgument = decimalError + 'Invalid argument: ',\r\n  precisionLimitExceeded = decimalError + 'Precision limit exceeded',\r\n  cryptoUnavailable = decimalError + 'crypto unavailable',\r\n\r\n  mathfloor = Math.floor,\r\n  mathpow = Math.pow,\r\n\r\n  isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i,\r\n  isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i,\r\n  isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i,\r\n  isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\r\n\r\n  BASE = 1e7,\r\n  LOG_BASE = 7,\r\n  MAX_SAFE_INTEGER = 9007199254740991,\r\n\r\n  LN10_PRECISION = LN10.length - 1,\r\n  PI_PRECISION = PI.length - 1,\r\n\r\n  // Decimal.prototype object\r\n  P = { name: '[object Decimal]' };\r\n\r\n\r\n// Decimal prototype methods\r\n\r\n\r\n/*\r\n *  absoluteValue             abs\r\n *  ceil\r\n *  comparedTo                cmp\r\n *  cosine                    cos\r\n *  cubeRoot                  cbrt\r\n *  decimalPlaces             dp\r\n *  dividedBy                 div\r\n *  dividedToIntegerBy        divToInt\r\n *  equals                    eq\r\n *  floor\r\n *  greaterThan               gt\r\n *  greaterThanOrEqualTo      gte\r\n *  hyperbolicCosine          cosh\r\n *  hyperbolicSine            sinh\r\n *  hyperbolicTangent         tanh\r\n *  inverseCosine             acos\r\n *  inverseHyperbolicCosine   acosh\r\n *  inverseHyperbolicSine     asinh\r\n *  inverseHyperbolicTangent  atanh\r\n *  inverseSine               asin\r\n *  inverseTangent            atan\r\n *  isFinite\r\n *  isInteger                 isInt\r\n *  isNaN\r\n *  isNegative                isNeg\r\n *  isPositive                isPos\r\n *  isZero\r\n *  lessThan                  lt\r\n *  lessThanOrEqualTo         lte\r\n *  logarithm                 log\r\n *  [maximum]                 [max]\r\n *  [minimum]                 [min]\r\n *  minus                     sub\r\n *  modulo                    mod\r\n *  naturalExponential        exp\r\n *  naturalLogarithm          ln\r\n *  negated                   neg\r\n *  plus                      add\r\n *  precision                 sd\r\n *  round\r\n *  sine                      sin\r\n *  squareRoot                sqrt\r\n *  tangent                   tan\r\n *  times                     mul\r\n *  toBinary\r\n *  toDecimalPlaces           toDP\r\n *  toExponential\r\n *  toFixed\r\n *  toFraction\r\n *  toHexadecimal             toHex\r\n *  toNearest\r\n *  toNumber\r\n *  toOctal\r\n *  toPower                   pow\r\n *  toPrecision\r\n *  toSignificantDigits       toSD\r\n *  toString\r\n *  truncated                 trunc\r\n *  valueOf                   toJSON\r\n */\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the absolute value of this Decimal.\r\n *\r\n */\r\nP.absoluteValue = P.abs = function () {\r\n  var x = new this.constructor(this);\r\n  if (x.s < 0) x.s = 1;\r\n  return finalise(x);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n * direction of positive Infinity.\r\n *\r\n */\r\nP.ceil = function () {\r\n  return finalise(new this.constructor(this), this.e + 1, 2);\r\n};\r\n\r\n\r\n/*\r\n * Return\r\n *   1    if the value of this Decimal is greater than the value of `y`,\r\n *  -1    if the value of this Decimal is less than the value of `y`,\r\n *   0    if they have the same value,\r\n *   NaN  if the value of either Decimal is NaN.\r\n *\r\n */\r\nP.comparedTo = P.cmp = function (y) {\r\n  var i, j, xdL, ydL,\r\n    x = this,\r\n    xd = x.d,\r\n    yd = (y = new x.constructor(y)).d,\r\n    xs = x.s,\r\n    ys = y.s;\r\n\r\n  // Either NaN or \u00B1Infinity?\r\n  if (!xd || !yd) {\r\n    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\r\n  }\r\n\r\n  // Either zero?\r\n  if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\r\n\r\n  // Signs differ?\r\n  if (xs !== ys) return xs;\r\n\r\n  // Compare exponents.\r\n  if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\r\n\r\n  xdL = xd.length;\r\n  ydL = yd.length;\r\n\r\n  // Compare digit by digit.\r\n  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\r\n    if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\r\n  }\r\n\r\n  // Compare lengths.\r\n  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * cos(0)         = 1\r\n * cos(-0)        = 1\r\n * cos(Infinity)  = NaN\r\n * cos(-Infinity) = NaN\r\n * cos(NaN)       = NaN\r\n *\r\n */\r\nP.cosine = P.cos = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.d) return new Ctor(NaN);\r\n\r\n  // cos(0) = cos(-0) = 1\r\n  if (!x.d[0]) return new Ctor(1);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n  Ctor.rounding = 1;\r\n\r\n  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\r\n};\r\n\r\n\r\n/*\r\n *\r\n * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n *  cbrt(0)  =  0\r\n *  cbrt(-0) = -0\r\n *  cbrt(1)  =  1\r\n *  cbrt(-1) = -1\r\n *  cbrt(N)  =  N\r\n *  cbrt(-I) = -I\r\n *  cbrt(I)  =  I\r\n *\r\n * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n *\r\n */\r\nP.cubeRoot = P.cbrt = function () {\r\n  var e, m, n, r, rep, s, sd, t, t3, t3plusx,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n  external = false;\r\n\r\n  // Initial estimate.\r\n  s = x.s * mathpow(x.s * x, 1 / 3);\r\n\r\n   // Math.cbrt underflow/overflow?\r\n   // Pass x to Math.pow as integer, then adjust the exponent of the result.\r\n  if (!s || Math.abs(s) == 1 / 0) {\r\n    n = digitsToString(x.d);\r\n    e = x.e;\r\n\r\n    // Adjust n exponent so it is a multiple of 3 away from x exponent.\r\n    if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');\r\n    s = mathpow(n, 1 / 3);\r\n\r\n    // Rarely, e may be one less than the result exponent value.\r\n    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\r\n\r\n    if (s == 1 / 0) {\r\n      n = '5e' + e;\r\n    } else {\r\n      n = s.toExponential();\r\n      n = n.slice(0, n.indexOf('e') + 1) + e;\r\n    }\r\n\r\n    r = new Ctor(n);\r\n    r.s = x.s;\r\n  } else {\r\n    r = new Ctor(s.toString());\r\n  }\r\n\r\n  sd = (e = Ctor.precision) + 3;\r\n\r\n  // Halley's method.\r\n  // TODO? Compare Newton's method.\r\n  for (;;) {\r\n    t = r;\r\n    t3 = t.times(t).times(t);\r\n    t3plusx = t3.plus(x);\r\n    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\r\n\r\n    // TODO? Replace with for-loop and checkRoundingDigits.\r\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n      n = n.slice(sd - 3, sd + 1);\r\n\r\n      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\r\n      // , i.e. approaching a rounding boundary, continue the iteration.\r\n      if (n == '9999' || !rep && n == '4999') {\r\n\r\n        // On the first iteration only, check to see if rounding up gives the exact result as the\r\n        // nines may infinitely repeat.\r\n        if (!rep) {\r\n          finalise(t, e + 1, 0);\r\n\r\n          if (t.times(t).times(t).eq(x)) {\r\n            r = t;\r\n            break;\r\n          }\r\n        }\r\n\r\n        sd += 4;\r\n        rep = 1;\r\n      } else {\r\n\r\n        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n        // If not, then there are further digits and m will be truthy.\r\n        if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n          // Truncate to the first rounding digit.\r\n          finalise(r, e + 1, 1);\r\n          m = !r.times(r).times(r).eq(x);\r\n        }\r\n\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  external = true;\r\n\r\n  return finalise(r, e, Ctor.rounding, m);\r\n};\r\n\r\n\r\n/*\r\n * Return the number of decimal places of the value of this Decimal.\r\n *\r\n */\r\nP.decimalPlaces = P.dp = function () {\r\n  var w,\r\n    d = this.d,\r\n    n = NaN;\r\n\r\n  if (d) {\r\n    w = d.length - 1;\r\n    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n    // Subtract the number of trailing zeros of the last word.\r\n    w = d[w];\r\n    if (w) for (; w % 10 == 0; w /= 10) n--;\r\n    if (n < 0) n = 0;\r\n  }\r\n\r\n  return n;\r\n};\r\n\r\n\r\n/*\r\n *  n / 0 = I\r\n *  n / N = N\r\n *  n / I = 0\r\n *  0 / n = 0\r\n *  0 / 0 = N\r\n *  0 / N = N\r\n *  0 / I = 0\r\n *  N / n = N\r\n *  N / 0 = N\r\n *  N / N = N\r\n *  N / I = N\r\n *  I / n = I\r\n *  I / 0 = I\r\n *  I / N = N\r\n *  I / I = N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.dividedBy = P.div = function (y) {\r\n  return divide(this, new this.constructor(y));\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.dividedToIntegerBy = P.divToInt = function (y) {\r\n  var x = this,\r\n    Ctor = x.constructor;\r\n  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n *\r\n */\r\nP.equals = P.eq = function (y) {\r\n  return this.cmp(y) === 0;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n * direction of negative Infinity.\r\n *\r\n */\r\nP.floor = function () {\r\n  return finalise(new this.constructor(this), this.e + 1, 3);\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n * false.\r\n *\r\n */\r\nP.greaterThan = P.gt = function (y) {\r\n  return this.cmp(y) > 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n * otherwise return false.\r\n *\r\n */\r\nP.greaterThanOrEqualTo = P.gte = function (y) {\r\n  var k = this.cmp(y);\r\n  return k == 1 || k === 0;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [1, Infinity]\r\n *\r\n * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n *\r\n * cosh(0)         = 1\r\n * cosh(-0)        = 1\r\n * cosh(Infinity)  = Infinity\r\n * cosh(-Infinity) = Infinity\r\n * cosh(NaN)       = NaN\r\n *\r\n *  x        time taken (ms)   result\r\n * 1000      9                 9.8503555700852349694e+433\r\n * 10000     25                4.4034091128314607936e+4342\r\n * 100000    171               1.4033316802130615897e+43429\r\n * 1000000   3817              1.5166076984010437725e+434294\r\n * 10000000  abandoned after 2 minute wait\r\n *\r\n * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n *\r\n */\r\nP.hyperbolicCosine = P.cosh = function () {\r\n  var k, n, pr, rm, len,\r\n    x = this,\r\n    Ctor = x.constructor,\r\n    one = new Ctor(1);\r\n\r\n  if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\r\n  if (x.isZero()) return one;\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n  Ctor.rounding = 1;\r\n  len = x.d.length;\r\n\r\n  // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\r\n  // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\r\n\r\n  // Estimate the optimum number of times to use the argument reduction.\r\n  // TODO? Estimation reused from cosine() and may not be optimal here.\r\n  if (len < 32) {\r\n    k = Math.ceil(len / 3);\r\n    n = (1 / tinyPow(4, k)).toString();\r\n  } else {\r\n    k = 16;\r\n    n = '2.3283064365386962890625e-10';\r\n  }\r\n\r\n  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\r\n\r\n  // Reverse argument reduction\r\n  var cosh2_x,\r\n    i = k,\r\n    d8 = new Ctor(8);\r\n  for (; i--;) {\r\n    cosh2_x = x.times(x);\r\n    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\r\n  }\r\n\r\n  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n *\r\n * sinh(0)         = 0\r\n * sinh(-0)        = -0\r\n * sinh(Infinity)  = Infinity\r\n * sinh(-Infinity) = -Infinity\r\n * sinh(NaN)       = NaN\r\n *\r\n * x        time taken (ms)\r\n * 10       2 ms\r\n * 100      5 ms\r\n * 1000     14 ms\r\n * 10000    82 ms\r\n * 100000   886 ms            1.4033316802130615897e+43429\r\n * 200000   2613 ms\r\n * 300000   5407 ms\r\n * 400000   8824 ms\r\n * 500000   13026 ms          8.7080643612718084129e+217146\r\n * 1000000  48543 ms\r\n *\r\n * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n *\r\n */\r\nP.hyperbolicSine = P.sinh = function () {\r\n  var k, pr, rm, len,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n  Ctor.rounding = 1;\r\n  len = x.d.length;\r\n\r\n  if (len < 3) {\r\n    x = taylorSeries(Ctor, 2, x, x, true);\r\n  } else {\r\n\r\n    // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\r\n    // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\r\n    // 3 multiplications and 1 addition\r\n\r\n    // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\r\n    // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\r\n    // 4 multiplications and 2 additions\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    k = 1.4 * Math.sqrt(len);\r\n    k = k > 16 ? 16 : k | 0;\r\n\r\n    x = x.times(1 / tinyPow(5, k));\r\n    x = taylorSeries(Ctor, 2, x, x, true);\r\n\r\n    // Reverse argument reduction\r\n    var sinh2_x,\r\n      d5 = new Ctor(5),\r\n      d16 = new Ctor(16),\r\n      d20 = new Ctor(20);\r\n    for (; k--;) {\r\n      sinh2_x = x.times(x);\r\n      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\r\n    }\r\n  }\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return finalise(x, pr, rm, true);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * tanh(x) = sinh(x) / cosh(x)\r\n *\r\n * tanh(0)         = 0\r\n * tanh(-0)        = -0\r\n * tanh(Infinity)  = 1\r\n * tanh(-Infinity) = -1\r\n * tanh(NaN)       = NaN\r\n *\r\n */\r\nP.hyperbolicTangent = P.tanh = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite()) return new Ctor(x.s);\r\n  if (x.isZero()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + 7;\r\n  Ctor.rounding = 1;\r\n\r\n  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n * this Decimal.\r\n *\r\n * Domain: [-1, 1]\r\n * Range: [0, pi]\r\n *\r\n * acos(x) = pi/2 - asin(x)\r\n *\r\n * acos(0)       = pi/2\r\n * acos(-0)      = pi/2\r\n * acos(1)       = 0\r\n * acos(-1)      = pi\r\n * acos(1/2)     = pi/3\r\n * acos(-1/2)    = 2*pi/3\r\n * acos(|x| > 1) = NaN\r\n * acos(NaN)     = NaN\r\n *\r\n */\r\nP.inverseCosine = P.acos = function () {\r\n  var halfPi,\r\n    x = this,\r\n    Ctor = x.constructor,\r\n    k = x.abs().cmp(1),\r\n    pr = Ctor.precision,\r\n    rm = Ctor.rounding;\r\n\r\n  if (k !== -1) {\r\n    return k === 0\r\n      // |x| is 1\r\n      ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)\r\n      // |x| > 1 or x is NaN\r\n      : new Ctor(NaN);\r\n  }\r\n\r\n  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n  // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\r\n\r\n  Ctor.precision = pr + 6;\r\n  Ctor.rounding = 1;\r\n\r\n  x = x.asin();\r\n  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return halfPi.minus(x);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n * value of this Decimal.\r\n *\r\n * Domain: [1, Infinity]\r\n * Range: [0, Infinity]\r\n *\r\n * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n *\r\n * acosh(x < 1)     = NaN\r\n * acosh(NaN)       = NaN\r\n * acosh(Infinity)  = Infinity\r\n * acosh(-Infinity) = NaN\r\n * acosh(0)         = NaN\r\n * acosh(-0)        = NaN\r\n * acosh(1)         = 0\r\n * acosh(-1)        = NaN\r\n *\r\n */\r\nP.inverseHyperbolicCosine = P.acosh = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\r\n  if (!x.isFinite()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\r\n  Ctor.rounding = 1;\r\n  external = false;\r\n\r\n  x = x.times(x).minus(1).sqrt().plus(x);\r\n\r\n  external = true;\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return x.ln();\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n * of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n *\r\n * asinh(NaN)       = NaN\r\n * asinh(Infinity)  = Infinity\r\n * asinh(-Infinity) = -Infinity\r\n * asinh(0)         = 0\r\n * asinh(-0)        = -0\r\n *\r\n */\r\nP.inverseHyperbolicSine = P.asinh = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\r\n  Ctor.rounding = 1;\r\n  external = false;\r\n\r\n  x = x.times(x).plus(1).sqrt().plus(x);\r\n\r\n  external = true;\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return x.ln();\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n * value of this Decimal.\r\n *\r\n * Domain: [-1, 1]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n *\r\n * atanh(|x| > 1)   = NaN\r\n * atanh(NaN)       = NaN\r\n * atanh(Infinity)  = NaN\r\n * atanh(-Infinity) = NaN\r\n * atanh(0)         = 0\r\n * atanh(-0)        = -0\r\n * atanh(1)         = Infinity\r\n * atanh(-1)        = -Infinity\r\n *\r\n */\r\nP.inverseHyperbolicTangent = P.atanh = function () {\r\n  var pr, rm, wpr, xsd,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite()) return new Ctor(NaN);\r\n  if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  xsd = x.sd();\r\n\r\n  if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\r\n\r\n  Ctor.precision = wpr = xsd - x.e;\r\n\r\n  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\r\n\r\n  Ctor.precision = pr + 4;\r\n  Ctor.rounding = 1;\r\n\r\n  x = x.ln();\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return x.times(0.5);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi/2, pi/2]\r\n *\r\n * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n *\r\n * asin(0)       = 0\r\n * asin(-0)      = -0\r\n * asin(1/2)     = pi/6\r\n * asin(-1/2)    = -pi/6\r\n * asin(1)       = pi/2\r\n * asin(-1)      = -pi/2\r\n * asin(|x| > 1) = NaN\r\n * asin(NaN)     = NaN\r\n *\r\n * TODO? Compare performance of Taylor series.\r\n *\r\n */\r\nP.inverseSine = P.asin = function () {\r\n  var halfPi, k,\r\n    pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (x.isZero()) return new Ctor(x);\r\n\r\n  k = x.abs().cmp(1);\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n\r\n  if (k !== -1) {\r\n\r\n    // |x| is 1\r\n    if (k === 0) {\r\n      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n      halfPi.s = x.s;\r\n      return halfPi;\r\n    }\r\n\r\n    // |x| > 1 or x is NaN\r\n    return new Ctor(NaN);\r\n  }\r\n\r\n  // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\r\n\r\n  Ctor.precision = pr + 6;\r\n  Ctor.rounding = 1;\r\n\r\n  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return x.times(2);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n * of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi/2, pi/2]\r\n *\r\n * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n *\r\n * atan(0)         = 0\r\n * atan(-0)        = -0\r\n * atan(1)         = pi/4\r\n * atan(-1)        = -pi/4\r\n * atan(Infinity)  = pi/2\r\n * atan(-Infinity) = -pi/2\r\n * atan(NaN)       = NaN\r\n *\r\n */\r\nP.inverseTangent = P.atan = function () {\r\n  var i, j, k, n, px, t, r, wpr, x2,\r\n    x = this,\r\n    Ctor = x.constructor,\r\n    pr = Ctor.precision,\r\n    rm = Ctor.rounding;\r\n\r\n  if (!x.isFinite()) {\r\n    if (!x.s) return new Ctor(NaN);\r\n    if (pr + 4 <= PI_PRECISION) {\r\n      r = getPi(Ctor, pr + 4, rm).times(0.5);\r\n      r.s = x.s;\r\n      return r;\r\n    }\r\n  } else if (x.isZero()) {\r\n    return new Ctor(x);\r\n  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\r\n    r = getPi(Ctor, pr + 4, rm).times(0.25);\r\n    r.s = x.s;\r\n    return r;\r\n  }\r\n\r\n  Ctor.precision = wpr = pr + 10;\r\n  Ctor.rounding = 1;\r\n\r\n  // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\r\n\r\n  // Argument reduction\r\n  // Ensure |x| < 0.42\r\n  // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\r\n\r\n  k = Math.min(28, wpr / LOG_BASE + 2 | 0);\r\n\r\n  for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));\r\n\r\n  external = false;\r\n\r\n  j = Math.ceil(wpr / LOG_BASE);\r\n  n = 1;\r\n  x2 = x.times(x);\r\n  r = new Ctor(x);\r\n  px = x;\r\n\r\n  // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n  for (; i !== -1;) {\r\n    px = px.times(x2);\r\n    t = r.minus(px.div(n += 2));\r\n\r\n    px = px.times(x2);\r\n    r = t.plus(px.div(n += 2));\r\n\r\n    if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);\r\n  }\r\n\r\n  if (k) r = r.times(2 << (k - 1));\r\n\r\n  external = true;\r\n\r\n  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n *\r\n */\r\nP.isFinite = function () {\r\n  return !!this.d;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is an integer, otherwise return false.\r\n *\r\n */\r\nP.isInteger = P.isInt = function () {\r\n  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is NaN, otherwise return false.\r\n *\r\n */\r\nP.isNaN = function () {\r\n  return !this.s;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is negative, otherwise return false.\r\n *\r\n */\r\nP.isNegative = P.isNeg = function () {\r\n  return this.s < 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is positive, otherwise return false.\r\n *\r\n */\r\nP.isPositive = P.isPos = function () {\r\n  return this.s > 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n *\r\n */\r\nP.isZero = function () {\r\n  return !!this.d && this.d[0] === 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n *\r\n */\r\nP.lessThan = P.lt = function (y) {\r\n  return this.cmp(y) < 0;\r\n};\r\n\r\n\r\n/*\r\n * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n *\r\n */\r\nP.lessThanOrEqualTo = P.lte = function (y) {\r\n  return this.cmp(y) < 1;\r\n};\r\n\r\n\r\n/*\r\n * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * If no base is specified, return log[10](arg).\r\n *\r\n * log[base](arg) = ln(arg) / ln(base)\r\n *\r\n * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n * otherwise:\r\n *\r\n * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n *\r\n * log[-b](a)       = NaN\r\n * log[0](a)        = NaN\r\n * log[1](a)        = NaN\r\n * log[NaN](a)      = NaN\r\n * log[Infinity](a) = NaN\r\n * log[b](0)        = -Infinity\r\n * log[b](-0)       = -Infinity\r\n * log[b](-a)       = NaN\r\n * log[b](1)        = 0\r\n * log[b](Infinity) = Infinity\r\n * log[b](NaN)      = NaN\r\n *\r\n * [base] {number|string|Decimal} The base of the logarithm.\r\n *\r\n */\r\nP.logarithm = P.log = function (base) {\r\n  var isBase10, d, denominator, k, inf, num, sd, r,\r\n    arg = this,\r\n    Ctor = arg.constructor,\r\n    pr = Ctor.precision,\r\n    rm = Ctor.rounding,\r\n    guard = 5;\r\n\r\n  // Default base is 10.\r\n  if (base == null) {\r\n    base = new Ctor(10);\r\n    isBase10 = true;\r\n  } else {\r\n    base = new Ctor(base);\r\n    d = base.d;\r\n\r\n    // Return NaN if base is negative, or non-finite, or is 0 or 1.\r\n    if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\r\n\r\n    isBase10 = base.eq(10);\r\n  }\r\n\r\n  d = arg.d;\r\n\r\n  // Is arg negative, non-finite, 0 or 1?\r\n  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\r\n    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\r\n  }\r\n\r\n  // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\r\n  // integer power of 10.\r\n  if (isBase10) {\r\n    if (d.length > 1) {\r\n      inf = true;\r\n    } else {\r\n      for (k = d[0]; k % 10 === 0;) k /= 10;\r\n      inf = k !== 1;\r\n    }\r\n  }\r\n\r\n  external = false;\r\n  sd = pr + guard;\r\n  num = naturalLogarithm(arg, sd);\r\n  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n\r\n  // The result will have 5 rounding digits.\r\n  r = divide(num, denominator, sd, 1);\r\n\r\n  // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\r\n  // calculate 10 further digits.\r\n  //\r\n  // If the result is known to have an infinite decimal expansion, repeat this until it is clear\r\n  // that the result is above or below the boundary. Otherwise, if after calculating the 10\r\n  // further digits, the last 14 are nines, round up and assume the result is exact.\r\n  // Also assume the result is exact if the last 14 are zero.\r\n  //\r\n  // Example of a result that will be incorrectly rounded:\r\n  // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\r\n  // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\r\n  // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\r\n  // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\r\n  // place is still 2.6.\r\n  if (checkRoundingDigits(r.d, k = pr, rm)) {\r\n\r\n    do {\r\n      sd += 10;\r\n      num = naturalLogarithm(arg, sd);\r\n      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n      r = divide(num, denominator, sd, 1);\r\n\r\n      if (!inf) {\r\n\r\n        // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\r\n        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\r\n          r = finalise(r, pr + 1, 0);\r\n        }\r\n\r\n        break;\r\n      }\r\n    } while (checkRoundingDigits(r.d, k += 10, rm));\r\n  }\r\n\r\n  external = true;\r\n\r\n  return finalise(r, pr, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\nP.max = function () {\r\n  Array.prototype.push.call(arguments, this);\r\n  return maxOrMin(this.constructor, arguments, 'lt');\r\n};\r\n */\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\nP.min = function () {\r\n  Array.prototype.push.call(arguments, this);\r\n  return maxOrMin(this.constructor, arguments, 'gt');\r\n};\r\n */\r\n\r\n\r\n/*\r\n *  n - 0 = n\r\n *  n - N = N\r\n *  n - I = -I\r\n *  0 - n = -n\r\n *  0 - 0 = 0\r\n *  0 - N = N\r\n *  0 - I = -I\r\n *  N - n = N\r\n *  N - 0 = N\r\n *  N - N = N\r\n *  N - I = N\r\n *  I - n = I\r\n *  I - 0 = I\r\n *  I - N = N\r\n *  I - I = N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.minus = P.sub = function (y) {\r\n  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  y = new Ctor(y);\r\n\r\n  // If either is not finite...\r\n  if (!x.d || !y.d) {\r\n\r\n    // Return NaN if either is NaN.\r\n    if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n    // Return y negated if x is finite and y is \u00B1Infinity.\r\n    else if (x.d) y.s = -y.s;\r\n\r\n    // Return x if y is finite and x is \u00B1Infinity.\r\n    // Return x if both are \u00B1Infinity with different signs.\r\n    // Return NaN if both are \u00B1Infinity with the same sign.\r\n    else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\r\n\r\n    return y;\r\n  }\r\n\r\n  // If signs differ...\r\n  if (x.s != y.s) {\r\n    y.s = -y.s;\r\n    return x.plus(y);\r\n  }\r\n\r\n  xd = x.d;\r\n  yd = y.d;\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n\r\n  // If either is zero...\r\n  if (!xd[0] || !yd[0]) {\r\n\r\n    // Return y negated if x is zero and y is non-zero.\r\n    if (yd[0]) y.s = -y.s;\r\n\r\n    // Return x if y is zero and x is non-zero.\r\n    else if (xd[0]) y = new Ctor(x);\r\n\r\n    // Return zero if both are zero.\r\n    // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.\r\n    else return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  }\r\n\r\n  // x and y are finite, non-zero numbers with the same sign.\r\n\r\n  // Calculate base 1e7 exponents.\r\n  e = mathfloor(y.e / LOG_BASE);\r\n  xe = mathfloor(x.e / LOG_BASE);\r\n\r\n  xd = xd.slice();\r\n  k = xe - e;\r\n\r\n  // If base 1e7 exponents differ...\r\n  if (k) {\r\n    xLTy = k < 0;\r\n\r\n    if (xLTy) {\r\n      d = xd;\r\n      k = -k;\r\n      len = yd.length;\r\n    } else {\r\n      d = yd;\r\n      e = xe;\r\n      len = xd.length;\r\n    }\r\n\r\n    // Numbers with massively different exponents would result in a very high number of\r\n    // zeros needing to be prepended, but this can be avoided while still ensuring correct\r\n    // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\r\n    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\r\n\r\n    if (k > i) {\r\n      k = i;\r\n      d.length = 1;\r\n    }\r\n\r\n    // Prepend zeros to equalise exponents.\r\n    d.reverse();\r\n    for (i = k; i--;) d.push(0);\r\n    d.reverse();\r\n\r\n  // Base 1e7 exponents equal.\r\n  } else {\r\n\r\n    // Check digits to determine which is the bigger number.\r\n\r\n    i = xd.length;\r\n    len = yd.length;\r\n    xLTy = i < len;\r\n    if (xLTy) len = i;\r\n\r\n    for (i = 0; i < len; i++) {\r\n      if (xd[i] != yd[i]) {\r\n        xLTy = xd[i] < yd[i];\r\n        break;\r\n      }\r\n    }\r\n\r\n    k = 0;\r\n  }\r\n\r\n  if (xLTy) {\r\n    d = xd;\r\n    xd = yd;\r\n    yd = d;\r\n    y.s = -y.s;\r\n  }\r\n\r\n  len = xd.length;\r\n\r\n  // Append zeros to `xd` if shorter.\r\n  // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\r\n  for (i = yd.length - len; i > 0; --i) xd[len++] = 0;\r\n\r\n  // Subtract yd from xd.\r\n  for (i = yd.length; i > k;) {\r\n\r\n    if (xd[--i] < yd[i]) {\r\n      for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;\r\n      --xd[j];\r\n      xd[i] += BASE;\r\n    }\r\n\r\n    xd[i] -= yd[i];\r\n  }\r\n\r\n  // Remove trailing zeros.\r\n  for (; xd[--len] === 0;) xd.pop();\r\n\r\n  // Remove leading zeros and adjust exponent accordingly.\r\n  for (; xd[0] === 0; xd.shift()) --e;\r\n\r\n  // Zero?\r\n  if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n  y.d = xd;\r\n  y.e = getBase10Exponent(xd, e);\r\n\r\n  return external ? finalise(y, pr, rm) : y;\r\n};\r\n\r\n\r\n/*\r\n *   n % 0 =  N\r\n *   n % N =  N\r\n *   n % I =  n\r\n *   0 % n =  0\r\n *  -0 % n = -0\r\n *   0 % 0 =  N\r\n *   0 % N =  N\r\n *   0 % I =  0\r\n *   N % n =  N\r\n *   N % 0 =  N\r\n *   N % N =  N\r\n *   N % I =  N\r\n *   I % n =  N\r\n *   I % 0 =  N\r\n *   I % N =  N\r\n *   I % I =  N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * The result depends on the modulo mode.\r\n *\r\n */\r\nP.modulo = P.mod = function (y) {\r\n  var q,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  y = new Ctor(y);\r\n\r\n  // Return NaN if x is \u00B1Infinity or NaN, or y is NaN or \u00B10.\r\n  if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\r\n\r\n  // Return x if y is \u00B1Infinity or x is \u00B10.\r\n  if (!y.d || x.d && !x.d[0]) {\r\n    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\r\n  }\r\n\r\n  // Prevent rounding of intermediate calculations.\r\n  external = false;\r\n\r\n  if (Ctor.modulo == 9) {\r\n\r\n    // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n    // result = x - q * y    where  0 <= result < abs(y)\r\n    q = divide(x, y.abs(), 0, 3, 1);\r\n    q.s *= y.s;\r\n  } else {\r\n    q = divide(x, y, 0, Ctor.modulo, 1);\r\n  }\r\n\r\n  q = q.times(y);\r\n\r\n  external = true;\r\n\r\n  return x.minus(q);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.naturalExponential = P.exp = function () {\r\n  return naturalExponential(this);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n * rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.naturalLogarithm = P.ln = function () {\r\n  return naturalLogarithm(this);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n * -1.\r\n *\r\n */\r\nP.negated = P.neg = function () {\r\n  var x = new this.constructor(this);\r\n  x.s = -x.s;\r\n  return finalise(x);\r\n};\r\n\r\n\r\n/*\r\n *  n + 0 = n\r\n *  n + N = N\r\n *  n + I = I\r\n *  0 + n = n\r\n *  0 + 0 = 0\r\n *  0 + N = N\r\n *  0 + I = I\r\n *  N + n = N\r\n *  N + 0 = N\r\n *  N + N = N\r\n *  N + I = N\r\n *  I + n = I\r\n *  I + 0 = I\r\n *  I + N = N\r\n *  I + I = I\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.plus = P.add = function (y) {\r\n  var carry, d, e, i, k, len, pr, rm, xd, yd,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  y = new Ctor(y);\r\n\r\n  // If either is not finite...\r\n  if (!x.d || !y.d) {\r\n\r\n    // Return NaN if either is NaN.\r\n    if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n    // Return x if y is finite and x is \u00B1Infinity.\r\n    // Return x if both are \u00B1Infinity with the same sign.\r\n    // Return NaN if both are \u00B1Infinity with different signs.\r\n    // Return y if x is finite and y is \u00B1Infinity.\r\n    else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\r\n\r\n    return y;\r\n  }\r\n\r\n   // If signs differ...\r\n  if (x.s != y.s) {\r\n    y.s = -y.s;\r\n    return x.minus(y);\r\n  }\r\n\r\n  xd = x.d;\r\n  yd = y.d;\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n\r\n  // If either is zero...\r\n  if (!xd[0] || !yd[0]) {\r\n\r\n    // Return x if y is zero.\r\n    // Return y if y is non-zero.\r\n    if (!yd[0]) y = new Ctor(x);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  }\r\n\r\n  // x and y are finite, non-zero numbers with the same sign.\r\n\r\n  // Calculate base 1e7 exponents.\r\n  k = mathfloor(x.e / LOG_BASE);\r\n  e = mathfloor(y.e / LOG_BASE);\r\n\r\n  xd = xd.slice();\r\n  i = k - e;\r\n\r\n  // If base 1e7 exponents differ...\r\n  if (i) {\r\n\r\n    if (i < 0) {\r\n      d = xd;\r\n      i = -i;\r\n      len = yd.length;\r\n    } else {\r\n      d = yd;\r\n      e = k;\r\n      len = xd.length;\r\n    }\r\n\r\n    // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\r\n    k = Math.ceil(pr / LOG_BASE);\r\n    len = k > len ? k + 1 : len + 1;\r\n\r\n    if (i > len) {\r\n      i = len;\r\n      d.length = 1;\r\n    }\r\n\r\n    // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\r\n    d.reverse();\r\n    for (; i--;) d.push(0);\r\n    d.reverse();\r\n  }\r\n\r\n  len = xd.length;\r\n  i = yd.length;\r\n\r\n  // If yd is longer than xd, swap xd and yd so xd points to the longer array.\r\n  if (len - i < 0) {\r\n    i = len;\r\n    d = yd;\r\n    yd = xd;\r\n    xd = d;\r\n  }\r\n\r\n  // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\r\n  for (carry = 0; i;) {\r\n    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\r\n    xd[i] %= BASE;\r\n  }\r\n\r\n  if (carry) {\r\n    xd.unshift(carry);\r\n    ++e;\r\n  }\r\n\r\n  // Remove trailing zeros.\r\n  // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n  for (len = xd.length; xd[--len] == 0;) xd.pop();\r\n\r\n  y.d = xd;\r\n  y.e = getBase10Exponent(xd, e);\r\n\r\n  return external ? finalise(y, pr, rm) : y;\r\n};\r\n\r\n\r\n/*\r\n * Return the number of significant digits of the value of this Decimal.\r\n *\r\n * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n *\r\n */\r\nP.precision = P.sd = function (z) {\r\n  var k,\r\n    x = this;\r\n\r\n  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\r\n\r\n  if (x.d) {\r\n    k = getPrecision(x.d);\r\n    if (z && x.e + 1 > k) k = x.e + 1;\r\n  } else {\r\n    k = NaN;\r\n  }\r\n\r\n  return k;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n * rounding mode `rounding`.\r\n *\r\n */\r\nP.round = function () {\r\n  var x = this,\r\n    Ctor = x.constructor;\r\n\r\n  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * sin(x) = x - x^3/3! + x^5/5! - ...\r\n *\r\n * sin(0)         = 0\r\n * sin(-0)        = -0\r\n * sin(Infinity)  = NaN\r\n * sin(-Infinity) = NaN\r\n * sin(NaN)       = NaN\r\n *\r\n */\r\nP.sine = P.sin = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite()) return new Ctor(NaN);\r\n  if (x.isZero()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n  Ctor.rounding = 1;\r\n\r\n  x = sine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n *  sqrt(-n) =  N\r\n *  sqrt(N)  =  N\r\n *  sqrt(-I) =  N\r\n *  sqrt(I)  =  I\r\n *  sqrt(0)  =  0\r\n *  sqrt(-0) = -0\r\n *\r\n */\r\nP.squareRoot = P.sqrt = function () {\r\n  var m, n, sd, r, rep, t,\r\n    x = this,\r\n    d = x.d,\r\n    e = x.e,\r\n    s = x.s,\r\n    Ctor = x.constructor;\r\n\r\n  // Negative/NaN/Infinity/zero?\r\n  if (s !== 1 || !d || !d[0]) {\r\n    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\r\n  }\r\n\r\n  external = false;\r\n\r\n  // Initial estimate.\r\n  s = Math.sqrt(+x);\r\n\r\n  // Math.sqrt underflow/overflow?\r\n  // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n  if (s == 0 || s == 1 / 0) {\r\n    n = digitsToString(d);\r\n\r\n    if ((n.length + e) % 2 == 0) n += '0';\r\n    s = Math.sqrt(n);\r\n    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n    if (s == 1 / 0) {\r\n      n = '5e' + e;\r\n    } else {\r\n      n = s.toExponential();\r\n      n = n.slice(0, n.indexOf('e') + 1) + e;\r\n    }\r\n\r\n    r = new Ctor(n);\r\n  } else {\r\n    r = new Ctor(s.toString());\r\n  }\r\n\r\n  sd = (e = Ctor.precision) + 3;\r\n\r\n  // Newton-Raphson iteration.\r\n  for (;;) {\r\n    t = r;\r\n    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\r\n\r\n    // TODO? Replace with for-loop and checkRoundingDigits.\r\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n      n = n.slice(sd - 3, sd + 1);\r\n\r\n      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\r\n      // 4999, i.e. approaching a rounding boundary, continue the iteration.\r\n      if (n == '9999' || !rep && n == '4999') {\r\n\r\n        // On the first iteration only, check to see if rounding up gives the exact result as the\r\n        // nines may infinitely repeat.\r\n        if (!rep) {\r\n          finalise(t, e + 1, 0);\r\n\r\n          if (t.times(t).eq(x)) {\r\n            r = t;\r\n            break;\r\n          }\r\n        }\r\n\r\n        sd += 4;\r\n        rep = 1;\r\n      } else {\r\n\r\n        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n        // If not, then there are further digits and m will be truthy.\r\n        if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n          // Truncate to the first rounding digit.\r\n          finalise(r, e + 1, 1);\r\n          m = !r.times(r).eq(x);\r\n        }\r\n\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  external = true;\r\n\r\n  return finalise(r, e, Ctor.rounding, m);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * tan(0)         = 0\r\n * tan(-0)        = -0\r\n * tan(Infinity)  = NaN\r\n * tan(-Infinity) = NaN\r\n * tan(NaN)       = NaN\r\n *\r\n */\r\nP.tangent = P.tan = function () {\r\n  var pr, rm,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (!x.isFinite()) return new Ctor(NaN);\r\n  if (x.isZero()) return new Ctor(x);\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n  Ctor.precision = pr + 10;\r\n  Ctor.rounding = 1;\r\n\r\n  x = x.sin();\r\n  x.s = 1;\r\n  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\r\n\r\n  Ctor.precision = pr;\r\n  Ctor.rounding = rm;\r\n\r\n  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\r\n};\r\n\r\n\r\n/*\r\n *  n * 0 = 0\r\n *  n * N = N\r\n *  n * I = I\r\n *  0 * n = 0\r\n *  0 * 0 = 0\r\n *  0 * N = N\r\n *  0 * I = N\r\n *  N * n = N\r\n *  N * 0 = N\r\n *  N * N = N\r\n *  N * I = N\r\n *  I * n = I\r\n *  I * 0 = N\r\n *  I * N = N\r\n *  I * I = I\r\n *\r\n * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n */\r\nP.times = P.mul = function (y) {\r\n  var carry, e, i, k, r, rL, t, xdL, ydL,\r\n    x = this,\r\n    Ctor = x.constructor,\r\n    xd = x.d,\r\n    yd = (y = new Ctor(y)).d;\r\n\r\n  y.s *= x.s;\r\n\r\n   // If either is NaN, \u00B1Infinity or \u00B10...\r\n  if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd\r\n\r\n      // Return NaN if either is NaN.\r\n      // Return NaN if x is \u00B10 and y is \u00B1Infinity, or y is \u00B10 and x is \u00B1Infinity.\r\n      ? NaN\r\n\r\n      // Return \u00B1Infinity if either is \u00B1Infinity.\r\n      // Return \u00B10 if either is \u00B10.\r\n      : !xd || !yd ? y.s / 0 : y.s * 0);\r\n  }\r\n\r\n  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\r\n  xdL = xd.length;\r\n  ydL = yd.length;\r\n\r\n  // Ensure xd points to the longer array.\r\n  if (xdL < ydL) {\r\n    r = xd;\r\n    xd = yd;\r\n    yd = r;\r\n    rL = xdL;\r\n    xdL = ydL;\r\n    ydL = rL;\r\n  }\r\n\r\n  // Initialise the result array with zeros.\r\n  r = [];\r\n  rL = xdL + ydL;\r\n  for (i = rL; i--;) r.push(0);\r\n\r\n  // Multiply!\r\n  for (i = ydL; --i >= 0;) {\r\n    carry = 0;\r\n    for (k = xdL + i; k > i;) {\r\n      t = r[k] + yd[i] * xd[k - i - 1] + carry;\r\n      r[k--] = t % BASE | 0;\r\n      carry = t / BASE | 0;\r\n    }\r\n\r\n    r[k] = (r[k] + carry) % BASE | 0;\r\n  }\r\n\r\n  // Remove trailing zeros.\r\n  for (; !r[--rL];) r.pop();\r\n\r\n  if (carry) ++e;\r\n  else r.shift();\r\n\r\n  y.d = r;\r\n  y.e = getBase10Exponent(r, e);\r\n\r\n  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toBinary = function (sd, rm) {\r\n  return toStringBinary(this, 2, sd, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n *\r\n * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toDecimalPlaces = P.toDP = function (dp, rm) {\r\n  var x = this,\r\n    Ctor = x.constructor;\r\n\r\n  x = new Ctor(x);\r\n  if (dp === void 0) return x;\r\n\r\n  checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n  if (rm === void 0) rm = Ctor.rounding;\r\n  else checkInt32(rm, 0, 8);\r\n\r\n  return finalise(x, dp + x.e + 1, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal in exponential notation rounded to\r\n * `dp` fixed decimal places using rounding mode `rounding`.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toExponential = function (dp, rm) {\r\n  var str,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (dp === void 0) {\r\n    str = finiteToString(x, true);\r\n  } else {\r\n    checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    x = finalise(new Ctor(x), dp + 1, rm);\r\n    str = finiteToString(x, true, dp + 1);\r\n  }\r\n\r\n  return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n * omitted.\r\n *\r\n * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n * (-0).toFixed(3) is '0.000'.\r\n * (-0.5).toFixed(0) is '-0'.\r\n *\r\n */\r\nP.toFixed = function (dp, rm) {\r\n  var str, y,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (dp === void 0) {\r\n    str = finiteToString(x);\r\n  } else {\r\n    checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    y = finalise(new Ctor(x), dp + x.e + 1, rm);\r\n    str = finiteToString(y, false, dp + y.e + 1);\r\n  }\r\n\r\n  // To determine whether to add the minus sign look at the value before it was rounded,\r\n  // i.e. look at `x` rather than `y`.\r\n  return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n};\r\n\r\n\r\n/*\r\n * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n * numerator and an integer denominator.\r\n *\r\n * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n * value necessary to represent the number exactly.\r\n *\r\n * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n *\r\n */\r\nP.toFraction = function (maxD) {\r\n  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,\r\n    x = this,\r\n    xd = x.d,\r\n    Ctor = x.constructor;\r\n\r\n  if (!xd) return new Ctor(x);\r\n\r\n  n1 = d0 = new Ctor(1);\r\n  d1 = n0 = new Ctor(0);\r\n\r\n  d = new Ctor(d1);\r\n  e = d.e = getPrecision(xd) - x.e - 1;\r\n  k = e % LOG_BASE;\r\n  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\r\n\r\n  if (maxD == null) {\r\n\r\n    // d is 10**e, the minimum max-denominator needed.\r\n    maxD = e > 0 ? d : n1;\r\n  } else {\r\n    n = new Ctor(maxD);\r\n    if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\r\n    maxD = n.gt(d) ? (e > 0 ? d : n1) : n;\r\n  }\r\n\r\n  external = false;\r\n  n = new Ctor(digitsToString(xd));\r\n  pr = Ctor.precision;\r\n  Ctor.precision = e = xd.length * LOG_BASE * 2;\r\n\r\n  for (;;)  {\r\n    q = divide(n, d, 0, 1, 1);\r\n    d2 = d0.plus(q.times(d1));\r\n    if (d2.cmp(maxD) == 1) break;\r\n    d0 = d1;\r\n    d1 = d2;\r\n    d2 = n1;\r\n    n1 = n0.plus(q.times(d2));\r\n    n0 = d2;\r\n    d2 = d;\r\n    d = n.minus(q.times(d2));\r\n    n = d2;\r\n  }\r\n\r\n  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\r\n  n0 = n0.plus(d2.times(n1));\r\n  d0 = d0.plus(d2.times(d1));\r\n  n0.s = n1.s = x.s;\r\n\r\n  // Determine which fraction is closer to x, n0/d0 or n1/d1?\r\n  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1\r\n      ? [n1, d1] : [n0, d0];\r\n\r\n  Ctor.precision = pr;\r\n  external = true;\r\n\r\n  return r;\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toHexadecimal = P.toHex = function (sd, rm) {\r\n  return toStringBinary(this, 16, sd, rm);\r\n};\r\n\r\n\r\n/*\r\n * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding\r\n * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.\r\n *\r\n * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n * or `y` is NaN, in which case the return value will be also be NaN.\r\n *\r\n * The return value is not affected by the value of `precision`.\r\n *\r\n * y {number|string|Decimal} The magnitude to round to a multiple of.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * 'toNearest() rounding mode not an integer: {rm}'\r\n * 'toNearest() rounding mode out of range: {rm}'\r\n *\r\n */\r\nP.toNearest = function (y, rm) {\r\n  var x = this,\r\n    Ctor = x.constructor;\r\n\r\n  x = new Ctor(x);\r\n\r\n  if (y == null) {\r\n\r\n    // If x is not finite, return x.\r\n    if (!x.d) return x;\r\n\r\n    y = new Ctor(1);\r\n    rm = Ctor.rounding;\r\n  } else {\r\n    y = new Ctor(y);\r\n    if (rm === void 0) {\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      checkInt32(rm, 0, 8);\r\n    }\r\n\r\n    // If x is not finite, return x if y is not NaN, else NaN.\r\n    if (!x.d) return y.s ? x : y;\r\n\r\n    // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\r\n    if (!y.d) {\r\n      if (y.s) y.s = x.s;\r\n      return y;\r\n    }\r\n  }\r\n\r\n  // If y is not zero, calculate the nearest multiple of y to x.\r\n  if (y.d[0]) {\r\n    external = false;\r\n    x = divide(x, y, 0, rm, 1).times(y);\r\n    external = true;\r\n    finalise(x);\r\n\r\n  // If y is zero, return zero with the sign of x.\r\n  } else {\r\n    y.s = x.s;\r\n    x = y;\r\n  }\r\n\r\n  return x;\r\n};\r\n\r\n\r\n/*\r\n * Return the value of this Decimal converted to a number primitive.\r\n * Zero keeps its sign.\r\n *\r\n */\r\nP.toNumber = function () {\r\n  return +this;\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toOctal = function (sd, rm) {\r\n  return toStringBinary(this, 8, sd, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n * to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * ECMAScript compliant.\r\n *\r\n *   pow(x, NaN)                           = NaN\r\n *   pow(x, \u00B10)                            = 1\r\n\r\n *   pow(NaN, non-zero)                    = NaN\r\n *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n *   pow(abs(x) > 1, -Infinity)            = +0\r\n *   pow(abs(x) == 1, \u00B1Infinity)           = NaN\r\n *   pow(abs(x) < 1, +Infinity)            = +0\r\n *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n *   pow(+Infinity, y > 0)                 = +Infinity\r\n *   pow(+Infinity, y < 0)                 = +0\r\n *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n *   pow(-Infinity, even integer > 0)      = +Infinity\r\n *   pow(-Infinity, odd integer < 0)       = -0\r\n *   pow(-Infinity, even integer < 0)      = +0\r\n *   pow(+0, y > 0)                        = +0\r\n *   pow(+0, y < 0)                        = +Infinity\r\n *   pow(-0, odd integer > 0)              = -0\r\n *   pow(-0, even integer > 0)             = +0\r\n *   pow(-0, odd integer < 0)              = -Infinity\r\n *   pow(-0, even integer < 0)             = +Infinity\r\n *   pow(finite x < 0, finite non-integer) = NaN\r\n *\r\n * For non-integer or very large exponents pow(x, y) is calculated using\r\n *\r\n *   x^y = exp(y*ln(x))\r\n *\r\n * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n * probability of an incorrectly rounded result\r\n * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n * i.e. 1 in 250,000,000,000,000\r\n *\r\n * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n *\r\n * y {number|string|Decimal} The power to which to raise this Decimal.\r\n *\r\n */\r\nP.toPower = P.pow = function (y) {\r\n  var e, k, pr, r, rm, s,\r\n    x = this,\r\n    Ctor = x.constructor,\r\n    yn = +(y = new Ctor(y));\r\n\r\n  // Either \u00B1Infinity, NaN or \u00B10?\r\n  if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));\r\n\r\n  x = new Ctor(x);\r\n\r\n  if (x.eq(1)) return x;\r\n\r\n  pr = Ctor.precision;\r\n  rm = Ctor.rounding;\r\n\r\n  if (y.eq(1)) return finalise(x, pr, rm);\r\n\r\n  // y exponent\r\n  e = mathfloor(y.e / LOG_BASE);\r\n\r\n  // If y is a small integer use the 'exponentiation by squaring' algorithm.\r\n  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\r\n    r = intPow(Ctor, x, k, pr);\r\n    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\r\n  }\r\n\r\n  s = x.s;\r\n\r\n  // if x is negative\r\n  if (s < 0) {\r\n\r\n    // if y is not an integer\r\n    if (e < y.d.length - 1) return new Ctor(NaN);\r\n\r\n    // Result is positive if x is negative and the last digit of integer y is even.\r\n    if ((y.d[e] & 1) == 0) s = 1;\r\n\r\n    // if x.eq(-1)\r\n    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\r\n      x.s = s;\r\n      return x;\r\n    }\r\n  }\r\n\r\n  // Estimate result exponent.\r\n  // x^y = 10^e,  where e = y * log10(x)\r\n  // log10(x) = log10(x_significand) + x_exponent\r\n  // log10(x_significand) = ln(x_significand) / ln(10)\r\n  k = mathpow(+x, yn);\r\n  e = k == 0 || !isFinite(k)\r\n    ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))\r\n    : new Ctor(k + '').e;\r\n\r\n  // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\r\n\r\n  // Overflow/underflow?\r\n  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);\r\n\r\n  external = false;\r\n  Ctor.rounding = x.s = 1;\r\n\r\n  // Estimate the extra guard digits needed to ensure five correct rounding digits from\r\n  // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\r\n  // new Decimal(2.32456).pow('2087987436534566.46411')\r\n  // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\r\n  k = Math.min(12, (e + '').length);\r\n\r\n  // r = x^y = exp(y*ln(x))\r\n  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\r\n\r\n  // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)\r\n  if (r.d) {\r\n\r\n    // Truncate to the required precision plus five rounding digits.\r\n    r = finalise(r, pr + 5, 1);\r\n\r\n    // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\r\n    // the result.\r\n    if (checkRoundingDigits(r.d, pr, rm)) {\r\n      e = pr + 10;\r\n\r\n      // Truncate to the increased precision plus five rounding digits.\r\n      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\r\n\r\n      // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\r\n      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\r\n        r = finalise(r, pr + 1, 0);\r\n      }\r\n    }\r\n  }\r\n\r\n  r.s = s;\r\n  external = true;\r\n  Ctor.rounding = rm;\r\n\r\n  return finalise(r, pr, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n * the integer part of the value in normal notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */\r\nP.toPrecision = function (sd, rm) {\r\n  var str,\r\n    x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (sd === void 0) {\r\n    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n  } else {\r\n    checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    x = finalise(new Ctor(x), sd, rm);\r\n    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\r\n  }\r\n\r\n  return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n * omitted.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * 'toSD() digits out of range: {sd}'\r\n * 'toSD() digits not an integer: {sd}'\r\n * 'toSD() rounding mode not an integer: {rm}'\r\n * 'toSD() rounding mode out of range: {rm}'\r\n *\r\n */\r\nP.toSignificantDigits = P.toSD = function (sd, rm) {\r\n  var x = this,\r\n    Ctor = x.constructor;\r\n\r\n  if (sd === void 0) {\r\n    sd = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n  } else {\r\n    checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n  }\r\n\r\n  return finalise(new Ctor(x), sd, rm);\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal.\r\n *\r\n * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n *\r\n */\r\nP.toString = function () {\r\n  var x = this,\r\n    Ctor = x.constructor,\r\n    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n  return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n};\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n *\r\n */\r\nP.truncated = P.trunc = function () {\r\n  return finalise(new this.constructor(this), this.e + 1, 1);\r\n};\r\n\r\n\r\n/*\r\n * Return a string representing the value of this Decimal.\r\n * Unlike `toString`, negative zero will include the minus sign.\r\n *\r\n */\r\nP.valueOf = P.toJSON = function () {\r\n  var x = this,\r\n    Ctor = x.constructor,\r\n    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n  return x.isNeg() ? '-' + str : str;\r\n};\r\n\r\n\r\n/*\r\n// Add aliases to match BigDecimal method names.\r\n// P.add = P.plus;\r\nP.subtract = P.minus;\r\nP.multiply = P.times;\r\nP.divide = P.div;\r\nP.remainder = P.mod;\r\nP.compareTo = P.cmp;\r\nP.negate = P.neg;\r\n */\r\n\r\n\r\n// Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\r\n\r\n\r\n/*\r\n *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n *                           finiteToString, naturalExponential, naturalLogarithm\r\n *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n *  convertBase              toStringBinary, parseOther\r\n *  cos                      P.cos\r\n *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n *                           taylorSeries, atan2, parseOther\r\n *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n *                           naturalLogarithm, ceil, floor, round, trunc\r\n *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n *                           toStringBinary\r\n *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n *  getLn10                  P.logarithm, naturalLogarithm\r\n *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n *  getPrecision             P.precision, P.toFraction\r\n *  getZeroString            digitsToString, finiteToString\r\n *  intPow                   P.toPower, parseOther\r\n *  isOdd                    toLessThanHalfPi\r\n *  maxOrMin                 max, min\r\n *  naturalExponential       P.naturalExponential, P.toPower\r\n *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n *                           P.toPower, naturalExponential\r\n *  nonFiniteToString        finiteToString, toStringBinary\r\n *  parseDecimal             Decimal\r\n *  parseOther               Decimal\r\n *  sin                      P.sin\r\n *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n *  toLessThanHalfPi         P.cos, P.sin\r\n *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n *  truncate                 intPow\r\n *\r\n *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n *                           naturalLogarithm, config, parseOther, random, Decimal\r\n */\r\n\r\n\r\nfunction digitsToString(d) {\r\n  var i, k, ws,\r\n    indexOfLastWord = d.length - 1,\r\n    str = '',\r\n    w = d[0];\r\n\r\n  if (indexOfLastWord > 0) {\r\n    str += w;\r\n    for (i = 1; i < indexOfLastWord; i++) {\r\n      ws = d[i] + '';\r\n      k = LOG_BASE - ws.length;\r\n      if (k) str += getZeroString(k);\r\n      str += ws;\r\n    }\r\n\r\n    w = d[i];\r\n    ws = w + '';\r\n    k = LOG_BASE - ws.length;\r\n    if (k) str += getZeroString(k);\r\n  } else if (w === 0) {\r\n    return '0';\r\n  }\r\n\r\n  // Remove trailing zeros of last w.\r\n  for (; w % 10 === 0;) w /= 10;\r\n\r\n  return str + w;\r\n}\r\n\r\n\r\nfunction checkInt32(i, min, max) {\r\n  if (i !== ~~i || i < min || i > max) {\r\n    throw Error(invalidArgument + i);\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n * `repeating == null` if caller is `log` or `pow`,\r\n * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n */\r\nfunction checkRoundingDigits(d, i, rm, repeating) {\r\n  var di, k, r, rd;\r\n\r\n  // Get the length of the first word of the array d.\r\n  for (k = d[0]; k >= 10; k /= 10) --i;\r\n\r\n  // Is the rounding digit in the first word of d?\r\n  if (--i < 0) {\r\n    i += LOG_BASE;\r\n    di = 0;\r\n  } else {\r\n    di = Math.ceil((i + 1) / LOG_BASE);\r\n    i %= LOG_BASE;\r\n  }\r\n\r\n  // i is the index (0 - 6) of the rounding digit.\r\n  // E.g. if within the word 3487563 the first rounding digit is 5,\r\n  // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\r\n  k = mathpow(10, LOG_BASE - i);\r\n  rd = d[di] % k | 0;\r\n\r\n  if (repeating == null) {\r\n    if (i < 3) {\r\n      if (i == 0) rd = rd / 100 | 0;\r\n      else if (i == 1) rd = rd / 10 | 0;\r\n      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\r\n    } else {\r\n      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&\r\n        (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||\r\n          (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\r\n    }\r\n  } else {\r\n    if (i < 4) {\r\n      if (i == 0) rd = rd / 1000 | 0;\r\n      else if (i == 1) rd = rd / 100 | 0;\r\n      else if (i == 2) rd = rd / 10 | 0;\r\n      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\r\n    } else {\r\n      r = ((repeating || rm < 4) && rd + 1 == k ||\r\n      (!repeating && rm > 3) && rd + 1 == k / 2) &&\r\n        (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\r\n    }\r\n  }\r\n\r\n  return r;\r\n}\r\n\r\n\r\n// Convert string of `baseIn` to an array of numbers of `baseOut`.\r\n// Eg. convertBase('255', 10, 16) returns [15, 15].\r\n// Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\r\nfunction convertBase(str, baseIn, baseOut) {\r\n  var j,\r\n    arr = [0],\r\n    arrL,\r\n    i = 0,\r\n    strL = str.length;\r\n\r\n  for (; i < strL;) {\r\n    for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;\r\n    arr[0] += NUMERALS.indexOf(str.charAt(i++));\r\n    for (j = 0; j < arr.length; j++) {\r\n      if (arr[j] > baseOut - 1) {\r\n        if (arr[j + 1] === void 0) arr[j + 1] = 0;\r\n        arr[j + 1] += arr[j] / baseOut | 0;\r\n        arr[j] %= baseOut;\r\n      }\r\n    }\r\n  }\r\n\r\n  return arr.reverse();\r\n}\r\n\r\n\r\n/*\r\n * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n * |x| < pi/2\r\n *\r\n */\r\nfunction cosine(Ctor, x) {\r\n  var k, y,\r\n    len = x.d.length;\r\n\r\n  // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\r\n  // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\r\n\r\n  // Estimate the optimum number of times to use the argument reduction.\r\n  if (len < 32) {\r\n    k = Math.ceil(len / 3);\r\n    y = (1 / tinyPow(4, k)).toString();\r\n  } else {\r\n    k = 16;\r\n    y = '2.3283064365386962890625e-10';\r\n  }\r\n\r\n  Ctor.precision += k;\r\n\r\n  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\r\n\r\n  // Reverse argument reduction\r\n  for (var i = k; i--;) {\r\n    var cos2x = x.times(x);\r\n    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\r\n  }\r\n\r\n  Ctor.precision -= k;\r\n\r\n  return x;\r\n}\r\n\r\n\r\n/*\r\n * Perform division in the specified base.\r\n */\r\nvar divide = (function () {\r\n\r\n  // Assumes non-zero x and k, and hence non-zero result.\r\n  function multiplyInteger(x, k, base) {\r\n    var temp,\r\n      carry = 0,\r\n      i = x.length;\r\n\r\n    for (x = x.slice(); i--;) {\r\n      temp = x[i] * k + carry;\r\n      x[i] = temp % base | 0;\r\n      carry = temp / base | 0;\r\n    }\r\n\r\n    if (carry) x.unshift(carry);\r\n\r\n    return x;\r\n  }\r\n\r\n  function compare(a, b, aL, bL) {\r\n    var i, r;\r\n\r\n    if (aL != bL) {\r\n      r = aL > bL ? 1 : -1;\r\n    } else {\r\n      for (i = r = 0; i < aL; i++) {\r\n        if (a[i] != b[i]) {\r\n          r = a[i] > b[i] ? 1 : -1;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n  function subtract(a, b, aL, base) {\r\n    var i = 0;\r\n\r\n    // Subtract b from a.\r\n    for (; aL--;) {\r\n      a[aL] -= i;\r\n      i = a[aL] < b[aL] ? 1 : 0;\r\n      a[aL] = i * base + a[aL] - b[aL];\r\n    }\r\n\r\n    // Remove leading zeros.\r\n    for (; !a[0] && a.length > 1;) a.shift();\r\n  }\r\n\r\n  return function (x, y, pr, rm, dp, base) {\r\n    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,\r\n      yL, yz,\r\n      Ctor = x.constructor,\r\n      sign = x.s == y.s ? 1 : -1,\r\n      xd = x.d,\r\n      yd = y.d;\r\n\r\n    // Either NaN, Infinity or 0?\r\n    if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n      return new Ctor(// Return NaN if either NaN, or both Infinity or 0.\r\n        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :\r\n\r\n        // Return \u00B10 if x is 0 or y is \u00B1Infinity, or return \u00B1Infinity as y is 0.\r\n        xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\r\n    }\r\n\r\n    if (base) {\r\n      logBase = 1;\r\n      e = x.e - y.e;\r\n    } else {\r\n      base = BASE;\r\n      logBase = LOG_BASE;\r\n      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\r\n    }\r\n\r\n    yL = yd.length;\r\n    xL = xd.length;\r\n    q = new Ctor(sign);\r\n    qd = q.d = [];\r\n\r\n    // Result exponent may be one less than e.\r\n    // The digit array of a Decimal from toStringBinary may have trailing zeros.\r\n    for (i = 0; yd[i] == (xd[i] || 0); i++);\r\n\r\n    if (yd[i] > (xd[i] || 0)) e--;\r\n\r\n    if (pr == null) {\r\n      sd = pr = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    } else if (dp) {\r\n      sd = pr + (x.e - y.e) + 1;\r\n    } else {\r\n      sd = pr;\r\n    }\r\n\r\n    if (sd < 0) {\r\n      qd.push(1);\r\n      more = true;\r\n    } else {\r\n\r\n      // Convert precision in number of base 10 digits to base 1e7 digits.\r\n      sd = sd / logBase + 2 | 0;\r\n      i = 0;\r\n\r\n      // divisor < 1e7\r\n      if (yL == 1) {\r\n        k = 0;\r\n        yd = yd[0];\r\n        sd++;\r\n\r\n        // k is the carry.\r\n        for (; (i < xL || k) && sd--; i++) {\r\n          t = k * base + (xd[i] || 0);\r\n          qd[i] = t / yd | 0;\r\n          k = t % yd | 0;\r\n        }\r\n\r\n        more = k || i < xL;\r\n\r\n      // divisor >= 1e7\r\n      } else {\r\n\r\n        // Normalise xd and yd so highest order digit of yd is >= base/2\r\n        k = base / (yd[0] + 1) | 0;\r\n\r\n        if (k > 1) {\r\n          yd = multiplyInteger(yd, k, base);\r\n          xd = multiplyInteger(xd, k, base);\r\n          yL = yd.length;\r\n          xL = xd.length;\r\n        }\r\n\r\n        xi = yL;\r\n        rem = xd.slice(0, yL);\r\n        remL = rem.length;\r\n\r\n        // Add zeros to make remainder as long as divisor.\r\n        for (; remL < yL;) rem[remL++] = 0;\r\n\r\n        yz = yd.slice();\r\n        yz.unshift(0);\r\n        yd0 = yd[0];\r\n\r\n        if (yd[1] >= base / 2) ++yd0;\r\n\r\n        do {\r\n          k = 0;\r\n\r\n          // Compare divisor and remainder.\r\n          cmp = compare(yd, rem, yL, remL);\r\n\r\n          // If divisor < remainder.\r\n          if (cmp < 0) {\r\n\r\n            // Calculate trial digit, k.\r\n            rem0 = rem[0];\r\n            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n            // k will be how many times the divisor goes into the current remainder.\r\n            k = rem0 / yd0 | 0;\r\n\r\n            //  Algorithm:\r\n            //  1. product = divisor * trial digit (k)\r\n            //  2. if product > remainder: product -= divisor, k--\r\n            //  3. remainder -= product\r\n            //  4. if product was < remainder at 2:\r\n            //    5. compare new remainder and divisor\r\n            //    6. If remainder > divisor: remainder -= divisor, k++\r\n\r\n            if (k > 1) {\r\n              if (k >= base) k = base - 1;\r\n\r\n              // product = divisor * trial digit.\r\n              prod = multiplyInteger(yd, k, base);\r\n              prodL = prod.length;\r\n              remL = rem.length;\r\n\r\n              // Compare product and remainder.\r\n              cmp = compare(prod, rem, prodL, remL);\r\n\r\n              // product > remainder.\r\n              if (cmp == 1) {\r\n                k--;\r\n\r\n                // Subtract divisor from product.\r\n                subtract(prod, yL < prodL ? yz : yd, prodL, base);\r\n              }\r\n            } else {\r\n\r\n              // cmp is -1.\r\n              // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\r\n              // to avoid it. If k is 1 there is a need to compare yd and rem again below.\r\n              if (k == 0) cmp = k = 1;\r\n              prod = yd.slice();\r\n            }\r\n\r\n            prodL = prod.length;\r\n            if (prodL < remL) prod.unshift(0);\r\n\r\n            // Subtract product from remainder.\r\n            subtract(rem, prod, remL, base);\r\n\r\n            // If product was < previous remainder.\r\n            if (cmp == -1) {\r\n              remL = rem.length;\r\n\r\n              // Compare divisor and new remainder.\r\n              cmp = compare(yd, rem, yL, remL);\r\n\r\n              // If divisor < new remainder, subtract divisor from remainder.\r\n              if (cmp < 1) {\r\n                k++;\r\n\r\n                // Subtract divisor from remainder.\r\n                subtract(rem, yL < remL ? yz : yd, remL, base);\r\n              }\r\n            }\r\n\r\n            remL = rem.length;\r\n          } else if (cmp === 0) {\r\n            k++;\r\n            rem = [0];\r\n          }    // if cmp === 1, k will be 0\r\n\r\n          // Add the next digit, k, to the result array.\r\n          qd[i++] = k;\r\n\r\n          // Update the remainder.\r\n          if (cmp && rem[0]) {\r\n            rem[remL++] = xd[xi] || 0;\r\n          } else {\r\n            rem = [xd[xi]];\r\n            remL = 1;\r\n          }\r\n\r\n        } while ((xi++ < xL || rem[0] !== void 0) && sd--);\r\n\r\n        more = rem[0] !== void 0;\r\n      }\r\n\r\n      // Leading zero?\r\n      if (!qd[0]) qd.shift();\r\n    }\r\n\r\n    // logBase is 1 when divide is being used for base conversion.\r\n    if (logBase == 1) {\r\n      q.e = e;\r\n      inexact = more;\r\n    } else {\r\n\r\n      // To calculate q.e, first get the number of digits of qd[0].\r\n      for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;\r\n      q.e = i + e * logBase - 1;\r\n\r\n      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\r\n    }\r\n\r\n    return q;\r\n  };\r\n})();\r\n\r\n\r\n/*\r\n * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n * Check for over/under-flow.\r\n */\r\n function finalise(x, sd, rm, isTruncated) {\r\n  var digits, i, j, k, rd, roundUp, w, xd, xdi,\r\n    Ctor = x.constructor;\r\n\r\n  // Don't round if sd is null or undefined.\r\n  out: if (sd != null) {\r\n    xd = x.d;\r\n\r\n    // Infinity/NaN.\r\n    if (!xd) return x;\r\n\r\n    // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n    // w: the word of xd containing rd, a base 1e7 number.\r\n    // xdi: the index of w within xd.\r\n    // digits: the number of digits of w.\r\n    // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\r\n    // they had leading zeros)\r\n    // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\r\n\r\n    // Get the length of the first word of the digits array xd.\r\n    for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;\r\n    i = sd - digits;\r\n\r\n    // Is the rounding digit in the first word of xd?\r\n    if (i < 0) {\r\n      i += LOG_BASE;\r\n      j = sd;\r\n      w = xd[xdi = 0];\r\n\r\n      // Get the rounding digit at index j of w.\r\n      rd = w / mathpow(10, digits - j - 1) % 10 | 0;\r\n    } else {\r\n      xdi = Math.ceil((i + 1) / LOG_BASE);\r\n      k = xd.length;\r\n      if (xdi >= k) {\r\n        if (isTruncated) {\r\n\r\n          // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\r\n          for (; k++ <= xdi;) xd.push(0);\r\n          w = rd = 0;\r\n          digits = 1;\r\n          i %= LOG_BASE;\r\n          j = i - LOG_BASE + 1;\r\n        } else {\r\n          break out;\r\n        }\r\n      } else {\r\n        w = k = xd[xdi];\r\n\r\n        // Get the number of digits of w.\r\n        for (digits = 1; k >= 10; k /= 10) digits++;\r\n\r\n        // Get the index of rd within w.\r\n        i %= LOG_BASE;\r\n\r\n        // Get the index of rd within w, adjusted for leading zeros.\r\n        // The number of leading zeros of w is given by LOG_BASE - digits.\r\n        j = i - LOG_BASE + digits;\r\n\r\n        // Get the rounding digit at index j of w.\r\n        rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\r\n      }\r\n    }\r\n\r\n    // Are there any non-zero digits after the rounding digit?\r\n    isTruncated = isTruncated || sd < 0 ||\r\n      xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\r\n\r\n    // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\r\n    // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\r\n    // will give 714.\r\n\r\n    roundUp = rm < 4\r\n      ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n      : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&\r\n\r\n        // Check whether the digit to the left of the rounding digit is odd.\r\n        ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||\r\n          rm == (x.s < 0 ? 8 : 7));\r\n\r\n    if (sd < 1 || !xd[0]) {\r\n      xd.length = 0;\r\n      if (roundUp) {\r\n\r\n        // Convert sd to decimal places.\r\n        sd -= x.e + 1;\r\n\r\n        // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n        xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\r\n        x.e = -sd || 0;\r\n      } else {\r\n\r\n        // Zero.\r\n        xd[0] = x.e = 0;\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n    // Remove excess digits.\r\n    if (i == 0) {\r\n      xd.length = xdi;\r\n      k = 1;\r\n      xdi--;\r\n    } else {\r\n      xd.length = xdi + 1;\r\n      k = mathpow(10, LOG_BASE - i);\r\n\r\n      // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n      // j > 0 means i > number of leading zeros of w.\r\n      xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\r\n    }\r\n\r\n    if (roundUp) {\r\n      for (;;) {\r\n\r\n        // Is the digit to be rounded up in the first word of xd?\r\n        if (xdi == 0) {\r\n\r\n          // i will be the length of xd[0] before k is added.\r\n          for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;\r\n          j = xd[0] += k;\r\n          for (k = 1; j >= 10; j /= 10) k++;\r\n\r\n          // if i != k the length has increased.\r\n          if (i != k) {\r\n            x.e++;\r\n            if (xd[0] == BASE) xd[0] = 1;\r\n          }\r\n\r\n          break;\r\n        } else {\r\n          xd[xdi] += k;\r\n          if (xd[xdi] != BASE) break;\r\n          xd[xdi--] = 0;\r\n          k = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (i = xd.length; xd[--i] === 0;) xd.pop();\r\n  }\r\n\r\n  if (external) {\r\n\r\n    // Overflow?\r\n    if (x.e > Ctor.maxE) {\r\n\r\n      // Infinity.\r\n      x.d = null;\r\n      x.e = NaN;\r\n\r\n    // Underflow?\r\n    } else if (x.e < Ctor.minE) {\r\n\r\n      // Zero.\r\n      x.e = 0;\r\n      x.d = [0];\r\n      // Ctor.underflow = true;\r\n    } // else Ctor.underflow = false;\r\n  }\r\n\r\n  return x;\r\n}\r\n\r\n\r\nfunction finiteToString(x, isExp, sd) {\r\n  if (!x.isFinite()) return nonFiniteToString(x);\r\n  var k,\r\n    e = x.e,\r\n    str = digitsToString(x.d),\r\n    len = str.length;\r\n\r\n  if (isExp) {\r\n    if (sd && (k = sd - len) > 0) {\r\n      str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);\r\n    } else if (len > 1) {\r\n      str = str.charAt(0) + '.' + str.slice(1);\r\n    }\r\n\r\n    str = str + (x.e < 0 ? 'e' : 'e+') + x.e;\r\n  } else if (e < 0) {\r\n    str = '0.' + getZeroString(-e - 1) + str;\r\n    if (sd && (k = sd - len) > 0) str += getZeroString(k);\r\n  } else if (e >= len) {\r\n    str += getZeroString(e + 1 - len);\r\n    if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);\r\n  } else {\r\n    if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);\r\n    if (sd && (k = sd - len) > 0) {\r\n      if (e + 1 === len) str += '.';\r\n      str += getZeroString(k);\r\n    }\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\n\r\n// Calculate the base 10 exponent from the base 1e7 exponent.\r\nfunction getBase10Exponent(digits, e) {\r\n  var w = digits[0];\r\n\r\n  // Add the number of digits of the first word of the digits array.\r\n  for ( e *= LOG_BASE; w >= 10; w /= 10) e++;\r\n  return e;\r\n}\r\n\r\n\r\nfunction getLn10(Ctor, sd, pr) {\r\n  if (sd > LN10_PRECISION) {\r\n\r\n    // Reset global state in case the exception is caught.\r\n    external = true;\r\n    if (pr) Ctor.precision = pr;\r\n    throw Error(precisionLimitExceeded);\r\n  }\r\n  return finalise(new Ctor(LN10), sd, 1, true);\r\n}\r\n\r\n\r\nfunction getPi(Ctor, sd, rm) {\r\n  if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\r\n  return finalise(new Ctor(PI), sd, rm, true);\r\n}\r\n\r\n\r\nfunction getPrecision(digits) {\r\n  var w = digits.length - 1,\r\n    len = w * LOG_BASE + 1;\r\n\r\n  w = digits[w];\r\n\r\n  // If non-zero...\r\n  if (w) {\r\n\r\n    // Subtract the number of trailing zeros of the last word.\r\n    for (; w % 10 == 0; w /= 10) len--;\r\n\r\n    // Add the number of digits of the first word.\r\n    for (w = digits[0]; w >= 10; w /= 10) len++;\r\n  }\r\n\r\n  return len;\r\n}\r\n\r\n\r\nfunction getZeroString(k) {\r\n  var zs = '';\r\n  for (; k--;) zs += '0';\r\n  return zs;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n * integer of type number.\r\n *\r\n * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n *\r\n */\r\nfunction intPow(Ctor, x, n, pr) {\r\n  var isTruncated,\r\n    r = new Ctor(1),\r\n\r\n    // Max n of 9007199254740991 takes 53 loop iterations.\r\n    // Maximum digits array length; leaves [28, 34] guard digits.\r\n    k = Math.ceil(pr / LOG_BASE + 4);\r\n\r\n  external = false;\r\n\r\n  for (;;) {\r\n    if (n % 2) {\r\n      r = r.times(x);\r\n      if (truncate(r.d, k)) isTruncated = true;\r\n    }\r\n\r\n    n = mathfloor(n / 2);\r\n    if (n === 0) {\r\n\r\n      // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\r\n      n = r.d.length - 1;\r\n      if (isTruncated && r.d[n] === 0) ++r.d[n];\r\n      break;\r\n    }\r\n\r\n    x = x.times(x);\r\n    truncate(x.d, k);\r\n  }\r\n\r\n  external = true;\r\n\r\n  return r;\r\n}\r\n\r\n\r\nfunction isOdd(n) {\r\n  return n.d[n.d.length - 1] & 1;\r\n}\r\n\r\n\r\n/*\r\n * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.\r\n */\r\nfunction maxOrMin(Ctor, args, ltgt) {\r\n  var y,\r\n    x = new Ctor(args[0]),\r\n    i = 0;\r\n\r\n  for (; ++i < args.length;) {\r\n    y = new Ctor(args[i]);\r\n    if (!y.s) {\r\n      x = y;\r\n      break;\r\n    } else if (x[ltgt](y)) {\r\n      x = y;\r\n    }\r\n  }\r\n\r\n  return x;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n * digits.\r\n *\r\n * Taylor/Maclaurin series.\r\n *\r\n * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n *\r\n * Argument reduction:\r\n *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n *   exp(x) = exp(x / 2^k)^(2^k)\r\n *\r\n * Previously, the argument was initially reduced by\r\n * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n * found to be slower than just dividing repeatedly by 32 as above.\r\n *\r\n * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n *\r\n *  exp(Infinity)  = Infinity\r\n *  exp(-Infinity) = 0\r\n *  exp(NaN)       = NaN\r\n *  exp(\u00B10)        = 1\r\n *\r\n *  exp(x) is non-terminating for any finite, non-zero x.\r\n *\r\n *  The result will always be correctly rounded.\r\n *\r\n */\r\nfunction naturalExponential(x, sd) {\r\n  var denominator, guard, j, pow, sum, t, wpr,\r\n    rep = 0,\r\n    i = 0,\r\n    k = 0,\r\n    Ctor = x.constructor,\r\n    rm = Ctor.rounding,\r\n    pr = Ctor.precision;\r\n\r\n  // 0/NaN/Infinity?\r\n  if (!x.d || !x.d[0] || x.e > 17) {\r\n\r\n    return new Ctor(x.d\r\n      ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0\r\n      : x.s ? x.s < 0 ? 0 : x : 0 / 0);\r\n  }\r\n\r\n  if (sd == null) {\r\n    external = false;\r\n    wpr = pr;\r\n  } else {\r\n    wpr = sd;\r\n  }\r\n\r\n  t = new Ctor(0.03125);\r\n\r\n  // while abs(x) >= 0.1\r\n  while (x.e > -2) {\r\n\r\n    // x = x / 2^5\r\n    x = x.times(t);\r\n    k += 5;\r\n  }\r\n\r\n  // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\r\n  // necessary to ensure the first 4 rounding digits are correct.\r\n  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\r\n  wpr += guard;\r\n  denominator = pow = sum = new Ctor(1);\r\n  Ctor.precision = wpr;\r\n\r\n  for (;;) {\r\n    pow = finalise(pow.times(x), wpr, 1);\r\n    denominator = denominator.times(++i);\r\n    t = sum.plus(divide(pow, denominator, wpr, 1));\r\n\r\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n      j = k;\r\n      while (j--) sum = finalise(sum.times(sum), wpr, 1);\r\n\r\n      // Check to see if the first 4 rounding digits are [49]999.\r\n      // If so, repeat the summation with a higher precision, otherwise\r\n      // e.g. with precision: 18, rounding: 1\r\n      // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\r\n      // `wpr - guard` is the index of first rounding digit.\r\n      if (sd == null) {\r\n\r\n        if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n          Ctor.precision = wpr += 10;\r\n          denominator = pow = t = new Ctor(1);\r\n          i = 0;\r\n          rep++;\r\n        } else {\r\n          return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n        }\r\n      } else {\r\n        Ctor.precision = pr;\r\n        return sum;\r\n      }\r\n    }\r\n\r\n    sum = t;\r\n  }\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n * digits.\r\n *\r\n *  ln(-n)        = NaN\r\n *  ln(0)         = -Infinity\r\n *  ln(-0)        = -Infinity\r\n *  ln(1)         = 0\r\n *  ln(Infinity)  = Infinity\r\n *  ln(-Infinity) = NaN\r\n *  ln(NaN)       = NaN\r\n *\r\n *  ln(n) (n != 1) is non-terminating.\r\n *\r\n */\r\nfunction naturalLogarithm(y, sd) {\r\n  var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,\r\n    n = 1,\r\n    guard = 10,\r\n    x = y,\r\n    xd = x.d,\r\n    Ctor = x.constructor,\r\n    rm = Ctor.rounding,\r\n    pr = Ctor.precision;\r\n\r\n  // Is x negative or Infinity, NaN, 0 or 1?\r\n  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\r\n    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\r\n  }\r\n\r\n  if (sd == null) {\r\n    external = false;\r\n    wpr = pr;\r\n  } else {\r\n    wpr = sd;\r\n  }\r\n\r\n  Ctor.precision = wpr += guard;\r\n  c = digitsToString(xd);\r\n  c0 = c.charAt(0);\r\n\r\n  if (Math.abs(e = x.e) < 1.5e15) {\r\n\r\n    // Argument reduction.\r\n    // The series converges faster the closer the argument is to 1, so using\r\n    // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\r\n    // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\r\n    // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\r\n    // later be divided by this number, then separate out the power of 10 using\r\n    // ln(a*10^b) = ln(a) + b*ln(10).\r\n\r\n    // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\r\n    //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\r\n    // max n is 6 (gives 0.7 - 1.3)\r\n    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\r\n      x = x.times(y);\r\n      c = digitsToString(x.d);\r\n      c0 = c.charAt(0);\r\n      n++;\r\n    }\r\n\r\n    e = x.e;\r\n\r\n    if (c0 > 1) {\r\n      x = new Ctor('0.' + c);\r\n      e++;\r\n    } else {\r\n      x = new Ctor(c0 + '.' + c.slice(1));\r\n    }\r\n  } else {\r\n\r\n    // The argument reduction method above may result in overflow if the argument y is a massive\r\n    // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\r\n    // function using ln(x*10^e) = ln(x) + e*ln(10).\r\n    t = getLn10(Ctor, wpr + 2, pr).times(e + '');\r\n    x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);\r\n    Ctor.precision = pr;\r\n\r\n    return sd == null ? finalise(x, pr, rm, external = true) : x;\r\n  }\r\n\r\n  // x1 is x reduced to a value near 1.\r\n  x1 = x;\r\n\r\n  // Taylor series.\r\n  // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\r\n  // where x = (y - 1)/(y + 1)    (|x| < 1)\r\n  sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\r\n  x2 = finalise(x.times(x), wpr, 1);\r\n  denominator = 3;\r\n\r\n  for (;;) {\r\n    numerator = finalise(numerator.times(x2), wpr, 1);\r\n    t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\r\n\r\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n      sum = sum.times(2);\r\n\r\n      // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\r\n      // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\r\n      if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));\r\n      sum = divide(sum, new Ctor(n), wpr, 1);\r\n\r\n      // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\r\n      // been repeated previously) and the first 4 rounding digits 9999?\r\n      // If so, restart the summation with a higher precision, otherwise\r\n      // e.g. with precision: 12, rounding: 1\r\n      // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\r\n      // `wpr - guard` is the index of first rounding digit.\r\n      if (sd == null) {\r\n        if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n          Ctor.precision = wpr += guard;\r\n          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\r\n          x2 = finalise(x.times(x), wpr, 1);\r\n          denominator = rep = 1;\r\n        } else {\r\n          return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n        }\r\n      } else {\r\n        Ctor.precision = pr;\r\n        return sum;\r\n      }\r\n    }\r\n\r\n    sum = t;\r\n    denominator += 2;\r\n  }\r\n}\r\n\r\n\r\n// \u00B1Infinity, NaN.\r\nfunction nonFiniteToString(x) {\r\n  // Unsigned.\r\n  return String(x.s * x.s / 0);\r\n}\r\n\r\n\r\n/*\r\n * Parse the value of a new Decimal `x` from string `str`.\r\n */\r\nfunction parseDecimal(x, str) {\r\n  var e, i, len;\r\n\r\n  // Decimal point?\r\n  if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n  // Exponential form?\r\n  if ((i = str.search(/e/i)) > 0) {\r\n\r\n    // Determine exponent.\r\n    if (e < 0) e = i;\r\n    e += +str.slice(i + 1);\r\n    str = str.substring(0, i);\r\n  } else if (e < 0) {\r\n\r\n    // Integer.\r\n    e = str.length;\r\n  }\r\n\r\n  // Determine leading zeros.\r\n  for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n  // Determine trailing zeros.\r\n  for (len = str.length; str.charCodeAt(len - 1) === 48; --len);\r\n  str = str.slice(i, len);\r\n\r\n  if (str) {\r\n    len -= i;\r\n    x.e = e = e - i - 1;\r\n    x.d = [];\r\n\r\n    // Transform base\r\n\r\n    // e is the base 10 exponent.\r\n    // i is where to slice str to get the first word of the digits array.\r\n    i = (e + 1) % LOG_BASE;\r\n    if (e < 0) i += LOG_BASE;\r\n\r\n    if (i < len) {\r\n      if (i) x.d.push(+str.slice(0, i));\r\n      for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));\r\n      str = str.slice(i);\r\n      i = LOG_BASE - str.length;\r\n    } else {\r\n      i -= len;\r\n    }\r\n\r\n    for (; i--;) str += '0';\r\n    x.d.push(+str);\r\n\r\n    if (external) {\r\n\r\n      // Overflow?\r\n      if (x.e > x.constructor.maxE) {\r\n\r\n        // Infinity.\r\n        x.d = null;\r\n        x.e = NaN;\r\n\r\n      // Underflow?\r\n      } else if (x.e < x.constructor.minE) {\r\n\r\n        // Zero.\r\n        x.e = 0;\r\n        x.d = [0];\r\n        // x.constructor.underflow = true;\r\n      } // else x.constructor.underflow = false;\r\n    }\r\n  } else {\r\n\r\n    // Zero.\r\n    x.e = 0;\r\n    x.d = [0];\r\n  }\r\n\r\n  return x;\r\n}\r\n\r\n\r\n/*\r\n * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n */\r\nfunction parseOther(x, str) {\r\n  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\r\n\r\n  if (str === 'Infinity' || str === 'NaN') {\r\n    if (!+str) x.s = NaN;\r\n    x.e = NaN;\r\n    x.d = null;\r\n    return x;\r\n  }\r\n\r\n  if (isHex.test(str))  {\r\n    base = 16;\r\n    str = str.toLowerCase();\r\n  } else if (isBinary.test(str))  {\r\n    base = 2;\r\n  } else if (isOctal.test(str))  {\r\n    base = 8;\r\n  } else {\r\n    throw Error(invalidArgument + str);\r\n  }\r\n\r\n  // Is there a binary exponent part?\r\n  i = str.search(/p/i);\r\n\r\n  if (i > 0) {\r\n    p = +str.slice(i + 1);\r\n    str = str.substring(2, i);\r\n  } else {\r\n    str = str.slice(2);\r\n  }\r\n\r\n  // Convert `str` as an integer then divide the result by `base` raised to a power such that the\r\n  // fraction part will be restored.\r\n  i = str.indexOf('.');\r\n  isFloat = i >= 0;\r\n  Ctor = x.constructor;\r\n\r\n  if (isFloat) {\r\n    str = str.replace('.', '');\r\n    len = str.length;\r\n    i = len - i;\r\n\r\n    // log[10](16) = 1.2041... , log[10](88) = 1.9444....\r\n    divisor = intPow(Ctor, new Ctor(base), i, i * 2);\r\n  }\r\n\r\n  xd = convertBase(str, base, BASE);\r\n  xe = xd.length - 1;\r\n\r\n  // Remove trailing zeros.\r\n  for (i = xe; xd[i] === 0; --i) xd.pop();\r\n  if (i < 0) return new Ctor(x.s * 0);\r\n  x.e = getBase10Exponent(xd, xe);\r\n  x.d = xd;\r\n  external = false;\r\n\r\n  // At what precision to perform the division to ensure exact conversion?\r\n  // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\r\n  // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\r\n  // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\r\n  // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\r\n  // Therefore using 4 * the number of digits of str will always be enough.\r\n  if (isFloat) x = divide(x, divisor, len * 4);\r\n\r\n  // Multiply by the binary exponent part if present.\r\n  if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\r\n  external = true;\r\n\r\n  return x;\r\n}\r\n\r\n\r\n/*\r\n * sin(x) = x - x^3/3! + x^5/5! - ...\r\n * |x| < pi/2\r\n *\r\n */\r\nfunction sine(Ctor, x) {\r\n  var k,\r\n    len = x.d.length;\r\n\r\n  if (len < 3) return taylorSeries(Ctor, 2, x, x);\r\n\r\n  // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\r\n  // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\r\n  // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\r\n\r\n  // Estimate the optimum number of times to use the argument reduction.\r\n  k = 1.4 * Math.sqrt(len);\r\n  k = k > 16 ? 16 : k | 0;\r\n\r\n  x = x.times(1 / tinyPow(5, k));\r\n  x = taylorSeries(Ctor, 2, x, x);\r\n\r\n  // Reverse argument reduction\r\n  var sin2_x,\r\n    d5 = new Ctor(5),\r\n    d16 = new Ctor(16),\r\n    d20 = new Ctor(20);\r\n  for (; k--;) {\r\n    sin2_x = x.times(x);\r\n    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\r\n  }\r\n\r\n  return x;\r\n}\r\n\r\n\r\n// Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\r\nfunction taylorSeries(Ctor, n, x, y, isHyperbolic) {\r\n  var j, t, u, x2,\r\n    i = 1,\r\n    pr = Ctor.precision,\r\n    k = Math.ceil(pr / LOG_BASE);\r\n\r\n  external = false;\r\n  x2 = x.times(x);\r\n  u = new Ctor(y);\r\n\r\n  for (;;) {\r\n    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\r\n    u = isHyperbolic ? y.plus(t) : y.minus(t);\r\n    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\r\n    t = u.plus(y);\r\n\r\n    if (t.d[k] !== void 0) {\r\n      for (j = k; t.d[j] === u.d[j] && j--;);\r\n      if (j == -1) break;\r\n    }\r\n\r\n    j = u;\r\n    u = y;\r\n    y = t;\r\n    t = j;\r\n    i++;\r\n  }\r\n\r\n  external = true;\r\n  t.d.length = k + 1;\r\n\r\n  return t;\r\n}\r\n\r\n\r\n// Exponent e must be positive and non-zero.\r\nfunction tinyPow(b, e) {\r\n  var n = b;\r\n  while (--e) n *= b;\r\n  return n;\r\n}\r\n\r\n\r\n// Return the absolute value of `x` reduced to less than or equal to half pi.\r\nfunction toLessThanHalfPi(Ctor, x) {\r\n  var t,\r\n    isNeg = x.s < 0,\r\n    pi = getPi(Ctor, Ctor.precision, 1),\r\n    halfPi = pi.times(0.5);\r\n\r\n  x = x.abs();\r\n\r\n  if (x.lte(halfPi)) {\r\n    quadrant = isNeg ? 4 : 1;\r\n    return x;\r\n  }\r\n\r\n  t = x.divToInt(pi);\r\n\r\n  if (t.isZero()) {\r\n    quadrant = isNeg ? 3 : 2;\r\n  } else {\r\n    x = x.minus(t.times(pi));\r\n\r\n    // 0 <= x < pi\r\n    if (x.lte(halfPi)) {\r\n      quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);\r\n      return x;\r\n    }\r\n\r\n    quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);\r\n  }\r\n\r\n  return x.minus(pi).abs();\r\n}\r\n\r\n\r\n/*\r\n * Return the value of Decimal `x` as a string in base `baseOut`.\r\n *\r\n * If the optional `sd` argument is present include a binary exponent suffix.\r\n */\r\nfunction toStringBinary(x, baseOut, sd, rm) {\r\n  var base, e, i, k, len, roundUp, str, xd, y,\r\n    Ctor = x.constructor,\r\n    isExp = sd !== void 0;\r\n\r\n  if (isExp) {\r\n    checkInt32(sd, 1, MAX_DIGITS);\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n  } else {\r\n    sd = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n  }\r\n\r\n  if (!x.isFinite()) {\r\n    str = nonFiniteToString(x);\r\n  } else {\r\n    str = finiteToString(x);\r\n    i = str.indexOf('.');\r\n\r\n    // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\r\n    // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\r\n    // minBinaryExponent = floor(decimalExponent * log[2](10))\r\n    // log[2](10) = 3.321928094887362347870319429489390175864\r\n\r\n    if (isExp) {\r\n      base = 2;\r\n      if (baseOut == 16) {\r\n        sd = sd * 4 - 3;\r\n      } else if (baseOut == 8) {\r\n        sd = sd * 3 - 2;\r\n      }\r\n    } else {\r\n      base = baseOut;\r\n    }\r\n\r\n    // Convert the number as an integer then divide the result by its base raised to a power such\r\n    // that the fraction part will be restored.\r\n\r\n    // Non-integer.\r\n    if (i >= 0) {\r\n      str = str.replace('.', '');\r\n      y = new Ctor(1);\r\n      y.e = str.length - i;\r\n      y.d = convertBase(finiteToString(y), 10, base);\r\n      y.e = y.d.length;\r\n    }\r\n\r\n    xd = convertBase(str, 10, base);\r\n    e = len = xd.length;\r\n\r\n    // Remove trailing zeros.\r\n    for (; xd[--len] == 0;) xd.pop();\r\n\r\n    if (!xd[0]) {\r\n      str = isExp ? '0p+0' : '0';\r\n    } else {\r\n      if (i < 0) {\r\n        e--;\r\n      } else {\r\n        x = new Ctor(x);\r\n        x.d = xd;\r\n        x.e = e;\r\n        x = divide(x, y, sd, rm, 0, base);\r\n        xd = x.d;\r\n        e = x.e;\r\n        roundUp = inexact;\r\n      }\r\n\r\n      // The rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      i = xd[sd];\r\n      k = base / 2;\r\n      roundUp = roundUp || xd[sd + 1] !== void 0;\r\n\r\n      roundUp = rm < 4\r\n        ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))\r\n        : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||\r\n          rm === (x.s < 0 ? 8 : 7));\r\n\r\n      xd.length = sd;\r\n\r\n      if (roundUp) {\r\n\r\n        // Rounding up may mean the previous digit has to be rounded up and so on.\r\n        for (; ++xd[--sd] > base - 1;) {\r\n          xd[sd] = 0;\r\n          if (!sd) {\r\n            ++e;\r\n            xd.unshift(1);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Determine trailing zeros.\r\n      for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n      // E.g. [4, 11, 15] becomes 4bf.\r\n      for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n\r\n      // Add binary exponent suffix?\r\n      if (isExp) {\r\n        if (len > 1) {\r\n          if (baseOut == 16 || baseOut == 8) {\r\n            i = baseOut == 16 ? 4 : 3;\r\n            for (--len; len % i; len++) str += '0';\r\n            xd = convertBase(str, base, baseOut);\r\n            for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n            // xd[0] will always be be 1\r\n            for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n          } else {\r\n            str = str.charAt(0) + '.' + str.slice(1);\r\n          }\r\n        }\r\n\r\n        str =  str + (e < 0 ? 'p' : 'p+') + e;\r\n      } else if (e < 0) {\r\n        for (; ++e;) str = '0' + str;\r\n        str = '0.' + str;\r\n      } else {\r\n        if (++e > len) for (e -= len; e-- ;) str += '0';\r\n        else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);\r\n      }\r\n    }\r\n\r\n    str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;\r\n  }\r\n\r\n  return x.s < 0 ? '-' + str : str;\r\n}\r\n\r\n\r\n// Does not strip trailing zeros.\r\nfunction truncate(arr, len) {\r\n  if (arr.length > len) {\r\n    arr.length = len;\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n// Decimal methods\r\n\r\n\r\n/*\r\n *  abs\r\n *  acos\r\n *  acosh\r\n *  add\r\n *  asin\r\n *  asinh\r\n *  atan\r\n *  atanh\r\n *  atan2\r\n *  cbrt\r\n *  ceil\r\n *  clone\r\n *  config\r\n *  cos\r\n *  cosh\r\n *  div\r\n *  exp\r\n *  floor\r\n *  hypot\r\n *  ln\r\n *  log\r\n *  log2\r\n *  log10\r\n *  max\r\n *  min\r\n *  mod\r\n *  mul\r\n *  pow\r\n *  random\r\n *  round\r\n *  set\r\n *  sign\r\n *  sin\r\n *  sinh\r\n *  sqrt\r\n *  sub\r\n *  tan\r\n *  tanh\r\n *  trunc\r\n */\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the absolute value of `x`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction abs(x) {\r\n  return new this(x).abs();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction acos(x) {\r\n  return new this(x).acos();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction acosh(x) {\r\n  return new this(x).acosh();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */\r\nfunction add(x, y) {\r\n  return new this(x).plus(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction asin(x) {\r\n  return new this(x).asin();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction asinh(x) {\r\n  return new this(x).asinh();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction atan(x) {\r\n  return new this(x).atan();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction atanh(x) {\r\n  return new this(x).atanh();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi, pi]\r\n *\r\n * y {number|string|Decimal} The y-coordinate.\r\n * x {number|string|Decimal} The x-coordinate.\r\n *\r\n * atan2(\u00B10, -0)               = \u00B1pi\r\n * atan2(\u00B10, +0)               = \u00B10\r\n * atan2(\u00B10, -x)               = \u00B1pi for x > 0\r\n * atan2(\u00B10, x)                = \u00B10 for x > 0\r\n * atan2(-y, \u00B10)               = -pi/2 for y > 0\r\n * atan2(y, \u00B10)                = pi/2 for y > 0\r\n * atan2(\u00B1y, -Infinity)        = \u00B1pi for finite y > 0\r\n * atan2(\u00B1y, +Infinity)        = \u00B10 for finite y > 0\r\n * atan2(\u00B1Infinity, x)         = \u00B1pi/2 for finite x\r\n * atan2(\u00B1Infinity, -Infinity) = \u00B13*pi/4\r\n * atan2(\u00B1Infinity, +Infinity) = \u00B1pi/4\r\n * atan2(NaN, x) = NaN\r\n * atan2(y, NaN) = NaN\r\n *\r\n */\r\nfunction atan2(y, x) {\r\n  y = new this(y);\r\n  x = new this(x);\r\n  var r,\r\n    pr = this.precision,\r\n    rm = this.rounding,\r\n    wpr = pr + 4;\r\n\r\n  // Either NaN\r\n  if (!y.s || !x.s) {\r\n    r = new this(NaN);\r\n\r\n  // Both \u00B1Infinity\r\n  } else if (!y.d && !x.d) {\r\n    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\r\n    r.s = y.s;\r\n\r\n  // x is \u00B1Infinity or y is \u00B10\r\n  } else if (!x.d || y.isZero()) {\r\n    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\r\n    r.s = y.s;\r\n\r\n  // y is \u00B1Infinity or x is \u00B10\r\n  } else if (!y.d || x.isZero()) {\r\n    r = getPi(this, wpr, 1).times(0.5);\r\n    r.s = y.s;\r\n\r\n  // Both non-zero and finite\r\n  } else if (x.s < 0) {\r\n    this.precision = wpr;\r\n    this.rounding = 1;\r\n    r = this.atan(divide(y, x, wpr, 1));\r\n    x = getPi(this, wpr, 1);\r\n    this.precision = pr;\r\n    this.rounding = rm;\r\n    r = y.s < 0 ? r.minus(x) : r.plus(x);\r\n  } else {\r\n    r = this.atan(divide(y, x, wpr, 1));\r\n  }\r\n\r\n  return r;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction cbrt(x) {\r\n  return new this(x).cbrt();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction ceil(x) {\r\n  return finalise(x = new this(x), x.e + 1, 2);\r\n}\r\n\r\n\r\n/*\r\n * Configure global settings for a Decimal constructor.\r\n *\r\n * `obj` is an object with one or more of the following properties,\r\n *\r\n *   precision  {number}\r\n *   rounding   {number}\r\n *   toExpNeg   {number}\r\n *   toExpPos   {number}\r\n *   maxE       {number}\r\n *   minE       {number}\r\n *   modulo     {number}\r\n *   crypto     {boolean|number}\r\n *   defaults   {true}\r\n *\r\n * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n *\r\n */\r\nfunction config(obj) {\r\n  if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');\r\n  var i, p, v,\r\n    useDefaults = obj.defaults === true,\r\n    ps = [\r\n      'precision', 1, MAX_DIGITS,\r\n      'rounding', 0, 8,\r\n      'toExpNeg', -EXP_LIMIT, 0,\r\n      'toExpPos', 0, EXP_LIMIT,\r\n      'maxE', 0, EXP_LIMIT,\r\n      'minE', -EXP_LIMIT, 0,\r\n      'modulo', 0, 9\r\n    ];\r\n\r\n  for (i = 0; i < ps.length; i += 3) {\r\n    if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];\r\n    if ((v = obj[p]) !== void 0) {\r\n      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\r\n      else throw Error(invalidArgument + p + ': ' + v);\r\n    }\r\n  }\r\n\r\n  if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];\r\n  if ((v = obj[p]) !== void 0) {\r\n    if (v === true || v === false || v === 0 || v === 1) {\r\n      if (v) {\r\n        if (typeof crypto != 'undefined' && crypto &&\r\n          (crypto.getRandomValues || crypto.randomBytes)) {\r\n          this[p] = true;\r\n        } else {\r\n          throw Error(cryptoUnavailable);\r\n        }\r\n      } else {\r\n        this[p] = false;\r\n      }\r\n    } else {\r\n      throw Error(invalidArgument + p + ': ' + v);\r\n    }\r\n  }\r\n\r\n  return this;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction cos(x) {\r\n  return new this(x).cos();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction cosh(x) {\r\n  return new this(x).cosh();\r\n}\r\n\r\n\r\n/*\r\n * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n * constructor.\r\n *\r\n */\r\nfunction clone(obj) {\r\n  var i, p, ps;\r\n\r\n  /*\r\n   * The Decimal constructor and exported function.\r\n   * Return a new Decimal instance.\r\n   *\r\n   * v {number|string|Decimal} A numeric value.\r\n   *\r\n   */\r\n  function Decimal(v) {\r\n    var e, i, t,\r\n      x = this;\r\n\r\n    // Decimal called without new.\r\n    if (!(x instanceof Decimal)) return new Decimal(v);\r\n\r\n    // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\r\n    // which points to Object.\r\n    x.constructor = Decimal;\r\n\r\n    // Duplicate.\r\n    if (v instanceof Decimal) {\r\n      x.s = v.s;\r\n\r\n      if (external) {\r\n        if (!v.d || v.e > Decimal.maxE) {\r\n\r\n          // Infinity.\r\n          x.e = NaN;\r\n          x.d = null;\r\n        } else if (v.e < Decimal.minE) {\r\n\r\n          // Zero.\r\n          x.e = 0;\r\n          x.d = [0];\r\n        } else {\r\n          x.e = v.e;\r\n          x.d = v.d.slice();\r\n        }\r\n      } else {\r\n        x.e = v.e;\r\n        x.d = v.d ? v.d.slice() : v.d;\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    t = typeof v;\r\n\r\n    if (t === 'number') {\r\n      if (v === 0) {\r\n        x.s = 1 / v < 0 ? -1 : 1;\r\n        x.e = 0;\r\n        x.d = [0];\r\n        return;\r\n      }\r\n\r\n      if (v < 0) {\r\n        v = -v;\r\n        x.s = -1;\r\n      } else {\r\n        x.s = 1;\r\n      }\r\n\r\n      // Fast path for small integers.\r\n      if (v === ~~v && v < 1e7) {\r\n        for (e = 0, i = v; i >= 10; i /= 10) e++;\r\n\r\n        if (external) {\r\n          if (e > Decimal.maxE) {\r\n            x.e = NaN;\r\n            x.d = null;\r\n          } else if (e < Decimal.minE) {\r\n            x.e = 0;\r\n            x.d = [0];\r\n          } else {\r\n            x.e = e;\r\n            x.d = [v];\r\n          }\r\n        } else {\r\n          x.e = e;\r\n          x.d = [v];\r\n        }\r\n\r\n        return;\r\n\r\n      // Infinity, NaN.\r\n      } else if (v * 0 !== 0) {\r\n        if (!v) x.s = NaN;\r\n        x.e = NaN;\r\n        x.d = null;\r\n        return;\r\n      }\r\n\r\n      return parseDecimal(x, v.toString());\r\n\r\n    } else if (t !== 'string') {\r\n      throw Error(invalidArgument + v);\r\n    }\r\n\r\n    // Minus sign?\r\n    if ((i = v.charCodeAt(0)) === 45) {\r\n      v = v.slice(1);\r\n      x.s = -1;\r\n    } else {\r\n      // Plus sign?\r\n      if (i === 43) v = v.slice(1);\r\n      x.s = 1;\r\n    }\r\n\r\n    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\r\n  }\r\n\r\n  Decimal.prototype = P;\r\n\r\n  Decimal.ROUND_UP = 0;\r\n  Decimal.ROUND_DOWN = 1;\r\n  Decimal.ROUND_CEIL = 2;\r\n  Decimal.ROUND_FLOOR = 3;\r\n  Decimal.ROUND_HALF_UP = 4;\r\n  Decimal.ROUND_HALF_DOWN = 5;\r\n  Decimal.ROUND_HALF_EVEN = 6;\r\n  Decimal.ROUND_HALF_CEIL = 7;\r\n  Decimal.ROUND_HALF_FLOOR = 8;\r\n  Decimal.EUCLID = 9;\r\n\r\n  Decimal.config = Decimal.set = config;\r\n  Decimal.clone = clone;\r\n  Decimal.isDecimal = isDecimalInstance;\r\n\r\n  Decimal.abs = abs;\r\n  Decimal.acos = acos;\r\n  Decimal.acosh = acosh;        // ES6\r\n  Decimal.add = add;\r\n  Decimal.asin = asin;\r\n  Decimal.asinh = asinh;        // ES6\r\n  Decimal.atan = atan;\r\n  Decimal.atanh = atanh;        // ES6\r\n  Decimal.atan2 = atan2;\r\n  Decimal.cbrt = cbrt;          // ES6\r\n  Decimal.ceil = ceil;\r\n  Decimal.cos = cos;\r\n  Decimal.cosh = cosh;          // ES6\r\n  Decimal.div = div;\r\n  Decimal.exp = exp;\r\n  Decimal.floor = floor;\r\n  Decimal.hypot = hypot;        // ES6\r\n  Decimal.ln = ln;\r\n  Decimal.log = log;\r\n  Decimal.log10 = log10;        // ES6\r\n  Decimal.log2 = log2;          // ES6\r\n  Decimal.max = max;\r\n  Decimal.min = min;\r\n  Decimal.mod = mod;\r\n  Decimal.mul = mul;\r\n  Decimal.pow = pow;\r\n  Decimal.random = random;\r\n  Decimal.round = round;\r\n  Decimal.sign = sign;          // ES6\r\n  Decimal.sin = sin;\r\n  Decimal.sinh = sinh;          // ES6\r\n  Decimal.sqrt = sqrt;\r\n  Decimal.sub = sub;\r\n  Decimal.tan = tan;\r\n  Decimal.tanh = tanh;          // ES6\r\n  Decimal.trunc = trunc;        // ES6\r\n\r\n  if (obj === void 0) obj = {};\r\n  if (obj) {\r\n    if (obj.defaults !== true) {\r\n      ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];\r\n      for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\r\n    }\r\n  }\r\n\r\n  Decimal.config(obj);\r\n\r\n  return Decimal;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */\r\nfunction div(x, y) {\r\n  return new this(x).div(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} The power to which to raise the base of the natural log.\r\n *\r\n */\r\nfunction exp(x) {\r\n  return new this(x).exp();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction floor(x) {\r\n  return finalise(x = new this(x), x.e + 1, 3);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n * rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */\r\nfunction hypot() {\r\n  var i, n,\r\n    t = new this(0);\r\n\r\n  external = false;\r\n\r\n  for (i = 0; i < arguments.length;) {\r\n    n = new this(arguments[i++]);\r\n    if (!n.d) {\r\n      if (n.s) {\r\n        external = true;\r\n        return new this(1 / 0);\r\n      }\r\n      t = n;\r\n    } else if (t.d) {\r\n      t = t.plus(n.times(n));\r\n    }\r\n  }\r\n\r\n  external = true;\r\n\r\n  return t.sqrt();\r\n}\r\n\r\n\r\n/*\r\n * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),\r\n * otherwise return false.\r\n *\r\n */\r\nfunction isDecimalInstance(obj) {\r\n  return obj instanceof Decimal || obj && obj.name === '[object Decimal]' || false;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction ln(x) {\r\n  return new this(x).ln();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * log[y](x)\r\n *\r\n * x {number|string|Decimal} The argument of the logarithm.\r\n * y {number|string|Decimal} The base of the logarithm.\r\n *\r\n */\r\nfunction log(x, y) {\r\n  return new this(x).log(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction log2(x) {\r\n  return new this(x).log(2);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction log10(x) {\r\n  return new this(x).log(10);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the maximum of the arguments.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */\r\nfunction max() {\r\n  return maxOrMin(this, arguments, 'lt');\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the minimum of the arguments.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */\r\nfunction min() {\r\n  return maxOrMin(this, arguments, 'gt');\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */\r\nfunction mod(x, y) {\r\n  return new this(x).mod(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */\r\nfunction mul(x, y) {\r\n  return new this(x).mul(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} The base.\r\n * y {number|string|Decimal} The exponent.\r\n *\r\n */\r\nfunction pow(x, y) {\r\n  return new this(x).pow(y);\r\n}\r\n\r\n\r\n/*\r\n * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n * are produced).\r\n *\r\n * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n *\r\n */\r\nfunction random(sd) {\r\n  var d, e, k, n,\r\n    i = 0,\r\n    r = new this(1),\r\n    rd = [];\r\n\r\n  if (sd === void 0) sd = this.precision;\r\n  else checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n  k = Math.ceil(sd / LOG_BASE);\r\n\r\n  if (!this.crypto) {\r\n    for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;\r\n\r\n  // Browsers supporting crypto.getRandomValues.\r\n  } else if (crypto.getRandomValues) {\r\n    d = crypto.getRandomValues(new Uint32Array(k));\r\n\r\n    for (; i < k;) {\r\n      n = d[i];\r\n\r\n      // 0 <= n < 4294967296\r\n      // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\r\n      if (n >= 4.29e9) {\r\n        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\r\n      } else {\r\n\r\n        // 0 <= n <= 4289999999\r\n        // 0 <= (n % 1e7) <= 9999999\r\n        rd[i++] = n % 1e7;\r\n      }\r\n    }\r\n\r\n  // Node.js supporting crypto.randomBytes.\r\n  } else if (crypto.randomBytes) {\r\n\r\n    // buffer\r\n    d = crypto.randomBytes(k *= 4);\r\n\r\n    for (; i < k;) {\r\n\r\n      // 0 <= n < 2147483648\r\n      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);\r\n\r\n      // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\r\n      if (n >= 2.14e9) {\r\n        crypto.randomBytes(4).copy(d, i);\r\n      } else {\r\n\r\n        // 0 <= n <= 2139999999\r\n        // 0 <= (n % 1e7) <= 9999999\r\n        rd.push(n % 1e7);\r\n        i += 4;\r\n      }\r\n    }\r\n\r\n    i = k / 4;\r\n  } else {\r\n    throw Error(cryptoUnavailable);\r\n  }\r\n\r\n  k = rd[--i];\r\n  sd %= LOG_BASE;\r\n\r\n  // Convert trailing digits to zeros according to sd.\r\n  if (k && sd) {\r\n    n = mathpow(10, LOG_BASE - sd);\r\n    rd[i] = (k / n | 0) * n;\r\n  }\r\n\r\n  // Remove trailing words which are zero.\r\n  for (; rd[i] === 0; i--) rd.pop();\r\n\r\n  // Zero?\r\n  if (i < 0) {\r\n    e = 0;\r\n    rd = [0];\r\n  } else {\r\n    e = -1;\r\n\r\n    // Remove leading words which are zero and adjust exponent accordingly.\r\n    for (; rd[0] === 0; e -= LOG_BASE) rd.shift();\r\n\r\n    // Count the digits of the first word of rd to determine leading zeros.\r\n    for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;\r\n\r\n    // Adjust the exponent for leading zeros of the first word of rd.\r\n    if (k < LOG_BASE) e -= LOG_BASE - k;\r\n  }\r\n\r\n  r.e = e;\r\n  r.d = rd;\r\n\r\n  return r;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n *\r\n * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction round(x) {\r\n  return finalise(x = new this(x), x.e + 1, this.rounding);\r\n}\r\n\r\n\r\n/*\r\n * Return\r\n *   1    if x > 0,\r\n *  -1    if x < 0,\r\n *   0    if x is 0,\r\n *  -0    if x is -0,\r\n *   NaN  otherwise\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction sign(x) {\r\n  x = new this(x);\r\n  return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction sin(x) {\r\n  return new this(x).sin();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction sinh(x) {\r\n  return new this(x).sinh();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction sqrt(x) {\r\n  return new this(x).sqrt();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */\r\nfunction sub(x, y) {\r\n  return new this(x).sub(y);\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction tan(x) {\r\n  return new this(x).tan();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */\r\nfunction tanh(x) {\r\n  return new this(x).tanh();\r\n}\r\n\r\n\r\n/*\r\n * Return a new Decimal whose value is `x` truncated to an integer.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */\r\nfunction trunc(x) {\r\n  return finalise(x = new this(x), x.e + 1, 1);\r\n}\r\n\r\n\r\nP[Symbol.for('nodejs.util.inspect.custom')] = P.toString;\r\nP[Symbol.toStringTag] = 'Decimal';\r\n\r\n// Create and configure initial Decimal constructor.\r\nexport var Decimal = clone(DEFAULTS);\r\n\r\n// Create the internal constants from their string values.\r\nLN10 = new Decimal(LN10);\r\nPI = new Decimal(PI);\r\n\r\nexport default Decimal;\r\n", "import chalk from 'chalk'\nimport indent from 'indent-string'\nimport leven from 'js-levenshtein'\nimport { DMMF } from '../dmmf-types'\nimport Decimal from 'decimal.js'\n\nexport interface Dictionary<T> {\n  [key: string]: T\n}\n\nexport const keyBy: <T>(collection: T[], prop: string) => Dictionary<T> = (\n  collection,\n  prop,\n) => {\n  const acc = {}\n\n  for (const obj of collection) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n  return acc\n}\n\nexport const keyBy2: <T>(\n  collection1: T[],\n  collection2: T[],\n  prop: string,\n) => Dictionary<T> = (collection1, collection2, prop) => {\n  const acc = {}\n\n  for (const obj of collection1) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n\n  for (const obj of collection2) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n  return acc\n}\n\nexport const ScalarTypeTable = {\n  String: true,\n  Int: true,\n  Float: true,\n  Boolean: true,\n  Long: true,\n  DateTime: true,\n  ID: true,\n  UUID: true,\n  Json: true,\n  Bytes: true,\n  Xml: true,\n  Decimal: true\n}\n\nexport function isScalar(str: string): boolean {\n  if (typeof str !== 'string') {\n    return false\n  }\n  return ScalarTypeTable[str] || false\n}\n\nexport const GraphQLScalarToJSTypeTable = {\n  String: 'string',\n  Int: 'number',\n  Float: 'number',\n  Boolean: 'boolean',\n  Long: 'number',\n  DateTime: ['Date', 'string'],\n  ID: 'string',\n  UUID: 'string',\n  Json: 'JsonValue',\n  Bytes: 'Buffer',\n  Xml: 'string',\n  Decimal: 'Decimal'\n}\n\nexport const JSOutputTypeToInputType = {\n  JsonValue: 'InputJsonValue',\n}\n\nexport const JSTypeToGraphQLType = {\n  string: 'String',\n  boolean: 'Boolean',\n  object: 'Json',\n}\n\nexport function stringifyGraphQLType(\n  type: string | DMMF.InputType | DMMF.SchemaEnum,\n) {\n  if (typeof type === 'string') {\n    return type\n  }\n  return type.name\n}\n\nexport function wrapWithList(str: string, isList: boolean) {\n  if (isList) {\n    return `List<${str}>`\n  }\n\n  return str\n}\n\nexport function getGraphQLType(\n  value: any,\n  potentialType?: string | DMMF.SchemaEnum | DMMF.InputType,\n): string {\n  if (value === null) {\n    return 'null'\n  }\n\n  // https://github.com/MikeMcl/decimal.js/blob/master/decimal.js#L4499\n  if (Decimal.isDecimal(value)) {\n    return 'Decimal'\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return 'Bytes'\n  }\n\n  if (potentialType && potentialType.toString() === 'Xml' && typeof value === 'string') {\n    return 'Xml'\n  }\n\n  if (Array.isArray(value)) {\n    let scalarTypes = value.reduce((acc, val) => {\n      const type = getGraphQLType(val, potentialType)\n      if (!acc.includes(type)) {\n        acc.push(type)\n      }\n      return acc\n    }, [])\n\n    // Merge Float and Int together\n    if (scalarTypes.includes('Float') && scalarTypes.includes('Int')) {\n      scalarTypes = ['Float']\n    }\n\n    return `List<${scalarTypes.join(' | ')}>`\n  }\n  const jsType = typeof value\n  if (jsType === 'number') {\n    if (Math.trunc(value) === value) {\n      return 'Int'\n    } else {\n      return 'Float'\n    }\n  }\n  if (Object.prototype.toString.call(value) === '[object Date]') {\n    return 'DateTime'\n  }\n  if (jsType === 'string') {\n    if (\n      /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(\n        value,\n      )\n    ) {\n      return 'UUID'\n    }\n    const date = new Date(value)\n    if (\n      potentialType &&\n      typeof potentialType === 'object' &&\n      (potentialType as DMMF.SchemaEnum).values &&\n      (potentialType as DMMF.SchemaEnum).values.includes(value)\n    ) {\n      return potentialType.name\n    }\n    if (date.toString() === 'Invalid Date') {\n      return 'String'\n    }\n    if (\n      /\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)/.test(\n        value,\n      )\n    ) {\n      return 'DateTime'\n    }\n  }\n  return JSTypeToGraphQLType[jsType]\n}\n\nexport function graphQLToJSType(gql: string) {\n  return GraphQLScalarToJSTypeTable[gql]\n}\n\nexport function getSuggestion(\n  str: string,\n  possibilities: string[],\n): string | null {\n  const bestMatch = possibilities.reduce<{\n    distance: number\n    str: string | null\n  }>(\n    (acc, curr) => {\n      const distance = leven(str, curr)\n      if (distance < acc.distance) {\n        return {\n          distance,\n          str: curr,\n        }\n      }\n\n      return acc\n    },\n    {\n      // heuristic to be not too strict, but allow some big mistakes (<= ~ 5)\n      distance: Math.min(\n        Math.floor(str.length) * 1.1,\n        ...possibilities.map((p) => p.length * 3),\n      ),\n      str: null,\n    },\n  )\n\n  return bestMatch.str\n}\n\nexport function stringifyInputType(\n  input: string | DMMF.InputType | DMMF.SchemaEnum,\n  greenKeys: boolean = false,\n): string {\n  if (typeof input === 'string') {\n    return input\n  }\n  if ((input as DMMF.SchemaEnum).values) {\n    return `enum ${input.name} {\\n${indent(\n      (input as DMMF.SchemaEnum).values.join(', '),\n      2,\n    )}\\n}`\n  } else {\n    const body = indent(\n      (input as DMMF.InputType).fields // TS doesn't discriminate based on existence of fields properly\n        .map((arg) => {\n          const key = `${arg.name}`\n          const str = `${greenKeys ? chalk.green(key) : key}${arg.isRequired ? '' : '?'\n            }: ${chalk.white(\n              arg.inputTypes\n                .map((argType) => {\n                  return wrapWithList(argIsInputType(argType.type)\n                    ? argType.type.name\n                    :\n                    stringifyGraphQLType(argType.type),\n                    argType.isList,\n                  )\n                }\n                )\n                .join(' | '),\n            )}`\n          if (!arg.isRequired) {\n            return chalk.dim(str)\n          }\n\n          return str\n        })\n        .join('\\n'),\n      2,\n    )\n    return `${chalk.dim('type')} ${chalk.bold.dim(input.name)} ${chalk.dim(\n      '{',\n    )}\\n${body}\\n${chalk.dim('}')}`\n  }\n}\n\nfunction argIsInputType(arg: DMMF.ArgType): arg is DMMF.InputType {\n  if (typeof arg === 'string') {\n    return false\n  }\n\n  return true\n}\n\nexport function getInputTypeName(\n  input: string | DMMF.InputType | DMMF.SchemaField | DMMF.SchemaEnum,\n) {\n  if (typeof input === 'string') {\n    if (input === 'Null') {\n      return 'null'\n    }\n    return input\n  }\n\n  return input.name\n}\n\nexport function getOutputTypeName(\n  input: string | DMMF.OutputType | DMMF.SchemaField | DMMF.SchemaEnum,\n) {\n  if (typeof input === 'string') {\n    return input\n  }\n\n  return input.name\n}\n\nexport function inputTypeToJson(\n  input: string | DMMF.InputType | DMMF.SchemaEnum,\n  isRequired: boolean,\n  nameOnly: boolean = false,\n): string | object {\n  if (typeof input === 'string') {\n    if (input === 'Null') {\n      return 'null'\n    }\n    return input\n  }\n\n  if ((input as DMMF.SchemaEnum).values) {\n    return (input as DMMF.SchemaEnum).values.join(' | ')\n  }\n\n  // TS \"Trick\" :/\n  const inputType: DMMF.InputType = input as DMMF.InputType\n\n\n  // If the parent type is required and all fields are non-scalars,\n  // it's very useful to show to the user, which options they actually have\n  const showDeepType =\n    isRequired &&\n    inputType.fields.every((arg) => arg.inputTypes[0].kind === 'object' || arg.inputTypes[1]?.kind === 'object')\n\n  if (nameOnly) {\n    return getInputTypeName(input)\n  }\n\n  return inputType.fields.reduce((acc, curr) => {\n    let str = ''\n\n    if (!showDeepType && !curr.isRequired) {\n      str = curr.inputTypes.map(argType => getInputTypeName(argType.type)).join(' | ')\n    } else {\n      str = curr.inputTypes.map(argInputType => inputTypeToJson(argInputType.type, curr.isRequired, true)).join(' | ')\n    }\n\n    acc[curr.name + (curr.isRequired ? '' : '?')] = str\n    return acc\n  }, {})\n}\n\nexport function destroyCircular(from, seen: any[] = []) {\n  const to: any = Array.isArray(from) ? [] : {}\n\n  seen.push(from)\n\n  for (const key of Object.keys(from)) {\n    const value = from[key]\n\n    if (typeof value === 'function') {\n      continue\n    }\n\n    if (!value || typeof value !== 'object') {\n      to[key] = value\n      continue\n    }\n\n    if (seen.indexOf(from[key]) === -1) {\n      to[key] = destroyCircular(from[key], seen.slice(0))\n      continue\n    }\n\n    to[key] = '[Circular]'\n  }\n\n  if (typeof from.name === 'string') {\n    to.name = from.name\n  }\n\n  if (typeof from.message === 'string') {\n    to.message = from.message\n  }\n\n  if (typeof from.stack === 'string') {\n    to.stack = from.stack\n  }\n\n  return to\n}\n\nexport function unionBy<T>(\n  arr1: T[],\n  arr2: T[],\n  iteratee: (element: T) => string | number,\n): T[] {\n  const map = {}\n\n  for (const element of arr1) {\n    map[iteratee(element)] = element\n  }\n\n  for (const element of arr2) {\n    const key = iteratee(element)\n    if (!map[key]) {\n      map[key] = element\n    }\n  }\n\n  return Object.values(map)\n}\n\nexport function uniqBy<T>(\n  arr: T[],\n  iteratee: (element: T) => string | number,\n): T[] {\n  const map = {}\n\n  for (const element of arr) {\n    map[iteratee(element)] = element\n  }\n\n  return Object.values(map)\n}\n\nexport function capitalize(str: string): string {\n  return str[0].toUpperCase() + str.slice(1)\n}\n\n/**\n * Converts the first character of a word to lower case\n * @param name\n */\nexport function lowerCase(name: string): string {\n  return name.substring(0, 1).toLowerCase() + name.substring(1)\n}\n", "import chalk from 'chalk'\nimport indent from 'indent-string'\nimport leven from 'js-levenshtein'\nimport { DMMF } from '../dmmf-types'\nimport Decimal from 'decimal.js'\n\nexport interface Dictionary<T> {\n  [key: string]: T\n}\n\nexport const keyBy: <T>(collection: T[], prop: string) => Dictionary<T> = (\n  collection,\n  prop,\n) => {\n  const acc = {}\n\n  for (const obj of collection) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n  return acc\n}\n\nexport const keyBy2: <T>(\n  collection1: T[],\n  collection2: T[],\n  prop: string,\n) => Dictionary<T> = (collection1, collection2, prop) => {\n  const acc = {}\n\n  for (const obj of collection1) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n\n  for (const obj of collection2) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n  return acc\n}\n\nexport const ScalarTypeTable = {\n  String: true,\n  Int: true,\n  Float: true,\n  Boolean: true,\n  Long: true,\n  DateTime: true,\n  ID: true,\n  UUID: true,\n  Json: true,\n  Bytes: true,\n  Xml: true,\n  Decimal: true\n}\n\nexport function isScalar(str: string): boolean {\n  if (typeof str !== 'string') {\n    return false\n  }\n  return ScalarTypeTable[str] || false\n}\n\nexport const GraphQLScalarToJSTypeTable = {\n  String: 'string',\n  Int: 'number',\n  Float: 'number',\n  Boolean: 'boolean',\n  Long: 'number',\n  DateTime: ['Date', 'string'],\n  ID: 'string',\n  UUID: 'string',\n  Json: 'JsonValue',\n  Bytes: 'Buffer',\n  Xml: 'string',\n  Decimal: 'Decimal'\n}\n\nexport const JSOutputTypeToInputType = {\n  JsonValue: 'InputJsonValue',\n}\n\nexport const JSTypeToGraphQLType = {\n  string: 'String',\n  boolean: 'Boolean',\n  object: 'Json',\n}\n\nexport function stringifyGraphQLType(\n  type: string | DMMF.InputType | DMMF.SchemaEnum,\n) {\n  if (typeof type === 'string') {\n    return type\n  }\n  return type.name\n}\n\nexport function wrapWithList(str: string, isList: boolean) {\n  if (isList) {\n    return `List<${str}>`\n  }\n\n  return str\n}\n\nexport function getGraphQLType(\n  value: any,\n  potentialType?: string | DMMF.SchemaEnum | DMMF.InputType,\n): string {\n  if (value === null) {\n    return 'null'\n  }\n\n  // https://github.com/MikeMcl/decimal.js/blob/master/decimal.js#L4499\n  if (Decimal.isDecimal(value)) {\n    return 'Decimal'\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return 'Bytes'\n  }\n\n  if (potentialType && potentialType.toString() === 'Xml' && typeof value === 'string') {\n    return 'Xml'\n  }\n\n  if (Array.isArray(value)) {\n    let scalarTypes = value.reduce((acc, val) => {\n      const type = getGraphQLType(val, potentialType)\n      if (!acc.includes(type)) {\n        acc.push(type)\n      }\n      return acc\n    }, [])\n\n    // Merge Float and Int together\n    if (scalarTypes.includes('Float') && scalarTypes.includes('Int')) {\n      scalarTypes = ['Float']\n    }\n\n    return `List<${scalarTypes.join(' | ')}>`\n  }\n  const jsType = typeof value\n  if (jsType === 'number') {\n    if (Math.trunc(value) === value) {\n      return 'Int'\n    } else {\n      return 'Float'\n    }\n  }\n  if (Object.prototype.toString.call(value) === '[object Date]') {\n    return 'DateTime'\n  }\n  if (jsType === 'string') {\n    if (\n      /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(\n        value,\n      )\n    ) {\n      return 'UUID'\n    }\n    const date = new Date(value)\n    if (\n      potentialType &&\n      typeof potentialType === 'object' &&\n      (potentialType as DMMF.SchemaEnum).values &&\n      (potentialType as DMMF.SchemaEnum).values.includes(value)\n    ) {\n      return potentialType.name\n    }\n    if (date.toString() === 'Invalid Date') {\n      return 'String'\n    }\n    if (\n      /\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)/.test(\n        value,\n      )\n    ) {\n      return 'DateTime'\n    }\n  }\n  return JSTypeToGraphQLType[jsType]\n}\n\nexport function graphQLToJSType(gql: string) {\n  return GraphQLScalarToJSTypeTable[gql]\n}\n\nexport function getSuggestion(\n  str: string,\n  possibilities: string[],\n): string | null {\n  const bestMatch = possibilities.reduce<{\n    distance: number\n    str: string | null\n  }>(\n    (acc, curr) => {\n      const distance = leven(str, curr)\n      if (distance < acc.distance) {\n        return {\n          distance,\n          str: curr,\n        }\n      }\n\n      return acc\n    },\n    {\n      // heuristic to be not too strict, but allow some big mistakes (<= ~ 5)\n      distance: Math.min(\n        Math.floor(str.length) * 1.1,\n        ...possibilities.map((p) => p.length * 3),\n      ),\n      str: null,\n    },\n  )\n\n  return bestMatch.str\n}\n\nexport function stringifyInputType(\n  input: string | DMMF.InputType | DMMF.SchemaEnum,\n  greenKeys: boolean = false,\n): string {\n  if (typeof input === 'string') {\n    return input\n  }\n  if ((input as DMMF.SchemaEnum).values) {\n    return `enum ${input.name} {\\n${indent(\n      (input as DMMF.SchemaEnum).values.join(', '),\n      2,\n    )}\\n}`\n  } else {\n    const body = indent(\n      (input as DMMF.InputType).fields // TS doesn't discriminate based on existence of fields properly\n        .map((arg) => {\n          const key = `${arg.name}`\n          const str = `${greenKeys ? chalk.green(key) : key}${arg.isRequired ? '' : '?'\n            }: ${chalk.white(\n              arg.inputTypes\n                .map((argType) => {\n                  return wrapWithList(argIsInputType(argType.type)\n                    ? argType.type.name\n                    :\n                    stringifyGraphQLType(argType.type),\n                    argType.isList,\n                  )\n                }\n                )\n                .join(' | '),\n            )}`\n          if (!arg.isRequired) {\n            return chalk.dim(str)\n          }\n\n          return str\n        })\n        .join('\\n'),\n      2,\n    )\n    return `${chalk.dim('type')} ${chalk.bold.dim(input.name)} ${chalk.dim(\n      '{',\n    )}\\n${body}\\n${chalk.dim('}')}`\n  }\n}\n\nfunction argIsInputType(arg: DMMF.ArgType): arg is DMMF.InputType {\n  if (typeof arg === 'string') {\n    return false\n  }\n\n  return true\n}\n\nexport function getInputTypeName(\n  input: string | DMMF.InputType | DMMF.SchemaField | DMMF.SchemaEnum,\n) {\n  if (typeof input === 'string') {\n    if (input === 'Null') {\n      return 'null'\n    }\n    return input\n  }\n\n  return input.name\n}\n\nexport function getOutputTypeName(\n  input: string | DMMF.OutputType | DMMF.SchemaField | DMMF.SchemaEnum,\n) {\n  if (typeof input === 'string') {\n    return input\n  }\n\n  return input.name\n}\n\nexport function inputTypeToJson(\n  input: string | DMMF.InputType | DMMF.SchemaEnum,\n  isRequired: boolean,\n  nameOnly: boolean = false,\n): string | object {\n  if (typeof input === 'string') {\n    if (input === 'Null') {\n      return 'null'\n    }\n    return input\n  }\n\n  if ((input as DMMF.SchemaEnum).values) {\n    return (input as DMMF.SchemaEnum).values.join(' | ')\n  }\n\n  // TS \"Trick\" :/\n  const inputType: DMMF.InputType = input as DMMF.InputType\n\n\n  // If the parent type is required and all fields are non-scalars,\n  // it's very useful to show to the user, which options they actually have\n  const showDeepType =\n    isRequired &&\n    inputType.fields.every((arg) => arg.inputTypes[0].kind === 'object' || arg.inputTypes[1]?.kind === 'object')\n\n  if (nameOnly) {\n    return getInputTypeName(input)\n  }\n\n  return inputType.fields.reduce((acc, curr) => {\n    let str = ''\n\n    if (!showDeepType && !curr.isRequired) {\n      str = curr.inputTypes.map(argType => getInputTypeName(argType.type)).join(' | ')\n    } else {\n      str = curr.inputTypes.map(argInputType => inputTypeToJson(argInputType.type, curr.isRequired, true)).join(' | ')\n    }\n\n    acc[curr.name + (curr.isRequired ? '' : '?')] = str\n    return acc\n  }, {})\n}\n\nexport function destroyCircular(from, seen: any[] = []) {\n  const to: any = Array.isArray(from) ? [] : {}\n\n  seen.push(from)\n\n  for (const key of Object.keys(from)) {\n    const value = from[key]\n\n    if (typeof value === 'function') {\n      continue\n    }\n\n    if (!value || typeof value !== 'object') {\n      to[key] = value\n      continue\n    }\n\n    if (seen.indexOf(from[key]) === -1) {\n      to[key] = destroyCircular(from[key], seen.slice(0))\n      continue\n    }\n\n    to[key] = '[Circular]'\n  }\n\n  if (typeof from.name === 'string') {\n    to.name = from.name\n  }\n\n  if (typeof from.message === 'string') {\n    to.message = from.message\n  }\n\n  if (typeof from.stack === 'string') {\n    to.stack = from.stack\n  }\n\n  return to\n}\n\nexport function unionBy<T>(\n  arr1: T[],\n  arr2: T[],\n  iteratee: (element: T) => string | number,\n): T[] {\n  const map = {}\n\n  for (const element of arr1) {\n    map[iteratee(element)] = element\n  }\n\n  for (const element of arr2) {\n    const key = iteratee(element)\n    if (!map[key]) {\n      map[key] = element\n    }\n  }\n\n  return Object.values(map)\n}\n\nexport function uniqBy<T>(\n  arr: T[],\n  iteratee: (element: T) => string | number,\n): T[] {\n  const map = {}\n\n  for (const element of arr) {\n    map[iteratee(element)] = element\n  }\n\n  return Object.values(map)\n}\n\nexport function capitalize(str: string): string {\n  return str[0].toUpperCase() + str.slice(1)\n}\n\n/**\n * Converts the first character of a word to lower case\n * @param name\n */\nexport function lowerCase(name: string): string {\n  return name.substring(0, 1).toLowerCase() + name.substring(1)\n}\n", "import chalk from 'chalk'\nimport indent from 'indent-string'\nimport leven from 'js-levenshtein'\nimport { DMMF } from '../dmmf-types'\nimport Decimal from 'decimal.js'\n\nexport interface Dictionary<T> {\n  [key: string]: T\n}\n\nexport const keyBy: <T>(collection: T[], prop: string) => Dictionary<T> = (\n  collection,\n  prop,\n) => {\n  const acc = {}\n\n  for (const obj of collection) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n  return acc\n}\n\nexport const keyBy2: <T>(\n  collection1: T[],\n  collection2: T[],\n  prop: string,\n) => Dictionary<T> = (collection1, collection2, prop) => {\n  const acc = {}\n\n  for (const obj of collection1) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n\n  for (const obj of collection2) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n  return acc\n}\n\nexport const ScalarTypeTable = {\n  String: true,\n  Int: true,\n  Float: true,\n  Boolean: true,\n  Long: true,\n  DateTime: true,\n  ID: true,\n  UUID: true,\n  Json: true,\n  Bytes: true,\n  Xml: true,\n  Decimal: true\n}\n\nexport function isScalar(str: string): boolean {\n  if (typeof str !== 'string') {\n    return false\n  }\n  return ScalarTypeTable[str] || false\n}\n\nexport const GraphQLScalarToJSTypeTable = {\n  String: 'string',\n  Int: 'number',\n  Float: 'number',\n  Boolean: 'boolean',\n  Long: 'number',\n  DateTime: ['Date', 'string'],\n  ID: 'string',\n  UUID: 'string',\n  Json: 'JsonValue',\n  Bytes: 'Buffer',\n  Xml: 'string',\n  Decimal: 'Decimal'\n}\n\nexport const JSOutputTypeToInputType = {\n  JsonValue: 'InputJsonValue',\n}\n\nexport const JSTypeToGraphQLType = {\n  string: 'String',\n  boolean: 'Boolean',\n  object: 'Json',\n}\n\nexport function stringifyGraphQLType(\n  type: string | DMMF.InputType | DMMF.SchemaEnum,\n) {\n  if (typeof type === 'string') {\n    return type\n  }\n  return type.name\n}\n\nexport function wrapWithList(str: string, isList: boolean) {\n  if (isList) {\n    return `List<${str}>`\n  }\n\n  return str\n}\n\nexport function getGraphQLType(\n  value: any,\n  potentialType?: string | DMMF.SchemaEnum | DMMF.InputType,\n): string {\n  if (value === null) {\n    return 'null'\n  }\n\n  // https://github.com/MikeMcl/decimal.js/blob/master/decimal.js#L4499\n  if (Decimal.isDecimal(value)) {\n    return 'Decimal'\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return 'Bytes'\n  }\n\n  if (potentialType && potentialType.toString() === 'Xml' && typeof value === 'string') {\n    return 'Xml'\n  }\n\n  if (Array.isArray(value)) {\n    let scalarTypes = value.reduce((acc, val) => {\n      const type = getGraphQLType(val, potentialType)\n      if (!acc.includes(type)) {\n        acc.push(type)\n      }\n      return acc\n    }, [])\n\n    // Merge Float and Int together\n    if (scalarTypes.includes('Float') && scalarTypes.includes('Int')) {\n      scalarTypes = ['Float']\n    }\n\n    return `List<${scalarTypes.join(' | ')}>`\n  }\n  const jsType = typeof value\n  if (jsType === 'number') {\n    if (Math.trunc(value) === value) {\n      return 'Int'\n    } else {\n      return 'Float'\n    }\n  }\n  if (Object.prototype.toString.call(value) === '[object Date]') {\n    return 'DateTime'\n  }\n  if (jsType === 'string') {\n    if (\n      /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(\n        value,\n      )\n    ) {\n      return 'UUID'\n    }\n    const date = new Date(value)\n    if (\n      potentialType &&\n      typeof potentialType === 'object' &&\n      (potentialType as DMMF.SchemaEnum).values &&\n      (potentialType as DMMF.SchemaEnum).values.includes(value)\n    ) {\n      return potentialType.name\n    }\n    if (date.toString() === 'Invalid Date') {\n      return 'String'\n    }\n    if (\n      /\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)/.test(\n        value,\n      )\n    ) {\n      return 'DateTime'\n    }\n  }\n  return JSTypeToGraphQLType[jsType]\n}\n\nexport function graphQLToJSType(gql: string) {\n  return GraphQLScalarToJSTypeTable[gql]\n}\n\nexport function getSuggestion(\n  str: string,\n  possibilities: string[],\n): string | null {\n  const bestMatch = possibilities.reduce<{\n    distance: number\n    str: string | null\n  }>(\n    (acc, curr) => {\n      const distance = leven(str, curr)\n      if (distance < acc.distance) {\n        return {\n          distance,\n          str: curr,\n        }\n      }\n\n      return acc\n    },\n    {\n      // heuristic to be not too strict, but allow some big mistakes (<= ~ 5)\n      distance: Math.min(\n        Math.floor(str.length) * 1.1,\n        ...possibilities.map((p) => p.length * 3),\n      ),\n      str: null,\n    },\n  )\n\n  return bestMatch.str\n}\n\nexport function stringifyInputType(\n  input: string | DMMF.InputType | DMMF.SchemaEnum,\n  greenKeys: boolean = false,\n): string {\n  if (typeof input === 'string') {\n    return input\n  }\n  if ((input as DMMF.SchemaEnum).values) {\n    return `enum ${input.name} {\\n${indent(\n      (input as DMMF.SchemaEnum).values.join(', '),\n      2,\n    )}\\n}`\n  } else {\n    const body = indent(\n      (input as DMMF.InputType).fields // TS doesn't discriminate based on existence of fields properly\n        .map((arg) => {\n          const key = `${arg.name}`\n          const str = `${greenKeys ? chalk.green(key) : key}${arg.isRequired ? '' : '?'\n            }: ${chalk.white(\n              arg.inputTypes\n                .map((argType) => {\n                  return wrapWithList(argIsInputType(argType.type)\n                    ? argType.type.name\n                    :\n                    stringifyGraphQLType(argType.type),\n                    argType.isList,\n                  )\n                }\n                )\n                .join(' | '),\n            )}`\n          if (!arg.isRequired) {\n            return chalk.dim(str)\n          }\n\n          return str\n        })\n        .join('\\n'),\n      2,\n    )\n    return `${chalk.dim('type')} ${chalk.bold.dim(input.name)} ${chalk.dim(\n      '{',\n    )}\\n${body}\\n${chalk.dim('}')}`\n  }\n}\n\nfunction argIsInputType(arg: DMMF.ArgType): arg is DMMF.InputType {\n  if (typeof arg === 'string') {\n    return false\n  }\n\n  return true\n}\n\nexport function getInputTypeName(\n  input: string | DMMF.InputType | DMMF.SchemaField | DMMF.SchemaEnum,\n) {\n  if (typeof input === 'string') {\n    if (input === 'Null') {\n      return 'null'\n    }\n    return input\n  }\n\n  return input.name\n}\n\nexport function getOutputTypeName(\n  input: string | DMMF.OutputType | DMMF.SchemaField | DMMF.SchemaEnum,\n) {\n  if (typeof input === 'string') {\n    return input\n  }\n\n  return input.name\n}\n\nexport function inputTypeToJson(\n  input: string | DMMF.InputType | DMMF.SchemaEnum,\n  isRequired: boolean,\n  nameOnly: boolean = false,\n): string | object {\n  if (typeof input === 'string') {\n    if (input === 'Null') {\n      return 'null'\n    }\n    return input\n  }\n\n  if ((input as DMMF.SchemaEnum).values) {\n    return (input as DMMF.SchemaEnum).values.join(' | ')\n  }\n\n  // TS \"Trick\" :/\n  const inputType: DMMF.InputType = input as DMMF.InputType\n\n\n  // If the parent type is required and all fields are non-scalars,\n  // it's very useful to show to the user, which options they actually have\n  const showDeepType =\n    isRequired &&\n    inputType.fields.every((arg) => arg.inputTypes[0].kind === 'object' || arg.inputTypes[1]?.kind === 'object')\n\n  if (nameOnly) {\n    return getInputTypeName(input)\n  }\n\n  return inputType.fields.reduce((acc, curr) => {\n    let str = ''\n\n    if (!showDeepType && !curr.isRequired) {\n      str = curr.inputTypes.map(argType => getInputTypeName(argType.type)).join(' | ')\n    } else {\n      str = curr.inputTypes.map(argInputType => inputTypeToJson(argInputType.type, curr.isRequired, true)).join(' | ')\n    }\n\n    acc[curr.name + (curr.isRequired ? '' : '?')] = str\n    return acc\n  }, {})\n}\n\nexport function destroyCircular(from, seen: any[] = []) {\n  const to: any = Array.isArray(from) ? [] : {}\n\n  seen.push(from)\n\n  for (const key of Object.keys(from)) {\n    const value = from[key]\n\n    if (typeof value === 'function') {\n      continue\n    }\n\n    if (!value || typeof value !== 'object') {\n      to[key] = value\n      continue\n    }\n\n    if (seen.indexOf(from[key]) === -1) {\n      to[key] = destroyCircular(from[key], seen.slice(0))\n      continue\n    }\n\n    to[key] = '[Circular]'\n  }\n\n  if (typeof from.name === 'string') {\n    to.name = from.name\n  }\n\n  if (typeof from.message === 'string') {\n    to.message = from.message\n  }\n\n  if (typeof from.stack === 'string') {\n    to.stack = from.stack\n  }\n\n  return to\n}\n\nexport function unionBy<T>(\n  arr1: T[],\n  arr2: T[],\n  iteratee: (element: T) => string | number,\n): T[] {\n  const map = {}\n\n  for (const element of arr1) {\n    map[iteratee(element)] = element\n  }\n\n  for (const element of arr2) {\n    const key = iteratee(element)\n    if (!map[key]) {\n      map[key] = element\n    }\n  }\n\n  return Object.values(map)\n}\n\nexport function uniqBy<T>(\n  arr: T[],\n  iteratee: (element: T) => string | number,\n): T[] {\n  const map = {}\n\n  for (const element of arr) {\n    map[iteratee(element)] = element\n  }\n\n  return Object.values(map)\n}\n\nexport function capitalize(str: string): string {\n  return str[0].toUpperCase() + str.slice(1)\n}\n\n/**\n * Converts the first character of a word to lower case\n * @param name\n */\nexport function lowerCase(name: string): string {\n  return name.substring(0, 1).toLowerCase() + name.substring(1)\n}\n", "import chalk from 'chalk'\nimport indent from 'indent-string'\nimport leven from 'js-levenshtein'\nimport { DMMF } from '../dmmf-types'\nimport Decimal from 'decimal.js'\n\nexport interface Dictionary<T> {\n  [key: string]: T\n}\n\nexport const keyBy: <T>(collection: T[], prop: string) => Dictionary<T> = (\n  collection,\n  prop,\n) => {\n  const acc = {}\n\n  for (const obj of collection) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n  return acc\n}\n\nexport const keyBy2: <T>(\n  collection1: T[],\n  collection2: T[],\n  prop: string,\n) => Dictionary<T> = (collection1, collection2, prop) => {\n  const acc = {}\n\n  for (const obj of collection1) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n\n  for (const obj of collection2) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n  return acc\n}\n\nexport const ScalarTypeTable = {\n  String: true,\n  Int: true,\n  Float: true,\n  Boolean: true,\n  Long: true,\n  DateTime: true,\n  ID: true,\n  UUID: true,\n  Json: true,\n  Bytes: true,\n  Xml: true,\n  Decimal: true\n}\n\nexport function isScalar(str: string): boolean {\n  if (typeof str !== 'string') {\n    return false\n  }\n  return ScalarTypeTable[str] || false\n}\n\nexport const GraphQLScalarToJSTypeTable = {\n  String: 'string',\n  Int: 'number',\n  Float: 'number',\n  Boolean: 'boolean',\n  Long: 'number',\n  DateTime: ['Date', 'string'],\n  ID: 'string',\n  UUID: 'string',\n  Json: 'JsonValue',\n  Bytes: 'Buffer',\n  Xml: 'string',\n  Decimal: 'Decimal'\n}\n\nexport const JSOutputTypeToInputType = {\n  JsonValue: 'InputJsonValue',\n}\n\nexport const JSTypeToGraphQLType = {\n  string: 'String',\n  boolean: 'Boolean',\n  object: 'Json',\n}\n\nexport function stringifyGraphQLType(\n  type: string | DMMF.InputType | DMMF.SchemaEnum,\n) {\n  if (typeof type === 'string') {\n    return type\n  }\n  return type.name\n}\n\nexport function wrapWithList(str: string, isList: boolean) {\n  if (isList) {\n    return `List<${str}>`\n  }\n\n  return str\n}\n\nexport function getGraphQLType(\n  value: any,\n  potentialType?: string | DMMF.SchemaEnum | DMMF.InputType,\n): string {\n  if (value === null) {\n    return 'null'\n  }\n\n  // https://github.com/MikeMcl/decimal.js/blob/master/decimal.js#L4499\n  if (Decimal.isDecimal(value)) {\n    return 'Decimal'\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return 'Bytes'\n  }\n\n  if (potentialType && potentialType.toString() === 'Xml' && typeof value === 'string') {\n    return 'Xml'\n  }\n\n  if (Array.isArray(value)) {\n    let scalarTypes = value.reduce((acc, val) => {\n      const type = getGraphQLType(val, potentialType)\n      if (!acc.includes(type)) {\n        acc.push(type)\n      }\n      return acc\n    }, [])\n\n    // Merge Float and Int together\n    if (scalarTypes.includes('Float') && scalarTypes.includes('Int')) {\n      scalarTypes = ['Float']\n    }\n\n    return `List<${scalarTypes.join(' | ')}>`\n  }\n  const jsType = typeof value\n  if (jsType === 'number') {\n    if (Math.trunc(value) === value) {\n      return 'Int'\n    } else {\n      return 'Float'\n    }\n  }\n  if (Object.prototype.toString.call(value) === '[object Date]') {\n    return 'DateTime'\n  }\n  if (jsType === 'string') {\n    if (\n      /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(\n        value,\n      )\n    ) {\n      return 'UUID'\n    }\n    const date = new Date(value)\n    if (\n      potentialType &&\n      typeof potentialType === 'object' &&\n      (potentialType as DMMF.SchemaEnum).values &&\n      (potentialType as DMMF.SchemaEnum).values.includes(value)\n    ) {\n      return potentialType.name\n    }\n    if (date.toString() === 'Invalid Date') {\n      return 'String'\n    }\n    if (\n      /\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)/.test(\n        value,\n      )\n    ) {\n      return 'DateTime'\n    }\n  }\n  return JSTypeToGraphQLType[jsType]\n}\n\nexport function graphQLToJSType(gql: string) {\n  return GraphQLScalarToJSTypeTable[gql]\n}\n\nexport function getSuggestion(\n  str: string,\n  possibilities: string[],\n): string | null {\n  const bestMatch = possibilities.reduce<{\n    distance: number\n    str: string | null\n  }>(\n    (acc, curr) => {\n      const distance = leven(str, curr)\n      if (distance < acc.distance) {\n        return {\n          distance,\n          str: curr,\n        }\n      }\n\n      return acc\n    },\n    {\n      // heuristic to be not too strict, but allow some big mistakes (<= ~ 5)\n      distance: Math.min(\n        Math.floor(str.length) * 1.1,\n        ...possibilities.map((p) => p.length * 3),\n      ),\n      str: null,\n    },\n  )\n\n  return bestMatch.str\n}\n\nexport function stringifyInputType(\n  input: string | DMMF.InputType | DMMF.SchemaEnum,\n  greenKeys: boolean = false,\n): string {\n  if (typeof input === 'string') {\n    return input\n  }\n  if ((input as DMMF.SchemaEnum).values) {\n    return `enum ${input.name} {\\n${indent(\n      (input as DMMF.SchemaEnum).values.join(', '),\n      2,\n    )}\\n}`\n  } else {\n    const body = indent(\n      (input as DMMF.InputType).fields // TS doesn't discriminate based on existence of fields properly\n        .map((arg) => {\n          const key = `${arg.name}`\n          const str = `${greenKeys ? chalk.green(key) : key}${arg.isRequired ? '' : '?'\n            }: ${chalk.white(\n              arg.inputTypes\n                .map((argType) => {\n                  return wrapWithList(argIsInputType(argType.type)\n                    ? argType.type.name\n                    :\n                    stringifyGraphQLType(argType.type),\n                    argType.isList,\n                  )\n                }\n                )\n                .join(' | '),\n            )}`\n          if (!arg.isRequired) {\n            return chalk.dim(str)\n          }\n\n          return str\n        })\n        .join('\\n'),\n      2,\n    )\n    return `${chalk.dim('type')} ${chalk.bold.dim(input.name)} ${chalk.dim(\n      '{',\n    )}\\n${body}\\n${chalk.dim('}')}`\n  }\n}\n\nfunction argIsInputType(arg: DMMF.ArgType): arg is DMMF.InputType {\n  if (typeof arg === 'string') {\n    return false\n  }\n\n  return true\n}\n\nexport function getInputTypeName(\n  input: string | DMMF.InputType | DMMF.SchemaField | DMMF.SchemaEnum,\n) {\n  if (typeof input === 'string') {\n    if (input === 'Null') {\n      return 'null'\n    }\n    return input\n  }\n\n  return input.name\n}\n\nexport function getOutputTypeName(\n  input: string | DMMF.OutputType | DMMF.SchemaField | DMMF.SchemaEnum,\n) {\n  if (typeof input === 'string') {\n    return input\n  }\n\n  return input.name\n}\n\nexport function inputTypeToJson(\n  input: string | DMMF.InputType | DMMF.SchemaEnum,\n  isRequired: boolean,\n  nameOnly: boolean = false,\n): string | object {\n  if (typeof input === 'string') {\n    if (input === 'Null') {\n      return 'null'\n    }\n    return input\n  }\n\n  if ((input as DMMF.SchemaEnum).values) {\n    return (input as DMMF.SchemaEnum).values.join(' | ')\n  }\n\n  // TS \"Trick\" :/\n  const inputType: DMMF.InputType = input as DMMF.InputType\n\n\n  // If the parent type is required and all fields are non-scalars,\n  // it's very useful to show to the user, which options they actually have\n  const showDeepType =\n    isRequired &&\n    inputType.fields.every((arg) => arg.inputTypes[0].kind === 'object' || arg.inputTypes[1]?.kind === 'object')\n\n  if (nameOnly) {\n    return getInputTypeName(input)\n  }\n\n  return inputType.fields.reduce((acc, curr) => {\n    let str = ''\n\n    if (!showDeepType && !curr.isRequired) {\n      str = curr.inputTypes.map(argType => getInputTypeName(argType.type)).join(' | ')\n    } else {\n      str = curr.inputTypes.map(argInputType => inputTypeToJson(argInputType.type, curr.isRequired, true)).join(' | ')\n    }\n\n    acc[curr.name + (curr.isRequired ? '' : '?')] = str\n    return acc\n  }, {})\n}\n\nexport function destroyCircular(from, seen: any[] = []) {\n  const to: any = Array.isArray(from) ? [] : {}\n\n  seen.push(from)\n\n  for (const key of Object.keys(from)) {\n    const value = from[key]\n\n    if (typeof value === 'function') {\n      continue\n    }\n\n    if (!value || typeof value !== 'object') {\n      to[key] = value\n      continue\n    }\n\n    if (seen.indexOf(from[key]) === -1) {\n      to[key] = destroyCircular(from[key], seen.slice(0))\n      continue\n    }\n\n    to[key] = '[Circular]'\n  }\n\n  if (typeof from.name === 'string') {\n    to.name = from.name\n  }\n\n  if (typeof from.message === 'string') {\n    to.message = from.message\n  }\n\n  if (typeof from.stack === 'string') {\n    to.stack = from.stack\n  }\n\n  return to\n}\n\nexport function unionBy<T>(\n  arr1: T[],\n  arr2: T[],\n  iteratee: (element: T) => string | number,\n): T[] {\n  const map = {}\n\n  for (const element of arr1) {\n    map[iteratee(element)] = element\n  }\n\n  for (const element of arr2) {\n    const key = iteratee(element)\n    if (!map[key]) {\n      map[key] = element\n    }\n  }\n\n  return Object.values(map)\n}\n\nexport function uniqBy<T>(\n  arr: T[],\n  iteratee: (element: T) => string | number,\n): T[] {\n  const map = {}\n\n  for (const element of arr) {\n    map[iteratee(element)] = element\n  }\n\n  return Object.values(map)\n}\n\nexport function capitalize(str: string): string {\n  return str[0].toUpperCase() + str.slice(1)\n}\n\n/**\n * Converts the first character of a word to lower case\n * @param name\n */\nexport function lowerCase(name: string): string {\n  return name.substring(0, 1).toLowerCase() + name.substring(1)\n}\n", "import chalk from 'chalk'\nimport indent from 'indent-string'\nimport leven from 'js-levenshtein'\nimport { DMMF } from '../dmmf-types'\nimport Decimal from 'decimal.js'\n\nexport interface Dictionary<T> {\n  [key: string]: T\n}\n\nexport const keyBy: <T>(collection: T[], prop: string) => Dictionary<T> = (\n  collection,\n  prop,\n) => {\n  const acc = {}\n\n  for (const obj of collection) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n  return acc\n}\n\nexport const keyBy2: <T>(\n  collection1: T[],\n  collection2: T[],\n  prop: string,\n) => Dictionary<T> = (collection1, collection2, prop) => {\n  const acc = {}\n\n  for (const obj of collection1) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n\n  for (const obj of collection2) {\n    const key = obj[prop]\n    acc[key] = obj\n  }\n  return acc\n}\n\nexport const ScalarTypeTable = {\n  String: true,\n  Int: true,\n  Float: true,\n  Boolean: true,\n  Long: true,\n  DateTime: true,\n  ID: true,\n  UUID: true,\n  Json: true,\n  Bytes: true,\n  Xml: true,\n  Decimal: true\n}\n\nexport function isScalar(str: string): boolean {\n  if (typeof str !== 'string') {\n    return false\n  }\n  return ScalarTypeTable[str] || false\n}\n\nexport const GraphQLScalarToJSTypeTable = {\n  String: 'string',\n  Int: 'number',\n  Float: 'number',\n  Boolean: 'boolean',\n  Long: 'number',\n  DateTime: ['Date', 'string'],\n  ID: 'string',\n  UUID: 'string',\n  Json: 'JsonValue',\n  Bytes: 'Buffer',\n  Xml: 'string',\n  Decimal: 'Decimal'\n}\n\nexport const JSOutputTypeToInputType = {\n  JsonValue: 'InputJsonValue',\n}\n\nexport const JSTypeToGraphQLType = {\n  string: 'String',\n  boolean: 'Boolean',\n  object: 'Json',\n}\n\nexport function stringifyGraphQLType(\n  type: string | DMMF.InputType | DMMF.SchemaEnum,\n) {\n  if (typeof type === 'string') {\n    return type\n  }\n  return type.name\n}\n\nexport function wrapWithList(str: string, isList: boolean) {\n  if (isList) {\n    return `List<${str}>`\n  }\n\n  return str\n}\n\nexport function getGraphQLType(\n  value: any,\n  potentialType?: string | DMMF.SchemaEnum | DMMF.InputType,\n): string {\n  if (value === null) {\n    return 'null'\n  }\n\n  // https://github.com/MikeMcl/decimal.js/blob/master/decimal.js#L4499\n  if (Decimal.isDecimal(value)) {\n    return 'Decimal'\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return 'Bytes'\n  }\n\n  if (potentialType && potentialType.toString() === 'Xml' && typeof value === 'string') {\n    return 'Xml'\n  }\n\n  if (Array.isArray(value)) {\n    let scalarTypes = value.reduce((acc, val) => {\n      const type = getGraphQLType(val, potentialType)\n      if (!acc.includes(type)) {\n        acc.push(type)\n      }\n      return acc\n    }, [])\n\n    // Merge Float and Int together\n    if (scalarTypes.includes('Float') && scalarTypes.includes('Int')) {\n      scalarTypes = ['Float']\n    }\n\n    return `List<${scalarTypes.join(' | ')}>`\n  }\n  const jsType = typeof value\n  if (jsType === 'number') {\n    if (Math.trunc(value) === value) {\n      return 'Int'\n    } else {\n      return 'Float'\n    }\n  }\n  if (Object.prototype.toString.call(value) === '[object Date]') {\n    return 'DateTime'\n  }\n  if (jsType === 'string') {\n    if (\n      /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(\n        value,\n      )\n    ) {\n      return 'UUID'\n    }\n    const date = new Date(value)\n    if (\n      potentialType &&\n      typeof potentialType === 'object' &&\n      (potentialType as DMMF.SchemaEnum).values &&\n      (potentialType as DMMF.SchemaEnum).values.includes(value)\n    ) {\n      return potentialType.name\n    }\n    if (date.toString() === 'Invalid Date') {\n      return 'String'\n    }\n    if (\n      /\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)/.test(\n        value,\n      )\n    ) {\n      return 'DateTime'\n    }\n  }\n  return JSTypeToGraphQLType[jsType]\n}\n\nexport function graphQLToJSType(gql: string) {\n  return GraphQLScalarToJSTypeTable[gql]\n}\n\nexport function getSuggestion(\n  str: string,\n  possibilities: string[],\n): string | null {\n  const bestMatch = possibilities.reduce<{\n    distance: number\n    str: string | null\n  }>(\n    (acc, curr) => {\n      const distance = leven(str, curr)\n      if (distance < acc.distance) {\n        return {\n          distance,\n          str: curr,\n        }\n      }\n\n      return acc\n    },\n    {\n      // heuristic to be not too strict, but allow some big mistakes (<= ~ 5)\n      distance: Math.min(\n        Math.floor(str.length) * 1.1,\n        ...possibilities.map((p) => p.length * 3),\n      ),\n      str: null,\n    },\n  )\n\n  return bestMatch.str\n}\n\nexport function stringifyInputType(\n  input: string | DMMF.InputType | DMMF.SchemaEnum,\n  greenKeys: boolean = false,\n): string {\n  if (typeof input === 'string') {\n    return input\n  }\n  if ((input as DMMF.SchemaEnum).values) {\n    return `enum ${input.name} {\\n${indent(\n      (input as DMMF.SchemaEnum).values.join(', '),\n      2,\n    )}\\n}`\n  } else {\n    const body = indent(\n      (input as DMMF.InputType).fields // TS doesn't discriminate based on existence of fields properly\n        .map((arg) => {\n          const key = `${arg.name}`\n          const str = `${greenKeys ? chalk.green(key) : key}${arg.isRequired ? '' : '?'\n            }: ${chalk.white(\n              arg.inputTypes\n                .map((argType) => {\n                  return wrapWithList(argIsInputType(argType.type)\n                    ? argType.type.name\n                    :\n                    stringifyGraphQLType(argType.type),\n                    argType.isList,\n                  )\n                }\n                )\n                .join(' | '),\n            )}`\n          if (!arg.isRequired) {\n            return chalk.dim(str)\n          }\n\n          return str\n        })\n        .join('\\n'),\n      2,\n    )\n    return `${chalk.dim('type')} ${chalk.bold.dim(input.name)} ${chalk.dim(\n      '{',\n    )}\\n${body}\\n${chalk.dim('}')}`\n  }\n}\n\nfunction argIsInputType(arg: DMMF.ArgType): arg is DMMF.InputType {\n  if (typeof arg === 'string') {\n    return false\n  }\n\n  return true\n}\n\nexport function getInputTypeName(\n  input: string | DMMF.InputType | DMMF.SchemaField | DMMF.SchemaEnum,\n) {\n  if (typeof input === 'string') {\n    if (input === 'Null') {\n      return 'null'\n    }\n    return input\n  }\n\n  return input.name\n}\n\nexport function getOutputTypeName(\n  input: string | DMMF.OutputType | DMMF.SchemaField | DMMF.SchemaEnum,\n) {\n  if (typeof input === 'string') {\n    return input\n  }\n\n  return input.name\n}\n\nexport function inputTypeToJson(\n  input: string | DMMF.InputType | DMMF.SchemaEnum,\n  isRequired: boolean,\n  nameOnly: boolean = false,\n): string | object {\n  if (typeof input === 'string') {\n    if (input === 'Null') {\n      return 'null'\n    }\n    return input\n  }\n\n  if ((input as DMMF.SchemaEnum).values) {\n    return (input as DMMF.SchemaEnum).values.join(' | ')\n  }\n\n  // TS \"Trick\" :/\n  const inputType: DMMF.InputType = input as DMMF.InputType\n\n\n  // If the parent type is required and all fields are non-scalars,\n  // it's very useful to show to the user, which options they actually have\n  const showDeepType =\n    isRequired &&\n    inputType.fields.every((arg) => arg.inputTypes[0].kind === 'object' || arg.inputTypes[1]?.kind === 'object')\n\n  if (nameOnly) {\n    return getInputTypeName(input)\n  }\n\n  return inputType.fields.reduce((acc, curr) => {\n    let str = ''\n\n    if (!showDeepType && !curr.isRequired) {\n      str = curr.inputTypes.map(argType => getInputTypeName(argType.type)).join(' | ')\n    } else {\n      str = curr.inputTypes.map(argInputType => inputTypeToJson(argInputType.type, curr.isRequired, true)).join(' | ')\n    }\n\n    acc[curr.name + (curr.isRequired ? '' : '?')] = str\n    return acc\n  }, {})\n}\n\nexport function destroyCircular(from, seen: any[] = []) {\n  const to: any = Array.isArray(from) ? [] : {}\n\n  seen.push(from)\n\n  for (const key of Object.keys(from)) {\n    const value = from[key]\n\n    if (typeof value === 'function') {\n      continue\n    }\n\n    if (!value || typeof value !== 'object') {\n      to[key] = value\n      continue\n    }\n\n    if (seen.indexOf(from[key]) === -1) {\n      to[key] = destroyCircular(from[key], seen.slice(0))\n      continue\n    }\n\n    to[key] = '[Circular]'\n  }\n\n  if (typeof from.name === 'string') {\n    to.name = from.name\n  }\n\n  if (typeof from.message === 'string') {\n    to.message = from.message\n  }\n\n  if (typeof from.stack === 'string') {\n    to.stack = from.stack\n  }\n\n  return to\n}\n\nexport function unionBy<T>(\n  arr1: T[],\n  arr2: T[],\n  iteratee: (element: T) => string | number,\n): T[] {\n  const map = {}\n\n  for (const element of arr1) {\n    map[iteratee(element)] = element\n  }\n\n  for (const element of arr2) {\n    const key = iteratee(element)\n    if (!map[key]) {\n      map[key] = element\n    }\n  }\n\n  return Object.values(map)\n}\n\nexport function uniqBy<T>(\n  arr: T[],\n  iteratee: (element: T) => string | number,\n): T[] {\n  const map = {}\n\n  for (const element of arr) {\n    map[iteratee(element)] = element\n  }\n\n  return Object.values(map)\n}\n\nexport function capitalize(str: string): string {\n  return str[0].toUpperCase() + str.slice(1)\n}\n\n/**\n * Converts the first character of a word to lower case\n * @param name\n */\nexport function lowerCase(name: string): string {\n  return name.substring(0, 1).toLowerCase() + name.substring(1)\n}\n", "import { DMMF } from '@prisma/generator-helper'\nimport { Dictionary, keyBy, ScalarTypeTable, keyBy2 } from './utils/common'\n\nexport class DMMFClass implements DMMF.Document {\n  public datamodel: DMMF.Datamodel\n  public schema: DMMF.Schema\n  public mappings: DMMF.Mapping[]\n  public queryType: DMMF.OutputType\n  public mutationType: DMMF.OutputType\n  public outputTypes: DMMF.OutputType[]\n  public outputTypeMap: Dictionary<DMMF.OutputType> = {}\n  public inputTypes: DMMF.InputType[]\n  public inputTypeMap: Dictionary<DMMF.InputType>\n  public enumMap: Dictionary<DMMF.SchemaEnum>\n  public modelMap: Dictionary<DMMF.Model>\n  public mappingsMap: Dictionary<DMMF.Mapping>\n  public rootFieldMap: Dictionary<DMMF.SchemaField>\n  constructor({ datamodel, schema, mappings }: DMMF.Document) {\n    this.datamodel = datamodel\n    this.schema = schema\n    this.mappings = mappings\n    this.enumMap = this.getEnumMap()\n    this.queryType = this.getQueryType()\n    this.mutationType = this.getMutationType()\n    this.modelMap = this.getModelMap()\n\n    this.outputTypes = this.getOutputTypes()\n\n    this.outputTypeMap = this.getMergedOutputTypeMap()\n\n    this.resolveOutputTypes(this.outputTypes)\n\n    this.inputTypes = this.schema.inputTypes\n    this.inputTypeMap = this.getInputTypeMap()\n    this.resolveInputTypes(this.inputTypes)\n    this.resolveFieldArgumentTypes(this.outputTypes, this.inputTypeMap)\n    this.mappingsMap = this.getMappingsMap()\n\n    // needed as references are not kept\n    this.queryType = this.outputTypeMap.Query\n    this.mutationType = this.outputTypeMap.Mutation\n    this.outputTypes = this.outputTypes\n    this.rootFieldMap = this.getRootFieldMap()\n  }\n  protected outputTypeToMergedOutputType = (\n    outputType: DMMF.OutputType,\n  ): DMMF.OutputType => {\n    const model = this.modelMap[outputType.name]\n    return {\n      ...outputType,\n      isEmbedded: model ? model.isEmbedded : false,\n      fields: outputType.fields,\n    }\n  }\n  protected resolveOutputTypes(types: DMMF.OutputType[]) {\n    for (const type of types) {\n      for (const field of type.fields) {\n        if (\n          typeof field.outputType.type === 'string' &&\n          !ScalarTypeTable[field.outputType.type]\n        ) {\n          field.outputType.type =\n            this.outputTypeMap[field.outputType.type] ||\n            this.enumMap[field.outputType.type] ||\n            field.outputType.type\n        }\n      }\n      type.fieldMap = keyBy(type.fields, 'name')\n    }\n  }\n  protected resolveInputTypes(types: DMMF.InputType[]) {\n    for (const type of types) {\n      for (const field of type.fields) {\n        const first = field.inputTypes[0].type\n        if (\n          typeof first === 'string' &&\n          !ScalarTypeTable[first] &&\n          (this.inputTypeMap[first] || this.enumMap[first])\n        ) {\n          field.inputTypes[0].type =\n            this.inputTypeMap[first] ||\n            this.enumMap[first] ||\n            field.inputTypes[0].type\n        }\n        const second = field.inputTypes[1] && field.inputTypes[1].type\n        if (\n          typeof second === 'string' &&\n          !ScalarTypeTable[second] &&\n          (this.inputTypeMap[second] || this.enumMap[second])\n        ) {\n          field.inputTypes[1].type =\n            this.inputTypeMap[second] ||\n            this.enumMap[second] ||\n            field.inputTypes[1].type\n        }\n      }\n      type.fieldMap = keyBy(type.fields, 'name')\n    }\n  }\n  protected resolveFieldArgumentTypes(\n    types: DMMF.OutputType[],\n    inputTypeMap: Dictionary<DMMF.InputType>,\n  ) {\n    for (const type of types) {\n      for (const field of type.fields) {\n        for (const arg of field.args) {\n          const first = arg.inputTypes[0].type\n          if (typeof first === 'string' && !ScalarTypeTable[first]) {\n            arg.inputTypes[0].type =\n              inputTypeMap[first] ||\n              this.enumMap[first] ||\n              arg.inputTypes[0].type\n          }\n          const second = arg.inputTypes[1] && arg.inputTypes[1].type\n          if (\n            second &&\n            typeof second === 'string' &&\n            !ScalarTypeTable[second]\n          ) {\n            arg.inputTypes[1].type =\n              inputTypeMap[second] ||\n              this.enumMap[second] ||\n              arg.inputTypes[1].type\n          }\n        }\n      }\n    }\n  }\n  protected getQueryType(): DMMF.OutputType {\n    return this.schema.outputTypes.find((t) => t.name === 'Query')!\n  }\n  protected getMutationType(): DMMF.OutputType {\n    return this.schema.outputTypes.find((t) => t.name === 'Mutation')!\n  }\n  protected getOutputTypes(): DMMF.OutputType[] {\n    return this.schema.outputTypes.map(this.outputTypeToMergedOutputType)\n  }\n  protected getEnumMap(): Dictionary<DMMF.SchemaEnum> {\n    return keyBy(this.schema.enums, 'name')\n  }\n  protected getModelMap(): Dictionary<DMMF.Model> {\n    return keyBy(this.datamodel.models, 'name')\n  }\n  protected getMergedOutputTypeMap(): Dictionary<DMMF.OutputType> {\n    return keyBy(this.outputTypes, 'name')\n  }\n  protected getInputTypeMap(): Dictionary<DMMF.InputType> {\n    return keyBy(this.schema.inputTypes, 'name')\n  }\n  protected getMappingsMap(): Dictionary<DMMF.Mapping> {\n    return keyBy(this.mappings, 'model')\n  }\n  protected getRootFieldMap(): Dictionary<DMMF.SchemaField> {\n    return keyBy2(this.queryType.fields, this.mutationType.fields, 'name')\n  }\n}\n", "import chalk from 'chalk'\nimport indent from 'indent-string'\nimport { /*dmmf, */ DMMFClass } from './dmmf'\nimport { DMMF } from './dmmf-types'\nimport {\n  ArgError,\n  AtLeastOneError,\n  AtMostOneError,\n  FieldError,\n  InvalidArgError,\n  InvalidFieldError,\n  MissingArgError,\n} from './error-types'\nimport {\n  getGraphQLType,\n  getInputTypeName,\n  getOutputTypeName,\n  getSuggestion,\n  inputTypeToJson,\n  stringifyGraphQLType,\n  stringifyInputType,\n  unionBy,\n  wrapWithList,\n} from './utils/common'\nimport { deepExtend } from './utils/deep-extend'\nimport { deepGet } from './utils/deep-set'\nimport { filterObject } from './utils/filterObject'\nimport { omit } from './utils/omit'\nimport {\n  MissingItem,\n  printJsonWithErrors,\n  PrintJsonWithErrorsArgs,\n} from './utils/printJsonErrors'\nimport { printStack } from './utils/printStack'\nimport stringifyObject from './utils/stringifyObject'\nimport stripAnsi from 'strip-ansi'\nimport { flatMap } from './utils/flatMap'\nimport Decimal from 'decimal.js'\n\nconst tab = 2\n\nexport class Document {\n  constructor(\n    public readonly type: 'query' | 'mutation',\n    public readonly children: Field[],\n  ) {\n    this.type = type\n    this.children = children\n  }\n  public toString() {\n    return `${this.type} {\n${indent(this.children.map(String).join('\\n'), tab)}\n}`\n  }\n  public validate(\n    select?: any,\n    isTopLevelQuery: boolean = false,\n    originalMethod?: string,\n    errorFormat?: 'pretty' | 'minimal' | 'colorless',\n    validationCallsite?: any,\n  ) {\n    if (!select) {\n      select = {}\n    }\n    const invalidChildren = this.children.filter(\n      (child) => child.hasInvalidChild || child.hasInvalidArg,\n    )\n    if (invalidChildren.length === 0) {\n      return\n    }\n\n    const fieldErrors: FieldError[] = []\n    const argErrors: ArgError[] = []\n    const prefix =\n      select && select.select\n        ? 'select'\n        : select.include\n          ? 'include'\n          : undefined\n\n    for (const child of invalidChildren) {\n      const errors = child.collectErrors(prefix)\n      fieldErrors.push(\n        ...errors.fieldErrors.map((e) => ({\n          ...e,\n          path: isTopLevelQuery ? e.path : e.path.slice(1),\n        })),\n      )\n      argErrors.push(\n        ...errors.argErrors.map((e) => ({\n          ...e,\n          path: isTopLevelQuery ? e.path : e.path.slice(1),\n        })),\n      )\n    }\n\n    const topLevelQueryName = this.children[0].name\n    const queryName = isTopLevelQuery ? this.type : topLevelQueryName\n    const keyPaths: string[] = []\n    const valuePaths: string[] = []\n    const missingItems: MissingItem[] = []\n    for (const fieldError of fieldErrors) {\n      const path = this.normalizePath(fieldError.path, select).join('.')\n      if (fieldError.error.type === 'invalidFieldName') {\n        keyPaths.push(path)\n\n        const fieldType = fieldError.error.outputType\n        const { isInclude } = fieldError.error\n        fieldType.fields\n          .filter((field) =>\n            isInclude ? field.outputType.kind === 'object' : true,\n          )\n          .forEach((field) => {\n            const splittedPath = path.split('.')\n            missingItems.push({\n              path: `${splittedPath\n                .slice(0, splittedPath.length - 1)\n                .join('.')}.${field.name}`,\n              type: 'true',\n              isRequired: false,\n            })\n          })\n      } else if (fieldError.error.type === 'includeAndSelect') {\n        keyPaths.push('select')\n        keyPaths.push('include')\n      } else {\n        valuePaths.push(path)\n      }\n      if (\n        fieldError.error.type === 'emptySelect' ||\n        fieldError.error.type === 'noTrueSelect' ||\n        fieldError.error.type === 'emptyInclude'\n      ) {\n        const selectPathArray = this.normalizePath(fieldError.path, select)\n        const selectPath = selectPathArray\n          .slice(0, selectPathArray.length - 1)\n          .join('.')\n\n        const fieldType = fieldError.error.field.outputType\n          .type as DMMF.OutputType\n\n        fieldType.fields\n          .filter((field) =>\n            fieldError.error.type === 'emptyInclude'\n              ? field.outputType.kind === 'object'\n              : true,\n          )\n          .forEach((field) => {\n            missingItems.push({\n              path: `${selectPath}.${field.name}`,\n              type: 'true',\n              isRequired: false,\n            })\n          })\n      }\n    }\n    // an arg error can either be an invalid key or invalid value\n    for (const argError of argErrors) {\n      const path = this.normalizePath(argError.path, select).join('.')\n      if (argError.error.type === 'invalidName') {\n        keyPaths.push(path)\n      } else if (\n        argError.error.type !== 'missingArg' &&\n        argError.error.type !== 'atLeastOne'\n      ) {\n        valuePaths.push(path)\n      } else if (argError.error.type === 'missingArg') {\n        const type =\n          argError.error.missingArg.inputTypes.length === 1\n            ? argError.error.missingArg.inputTypes[0].type\n            : argError.error.missingArg.inputTypes\n              .map((t) => {\n                const inputTypeName = getInputTypeName(t.type)\n                if (inputTypeName === 'Null') {\n                  return 'null'\n                }\n                if (t.isList) {\n                  return inputTypeName + '[]'\n                }\n                return inputTypeName\n              })\n              .join(' | ')\n        missingItems.push({\n          path,\n          type: inputTypeToJson(type, true, path.split('where.').length === 2),\n          isRequired: argError.error.missingArg.isRequired\n        })\n      }\n    }\n\n    const renderErrorStr = (callsite?: string) => {\n      const hasRequiredMissingArgsErrors = argErrors.some(\n        (e) =>\n          e.error.type === 'missingArg' && e.error.missingArg.isRequired,\n      )\n      const hasOptionalMissingArgsErrors = Boolean(argErrors.find(\n        (e) =>\n          e.error.type === 'missingArg' && !e.error.missingArg.isRequired,\n      ))\n      const hasMissingArgsErrors =\n        hasOptionalMissingArgsErrors || hasRequiredMissingArgsErrors\n\n      let missingArgsLegend = ''\n      if (hasRequiredMissingArgsErrors) {\n        missingArgsLegend += `\\n${chalk.dim(\n          'Note: Lines with ',\n        )}${chalk.reset.greenBright('+')} ${chalk.dim('are required')}`\n      }\n\n      if (hasOptionalMissingArgsErrors) {\n        if (missingArgsLegend.length === 0) {\n          missingArgsLegend = '\\n'\n        }\n        if (hasRequiredMissingArgsErrors) {\n          missingArgsLegend += chalk.dim(\n            `, lines with ${chalk.green('?')} are optional`,\n          )\n        } else {\n          missingArgsLegend += chalk.dim(\n            `Note: Lines with ${chalk.green('?')} are optional`,\n          )\n        }\n        missingArgsLegend += chalk.dim('.')\n      }\n\n      const errorMessages = `${argErrors\n        .filter(\n          (e) =>\n            e.error.type !== 'missingArg' || e.error.missingArg.isRequired,\n        )\n        .map((e) =>\n          this.printArgError(\n            e,\n            hasMissingArgsErrors,\n            errorFormat === 'minimal',\n          ),\n        ) // if no callsite is provided, just render the minimal error\n        .join('\\n')}\n${fieldErrors\n          .map((e) => this.printFieldError(e, missingItems, errorFormat === 'minimal'))\n          .join('\\n')}`\n\n      if (errorFormat === 'minimal') {\n        return stripAnsi(errorMessages)\n      }\n\n      const { stack, indent: indentValue, afterLines } = printStack({\n        callsite,\n        originalMethod: originalMethod || queryName,\n        showColors: errorFormat && errorFormat === 'pretty',\n        isValidationError: true,\n      })\n\n      let printJsonArgs: PrintJsonWithErrorsArgs = {\n        ast: isTopLevelQuery ? { [topLevelQueryName]: select } : select,\n        keyPaths,\n        valuePaths,\n        missingItems,\n      }\n\n      // as for aggregate we simplify the api to not include `select`\n      // we need to map this here so the errors make sense\n      if (originalMethod?.endsWith('aggregate')) {\n        printJsonArgs = transformAggregatePrintJsonArgs(printJsonArgs)\n      }\n\n      const errorStr = `${stack}${indent(\n        printJsonWithErrors(printJsonArgs),\n        indentValue,\n      ).slice(indentValue)}${chalk.dim(afterLines)}\n\n${errorMessages}${missingArgsLegend}\\n`\n\n      if (process.env.NO_COLOR || errorFormat === 'colorless') {\n        return stripAnsi(errorStr)\n      }\n      return errorStr\n    }\n    // end renderErrorStr definition\n\n    const error = new PrismaClientValidationError(\n      renderErrorStr(validationCallsite),\n    )\n\n    // @ts-ignore\n    if (process.env.NODE_ENV !== 'production') {\n      Object.defineProperty(error, 'render', {\n        get: () => renderErrorStr,\n        enumerable: false,\n      })\n    }\n    throw error\n  }\n  protected printFieldError = (\n    { error, path }: FieldError,\n    missingItems: MissingItem[],\n    minimal: boolean,\n  ) => {\n    if (error.type === 'emptySelect') {\n      const additional = minimal\n        ? ''\n        : ` Available options are listed in ${chalk.greenBright.dim('green')}.`\n      return `The ${chalk.redBright(\n        '`select`',\n      )} statement for type ${chalk.bold(\n        getOutputTypeName(error.field.outputType.type),\n      )} must not be empty.${additional}`\n    }\n    if (error.type === 'emptyInclude') {\n      if (missingItems.length === 0) {\n        return `${chalk.bold(\n          getOutputTypeName(error.field.outputType.type),\n        )} does not have any relation and therefore can't have an ${chalk.redBright(\n          '`include`',\n        )} statement.`\n      }\n      const additional = minimal\n        ? ''\n        : ` Available options are listed in ${chalk.greenBright.dim('green')}.`\n      return `The ${chalk.redBright(\n        '`include`',\n      )} statement for type ${chalk.bold(\n        getOutputTypeName(error.field.outputType.type),\n      )} must not be empty.${additional}`\n    }\n    if (error.type === 'noTrueSelect') {\n      return `The ${chalk.redBright(\n        '`select`',\n      )} statement for type ${chalk.bold(\n        getOutputTypeName(error.field.outputType.type),\n      )} needs ${chalk.bold('at least one truthy value')}.`\n    }\n    if (error.type === 'includeAndSelect') {\n      return `Please ${chalk.bold('either')} use ${chalk.greenBright(\n        '`include`',\n      )} or ${chalk.greenBright('`select`')}, but ${chalk.redBright(\n        'not both',\n      )} at the same time.`\n    }\n    if (error.type === 'invalidFieldName') {\n      const statement = error.isInclude ? 'include' : 'select'\n      const wording = error.isIncludeScalar ? 'Invalid scalar' : 'Unknown'\n      const additional = minimal\n        ? ''\n        : error.isInclude && missingItems.length === 0\n          ? `\\nThis model has no relations, so you can't use ${chalk.redBright(\n            'include',\n          )} with it.`\n          : ` Available options are listed in ${chalk.greenBright.dim('green')}.`\n      let str = `${wording} field ${chalk.redBright(\n        `\\`${error.providedName}\\``,\n      )} for ${chalk.bold(statement)} statement on model ${chalk.bold.white(\n        error.modelName,\n      )}.${additional}`\n\n      if (error.didYouMean) {\n        str += ` Did you mean ${chalk.greenBright(`\\`${error.didYouMean}\\``)}?`\n      }\n\n      if (error.isIncludeScalar) {\n        str += `\\nNote, that ${chalk.bold(\n          'include',\n        )} statements only accept relation fields.`\n      }\n\n      return str\n    }\n    if (error.type === 'invalidFieldType') {\n      const str = `Invalid value ${chalk.redBright(\n        `${stringifyObject(error.providedValue)}`,\n      )} of type ${chalk.redBright(\n        getGraphQLType(error.providedValue, undefined),\n      )} for field ${chalk.bold(\n        `${error.fieldName}`,\n      )} on model ${chalk.bold.white(\n        error.modelName,\n      )}. Expected either ${chalk.greenBright('true')} or ${chalk.greenBright(\n        'false',\n      )}.`\n\n      return str\n    }\n  }\n  protected printArgError = (\n    { error, path }: ArgError,\n    hasMissingItems: boolean,\n    minimal: boolean,\n  ) => {\n    if (error.type === 'invalidName') {\n      let str = `Unknown arg ${chalk.redBright(\n        `\\`${error.providedName}\\``,\n      )} in ${chalk.bold(path.join('.'))} for type ${chalk.bold(\n        error.outputType\n          ? error.outputType.name\n          : getInputTypeName(error.originalType),\n      )}.`\n      if (error.didYouMeanField) {\n        str += `\\n\u2192 Did you forget to wrap it with \\`${chalk.greenBright(\n          'select',\n        )}\\`? ${chalk.dim(\n          'e.g. ' +\n          chalk.greenBright(\n            `{ select: { ${error.providedName}: ${error.providedValue} } }`,\n          ),\n        )}`\n      } else if (error.didYouMeanArg) {\n        str += ` Did you mean \\`${chalk.greenBright(error.didYouMeanArg)}\\`?`\n        if (!hasMissingItems && !minimal) {\n          str +=\n            ` ${chalk.dim('Available args:')}\\n` +\n            stringifyInputType(error.originalType, true)\n        }\n      } else {\n        if ((error.originalType as DMMF.InputType).fields.length === 0) {\n          str += ` The field ${chalk.bold(\n            (error.originalType as DMMF.InputType).name,\n          )} has no arguments.`\n        } else if (!hasMissingItems && !minimal) {\n          str +=\n            ` Available args:\\n\\n` +\n            stringifyInputType(error.originalType, true)\n        }\n      }\n      return str\n    }\n\n    if (error.type === 'invalidType') {\n      let valueStr = stringifyObject(error.providedValue, { indent: '  ' })\n      const multilineValue = valueStr.split('\\n').length > 1\n      if (multilineValue) {\n        valueStr = `\\n${valueStr}\\n`\n      }\n      // TODO: we don't yet support enums in a union with a non enum. This is mostly due to not implemented error handling\n      // at this code part.\n      if (error.requiredType.bestFittingType.kind === 'enum') {\n        return `Argument ${chalk.bold(\n          error.argName,\n        )}: Provided value ${chalk.redBright(valueStr)}${multilineValue ? '' : ' '\n          }of type ${chalk.redBright(\n            getGraphQLType(error.providedValue),\n          )} on ${chalk.bold(\n            `prisma.${this.children[0].name}`,\n          )} is not a ${chalk.greenBright(\n            wrapWithList(\n              stringifyGraphQLType(error.requiredType.bestFittingType.kind),\n              error.requiredType.bestFittingType.isList,\n            ),\n          )}.\n\u2192 Possible values: ${(error.requiredType.bestFittingType\n            .type as DMMF.SchemaEnum).values\n            .map((v) =>\n              chalk.greenBright(\n                `${stringifyGraphQLType(\n                  error.requiredType.bestFittingType.type,\n                )}.${v}`,\n              ),\n            )\n            .join(', ')}`\n      }\n\n      let typeStr = '.'\n      if (isInputArgType(error.requiredType.bestFittingType.type)) {\n        typeStr =\n          ':\\n' + stringifyInputType(error.requiredType.bestFittingType.type)\n      }\n      let expected = `${error.requiredType.inputType\n        .map((t) =>\n          chalk.greenBright(\n            wrapWithList(\n              stringifyGraphQLType(t.type),\n              error.requiredType.bestFittingType.isList,\n            ),\n          ),\n        )\n        .join(' or ')}${typeStr}`\n      const inputType: null | DMMF.SchemaArgInputType =\n        (error.requiredType.inputType.length === 2 &&\n          error.requiredType.inputType.find((t) => isInputArgType(t.type))) ||\n        null\n      if (inputType) {\n        expected += `\\n` + stringifyInputType(inputType.type, true)\n      }\n      return `Argument ${chalk.bold(\n        error.argName,\n      )}: Got invalid value ${chalk.redBright(valueStr)}${multilineValue ? '' : ' '\n        }on ${chalk.bold(\n          `prisma.${this.children[0].name}`,\n        )}. Provided ${chalk.redBright(\n          getGraphQLType(error.providedValue),\n        )}, expected ${expected}`\n    }\n\n    if (error.type === 'invalidNullArg') {\n      const forStr =\n        path.length === 1 && path[0] === error.name\n          ? ''\n          : ` for ${chalk.bold(`${path.join('.')}`)}`\n      const undefinedTip = ` Please use ${chalk.bold.greenBright(\n        'undefined',\n      )} instead.`\n      return `Argument ${chalk.greenBright(\n        error.name,\n      )}${forStr} must not be ${chalk.bold('null')}.${undefinedTip}`\n    }\n\n    if (error.type === 'missingArg') {\n      const forStr =\n        path.length === 1 && path[0] === error.missingName\n          ? ''\n          : ` for ${chalk.bold(`${path.join('.')}`)}`\n      return `Argument ${chalk.greenBright(\n        error.missingName,\n      )}${forStr} is missing.`\n    }\n\n    if (error.type === 'atLeastOne') {\n      const additional = minimal\n        ? ''\n        : ` Available args are listed in ${chalk.dim.green('green')}.`\n      return `Argument ${chalk.bold(path.join('.'))} of type ${chalk.bold(\n        error.inputType.name,\n      )} needs ${chalk.greenBright('at least one')} argument.${additional}`\n    }\n\n    if (error.type === 'atMostOne') {\n      const additional = minimal\n        ? ''\n        : ` Please choose one. ${chalk.dim(\n          'Available args:',\n        )} \\n${stringifyInputType(error.inputType, true)}`\n      return `Argument ${chalk.bold(path.join('.'))} of type ${chalk.bold(\n        error.inputType.name,\n      )} needs ${chalk.greenBright(\n        'exactly one',\n      )} argument, but you provided ${error.providedKeys\n        .map((key) => chalk.redBright(key))\n        .join(' and ')}.${additional}`\n    }\n  }\n  /**\n   * As we're allowing both single objects and array of objects for list inputs, we need to remove incorrect\n   * zero indexes from the path\n   * @param inputPath e.g. ['where', 'AND', 0, 'id']\n   * @param select select object\n   */\n  private normalizePath(inputPath: Array<string | number>, select: any) {\n    const path = inputPath.slice()\n    const newPath: Array<string | number> = []\n    let key: undefined | string | number\n    let pointer = select\n    // tslint:disable-next-line:no-conditional-assignment\n    while ((key = path.shift()) !== undefined) {\n      if (!Array.isArray(pointer) && key === 0) {\n        continue\n      }\n      if (key === 'select') {\n        // TODO: Remove this logic! It shouldn't be needed\n        if (!pointer[key]) {\n          pointer = pointer.include\n        } else {\n          pointer = pointer[key]\n        }\n      } else if (pointer && pointer[key]) {\n        pointer = pointer[key]\n      }\n\n      newPath.push(key)\n    }\n    return newPath\n  }\n}\n\nexport class PrismaClientValidationError extends Error { }\n\nexport interface FieldArgs {\n  name: string\n  schemaField?: DMMF.SchemaField // optional as we want to even build up invalid queries to collect all errors\n  args?: Args\n  children?: Field[]\n  error?: InvalidFieldError\n}\n\nexport class Field {\n  public readonly name: string\n  public readonly args?: Args\n  public readonly children?: Field[]\n  public readonly error?: InvalidFieldError\n  public readonly hasInvalidChild: boolean\n  public readonly hasInvalidArg: boolean\n  public readonly schemaField?: DMMF.SchemaField\n  constructor({ name, args, children, error, schemaField }: FieldArgs) {\n    this.name = name\n    this.args = args\n    this.children = children\n    this.error = error\n    this.schemaField = schemaField\n    this.hasInvalidChild = children\n      ? children.some((child) =>\n        Boolean(child.error || child.hasInvalidArg || child.hasInvalidChild),\n      )\n      : false\n    this.hasInvalidArg = args ? args.hasInvalidArg : false\n  }\n  public toString() {\n    let str = this.name\n\n    if (this.error) {\n      return str + ' # INVALID_FIELD'\n    }\n\n    if (this.args && this.args.args && this.args.args.length > 0) {\n      if (this.args.args.length === 1) {\n        str += `(${this.args.toString()})`\n      } else {\n        str += `(\\n${indent(this.args.toString(), tab)}\\n)`\n      }\n    }\n\n    if (this.children) {\n      str += ` {\n${indent(this.children.map(String).join('\\n'), tab)}\n}`\n    }\n\n    return str\n  }\n  public collectErrors(\n    prefix = 'select',\n  ): { fieldErrors: FieldError[]; argErrors: ArgError[] } {\n    const fieldErrors: FieldError[] = []\n    const argErrors: ArgError[] = []\n\n    if (this.error) {\n      fieldErrors.push({\n        path: [this.name],\n        error: this.error,\n      })\n    }\n\n    // get all errors from fields\n    if (this.children) {\n      for (const child of this.children) {\n        const errors = child.collectErrors(prefix)\n        // Field -> Field always goes through a 'select'\n        fieldErrors.push(\n          ...errors.fieldErrors.map((e) => ({\n            ...e,\n            path: [this.name, prefix, ...e.path],\n          })),\n        )\n        argErrors.push(\n          ...errors.argErrors.map((e) => ({\n            ...e,\n            path: [this.name, prefix, ...e.path],\n          })),\n        )\n      }\n    }\n\n    // get all errors from args\n    if (this.args) {\n      argErrors.push(\n        ...this.args\n          .collectErrors()\n          .map((e) => ({ ...e, path: [this.name, ...e.path] })),\n      )\n    }\n\n    return {\n      fieldErrors,\n      argErrors,\n    }\n  }\n}\n\nexport class Args {\n  public args: Arg[]\n  public readonly hasInvalidArg: boolean\n  constructor(args: Arg[] = []) {\n    this.args = args\n    this.hasInvalidArg = args\n      ? args.some((arg) => Boolean(arg.hasError))\n      : false\n  }\n  public toString() {\n    if (this.args.length === 0) {\n      return ''\n    }\n    return `${this.args\n      .map((arg) => arg.toString())\n      .filter((a) => a)\n      .join('\\n')}`\n  }\n  public collectErrors(): ArgError[] {\n    if (!this.hasInvalidArg) {\n      return []\n    }\n\n    return flatMap(this.args, (arg) => arg.collectErrors())\n  }\n}\n\n/**\n * Custom stringify which turns undefined into null - needed by GraphQL\n * @param obj to stringify\n * @param _\n * @param tab\n */\nfunction stringify(\n  obj,\n  _?: any,\n  tabbing?: string | number,\n  isEnum?: boolean,\n  isJson?: boolean,\n) {\n  if (Buffer.isBuffer(obj)) {\n    return JSON.stringify(obj.toString('base64'))\n  }\n\n  if (isJson) {\n    if (obj === null) {\n      return 'null'\n    }\n    if (obj && obj.values && obj.__prismaRawParamaters__) {\n      return JSON.stringify(obj.values)\n    }\n    return JSON.stringify(JSON.stringify(obj))\n  }\n\n  if (obj === undefined) {\n    return null\n  }\n\n  if (obj === null) {\n    return 'null'\n  }\n\n  if (Decimal.isDecimal(obj)) {\n    return obj.toString()\n  }\n\n  if (isEnum && typeof obj === 'string') {\n    return obj\n  }\n\n  if (isEnum && Array.isArray(obj)) {\n    return `[${obj.join(', ')}]`\n  }\n\n  return JSON.stringify(obj, _, tabbing)\n}\n\ninterface ArgOptions {\n  key: string\n  value: ArgValue\n  argType?: DMMF.ArgType // just needed to transform the ast\n  isEnum?: boolean\n  error?: InvalidArgError\n  schemaArg?: DMMF.SchemaArg\n}\n\nexport class Arg {\n  public key: string\n  // not readonly, as we later need to transform it\n  public value: ArgValue\n  public error?: InvalidArgError\n  public hasError: boolean\n  public isEnum: boolean\n  public schemaArg?: DMMF.SchemaArg\n  public argType?: DMMF.ArgType\n  public isNullable: boolean\n\n  constructor({\n    key,\n    value,\n    argType,\n    isEnum = false,\n    error,\n    schemaArg,\n  }: ArgOptions) {\n    this.key = key\n    this.value = value\n    this.argType = argType\n    this.isEnum = isEnum\n    this.error = error\n    this.schemaArg = schemaArg\n    this.isNullable =\n      schemaArg?.inputTypes.reduce<boolean>(\n        (isNullable, inputType) => isNullable && schemaArg.isNullable,\n        true,\n      ) || false\n    this.hasError =\n      Boolean(error) ||\n      (value instanceof Args ? value.hasInvalidArg : false) ||\n      (Array.isArray(value) &&\n        value.some((v) => (v instanceof Args ? v.hasInvalidArg : false)))\n  }\n  public _toString(value: ArgValue, key: string): string | undefined {\n    if (typeof value === 'undefined') {\n      return undefined\n    }\n\n    if (value instanceof Args) {\n      if (\n        value.args.length === 1 &&\n        value.args[0].key === 'set' &&\n        value.args[0].schemaArg?.inputTypes[0].type === 'Json'\n      ) {\n        return `${key}: {\n  set: ${stringify(value.args[0].value, null, 2, this.isEnum, true)}\n}`\n      }\n      return `${key}: {\n${indent(value.toString(), 2)}\n}`\n    }\n\n    if (Array.isArray(value)) {\n      if (this.argType === 'Json') {\n        return `${key}: ${stringify(\n          value,\n          null,\n          2,\n          this.isEnum,\n          this.argType === 'Json',\n        )}`\n      }\n\n      const isScalar = !(value as any[]).some((v) => typeof v === 'object')\n      return `${key}: [${isScalar ? '' : '\\n'}${indent(\n        (value as any[])\n          .map((nestedValue) => {\n            if (nestedValue instanceof Args) {\n              return `{\\n${indent(nestedValue.toString(), tab)}\\n}`\n            }\n            return stringify(nestedValue, null, 2, this.isEnum)\n          })\n          .join(`,${isScalar ? ' ' : '\\n'}`),\n        isScalar ? 0 : tab,\n      )}${isScalar ? '' : '\\n'}]`\n    }\n\n    return `${key}: ${stringify(\n      value,\n      null,\n      2,\n      this.isEnum,\n      this.argType === 'Json',\n    )}`\n  }\n  public toString() {\n    return this._toString(this.value, this.key)\n  }\n  public collectErrors(): ArgError[] {\n    if (!this.hasError) {\n      return []\n    }\n\n    const errors: ArgError[] = []\n\n    // add the own arg\n    if (this.error) {\n      errors.push({\n        error: this.error,\n        path: [this.key],\n      })\n    }\n\n    if (Array.isArray(this.value)) {\n      errors.push(\n        ...(flatMap(this.value as any[], (val, index) => {\n          if (!val.collectErrors) {\n            return []\n          }\n\n          return val.collectErrors().map((e) => {\n            return { ...e, path: [this.key, index, ...e.path] }\n          })\n        }) as any[]),\n      )\n    }\n\n    // collect errors of children if there are any\n    if (this.value instanceof Args) {\n      errors.push(\n        ...this.value\n          .collectErrors()\n          .map((e) => ({ ...e, path: [this.key, ...e.path] })),\n      )\n    }\n\n    return errors\n  }\n}\n\nexport type ArgValue =\n  | string\n  | boolean\n  | number\n  | undefined\n  | Args\n  | string[]\n  | boolean[]\n  | number[]\n  | Args[]\n  | null\n\nexport interface DocumentInput {\n  dmmf: DMMFClass\n  rootTypeName: 'query' | 'mutation'\n  rootField: string\n  select?: any\n}\n\nexport function makeDocument({\n  dmmf,\n  rootTypeName,\n  rootField,\n  select,\n}: DocumentInput): Document {\n  if (!select) {\n    select = {}\n  }\n  const rootType = rootTypeName === 'query' ? dmmf.queryType : dmmf.mutationType\n  // Create a fake toplevel field for easier implementation\n  const fakeRootField: DMMF.SchemaField = {\n    args: [],\n    outputType: {\n      isList: false,\n      type: rootType,\n      kind: 'object',\n    },\n    isRequired: true,\n    name: rootTypeName,\n  }\n  const children = selectionToFields(\n    dmmf,\n    { [rootField]: select },\n    fakeRootField,\n    [rootTypeName],\n  )\n  return new Document(rootTypeName, children) as any\n}\n\n// TODO: get rid of this function\nexport function transformDocument(document: Document): Document {\n  return document\n}\n\nfunction isArgsArray(input: any): input is Args[] {\n  if (Array.isArray(input)) {\n    return input.every((arg) => arg instanceof Args)\n  }\n\n  return false\n}\n\nfunction getFilterArgName(arg: string, filter: string) {\n  if (filter === 'equals') {\n    return arg\n  }\n\n  return `${arg}_${convertToSnakeCase(filter)}`\n}\n\nfunction convertToSnakeCase(str: string): string {\n  return str\n    .split(/(?=[A-Z])/)\n    .join('_')\n    .toLowerCase()\n}\n\nexport function selectionToFields(\n  dmmf: DMMFClass,\n  selection: any,\n  schemaField: DMMF.SchemaField,\n  path: string[],\n): Field[] {\n  const outputType = schemaField.outputType.type as DMMF.OutputType\n  return Object.entries(selection).reduce((acc, [name, value]: any) => {\n    const field = outputType.fieldMap\n      ? outputType.fieldMap[name]\n      : outputType.fields.find((f) => f.name === name)\n\n    if (!field) {\n      // if the field name is incorrect, we ignore the args and child fields altogether\n      acc.push(\n        new Field({\n          name,\n          children: [],\n          // @ts-ignore\n          error: {\n            type: 'invalidFieldName',\n            modelName: outputType.name,\n            providedName: name,\n            didYouMean: getSuggestion(\n              name,\n              outputType.fields.map((f) => f.name),\n            ),\n            outputType,\n          },\n        }),\n      )\n\n      return acc\n    }\n\n    if (\n      typeof value !== 'boolean' &&\n      field.outputType.kind === 'scalar' &&\n      field.name !== 'executeRaw' &&\n      field.name !== 'queryRaw' &&\n      outputType.name !== 'Query' &&\n      !name.startsWith('aggregate') &&\n      field.name !== 'count' // TODO: Find a cleaner solution\n    ) {\n      acc.push(\n        new Field({\n          name,\n          children: [],\n          error: {\n            type: 'invalidFieldType',\n            modelName: outputType.name,\n            fieldName: name,\n            providedValue: value,\n          },\n        }),\n      )\n\n      return acc\n    }\n    if (value === false) {\n      return acc\n    }\n\n    const transformedField = {\n      name: field.name,\n      fields: field.args,\n      constraints: {\n        minNumFields: null,\n        maxNumFields: null\n      }\n    }\n    const argsWithoutIncludeAndSelect =\n      typeof value === 'object' ? omit(value, ['include', 'select']) : undefined\n    const args = argsWithoutIncludeAndSelect\n      ? objectToArgs(\n        argsWithoutIncludeAndSelect,\n        transformedField,\n        [],\n        typeof field === 'string'\n          ? undefined\n          : (field.outputType.type as DMMF.OutputType),\n      )\n      : undefined\n    const isRelation = field.outputType.kind === 'object'\n\n    // TODO: use default selection for `include` again\n\n    // check for empty select\n    if (value) {\n      if (value.select && value.include) {\n        acc.push(\n          new Field({\n            name,\n            children: [\n              new Field({\n                name: 'include',\n                args: new Args(),\n                error: {\n                  type: 'includeAndSelect',\n                  field,\n                },\n              }),\n            ],\n          }),\n        )\n      } else if (value.include) {\n        const keys = Object.keys(value.include)\n\n        if (keys.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: 'include',\n                  args: new Args(),\n                  error: {\n                    type: 'emptyInclude',\n                    field,\n                  },\n                }),\n              ],\n            }),\n          )\n\n          return acc\n        }\n\n        // TODO: unify with select validation logic\n        /**\n         * Error handling for `include` statements\n         */\n        if (field.outputType.kind === 'object') {\n          const fieldOutputType = field.outputType.type as DMMF.OutputType\n          const allowedKeys = fieldOutputType.fields\n            .filter((f) => f.outputType.kind === 'object')\n            .map((f) => f.name)\n          const invalidKeys = keys.filter((key) => !allowedKeys.includes(key))\n          if (invalidKeys.length > 0) {\n            acc.push(\n              ...invalidKeys.map(\n                (invalidKey) =>\n                  new Field({\n                    name: invalidKey,\n                    children: [\n                      new Field({\n                        name: invalidKey,\n                        args: new Args(),\n                        error: {\n                          type: 'invalidFieldName',\n                          modelName: fieldOutputType.name,\n                          outputType: fieldOutputType,\n                          providedName: invalidKey,\n                          didYouMean:\n                            getSuggestion(invalidKey, allowedKeys) || undefined,\n                          isInclude: true,\n                          isIncludeScalar: fieldOutputType.fields.some(\n                            (f) => f.name === invalidKey,\n                          ),\n                        },\n                      }),\n                    ],\n                    // @ts-ignore\n                  }),\n              ),\n            )\n            return acc\n          }\n        }\n      } else if (value.select) {\n        const values = Object.values(value.select)\n        if (values.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: 'select',\n                  args: new Args(),\n                  error: {\n                    type: 'emptySelect',\n                    field,\n                  },\n                }),\n              ],\n            }),\n          )\n\n          return acc\n        }\n\n        // check if there is at least one truthy value\n        const truthyValues = values.filter((v) => v)\n        if (truthyValues.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: 'select',\n                  args: new Args(),\n                  error: {\n                    type: 'noTrueSelect',\n                    field,\n                  },\n                }),\n              ],\n            }),\n          )\n\n          return acc\n        }\n      }\n    }\n    // either use select or default selection, but not both at the same time\n    const defaultSelection = isRelation\n      ? getDefaultSelection(field.outputType.type as DMMF.OutputType)\n      : null\n    let select = defaultSelection\n    if (value) {\n      if (value.select) {\n        select = value.select\n      } else if (value.include) {\n        select = deepExtend(defaultSelection, value.include)\n      }\n    }\n    const children =\n      select !== false && isRelation\n        ? selectionToFields(dmmf, select, field, [...path, name])\n        : undefined\n\n    acc.push(new Field({ name, args, children, schemaField: field }))\n\n    return acc\n  }, [] as Field[])\n}\n\nfunction getDefaultSelection(outputType: DMMF.OutputType) {\n  return outputType.fields.reduce((acc, f) => {\n    if (f.outputType.kind === 'scalar' || f.outputType.kind === 'enum') {\n      acc[f.name] = true\n    } else {\n      // otherwise field is a relation. Only continue if it's an embedded type\n      // as normal types don't end up in the default selection\n      if ((f.outputType.type as DMMF.OutputType).isEmbedded) {\n        acc[f.name] = {\n          select: getDefaultSelection(f.outputType.type as DMMF.OutputType),\n        }\n      }\n    }\n\n    return acc\n  }, {})\n}\n\nfunction getInvalidTypeArg(\n  key: string,\n  value: any,\n  arg: DMMF.SchemaArg,\n  bestFittingType: DMMF.SchemaArgInputType,\n): Arg {\n  const arrg = new Arg({\n    key,\n    value,\n    isEnum: bestFittingType.kind === 'enum',\n    argType: bestFittingType.type,\n    error: {\n      type: 'invalidType',\n      providedValue: value,\n      argName: key,\n      requiredType: {\n        inputType: arg.inputTypes,\n\n        bestFittingType,\n      },\n    },\n  })\n\n  return arrg\n}\n\nfunction hasCorrectScalarType(\n  value: any,\n  arg: DMMF.SchemaArg,\n  inputType: DMMF.SchemaArgInputType,\n): boolean {\n  const { type, isList } = inputType\n  const expectedType = wrapWithList(stringifyGraphQLType(type), isList)\n  const graphQLType = getGraphQLType(value, type)\n\n  if (graphQLType === expectedType) {\n    return true\n  }\n\n  if (isList && graphQLType === 'List<>') {\n    return true\n  }\n\n  if (expectedType === 'Json') {\n    return true\n  }\n\n  if ((graphQLType === 'Int' || graphQLType === 'Float') && expectedType === 'Decimal') {\n    return true\n  }\n\n  // DateTime is a subset of string\n  if (graphQLType === 'DateTime' && expectedType === 'String') {\n    return true\n  }\n  if (graphQLType === 'List<DateTime>' && expectedType === 'List<String>') {\n    return true\n  }\n\n  // UUID is a subset of string\n  if (graphQLType === 'UUID' && expectedType === 'String') {\n    return true\n  }\n  if (graphQLType === 'List<UUID>' && expectedType === 'List<String>') {\n    return true\n  }\n\n  if (graphQLType === 'String' && expectedType === 'ID') {\n    return true\n  }\n  if (graphQLType === 'List<String>' && expectedType === 'List<ID>') {\n    return true\n  }\n  if (\n    expectedType === 'List<String>' &&\n    (graphQLType === 'List<String | UUID>' ||\n      graphQLType === 'List<UUID | String>')\n  ) {\n    return true\n  }\n\n  // Int is a subset of Float\n  if (graphQLType === 'Int' && expectedType === 'Float') {\n    return true\n  }\n  if (graphQLType === 'List<Int>' && expectedType === 'List<Float>') {\n    return true\n  }\n  // Int is a subset of Long\n  if (graphQLType === 'Int' && expectedType === 'Long') {\n    return true\n  }\n  if (graphQLType === 'List<Int>' && expectedType === 'List<Long>') {\n    return true\n  }\n\n  // to match all strings which are valid decimals\n  // from https://github.com/MikeMcl/decimal.js/blob/master/decimal.js#L115\n  if (graphQLType === 'String' && /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i.test(value) && expectedType === 'Decimal') {\n    return true\n  }\n\n  if (!arg.isRequired && value === null) {\n    return true\n  }\n  return false\n}\n\n\nconst cleanObject = (obj) => filterObject(obj, (k, v) => v !== undefined)\n\nfunction valueToArg(key: string, value: any, arg: DMMF.SchemaArg): Arg | null {\n  /**\n   * Go through the possible union input types.\n   * Stop on the first successful one\n   */\n  let maybeArg: Arg | null = null\n  for (const inputType of arg.inputTypes) {\n    maybeArg = tryInferArgs(key, value, arg, inputType)\n    if (maybeArg?.collectErrors().length === 0) {\n      return maybeArg\n    }\n  }\n\n  return maybeArg\n}\n\n/**\n * Running through the possible input types of a union.\n * @param key \n * @param value \n * @param arg \n * @param inputType \n */\nfunction tryInferArgs(key: string, value: any, arg: DMMF.SchemaArg, inputType: DMMF.SchemaArgInputType): Arg | null {\n  if (typeof value === 'undefined') {\n    // the arg is undefined and not required - we're fine\n    if (!arg.isRequired) {\n      return null\n    }\n\n    // the provided value is 'undefined' but shouldn't be\n    return new Arg({\n      key,\n      value,\n      isEnum: inputType.kind === 'enum',\n      error: {\n        type: 'missingArg',\n        missingName: key,\n        missingArg: arg,\n        atLeastOne: false,\n        atMostOne: false,\n      },\n    })\n  }\n\n  const { isNullable, isRequired } = arg\n\n  if (value === null && !isNullable && !isRequired) {\n    // we don't need to execute this ternery if not necessary\n    const isAtLeastOne = isInputArgType(inputType.type)\n      ? (inputType.type.constraints.minNumFields !== null && inputType.type.constraints.minNumFields > 0)\n      : false\n    if (!isAtLeastOne) {\n      return new Arg({\n        key,\n        value,\n        isEnum: inputType.kind === 'enum',\n        error: {\n          type: 'invalidNullArg',\n          name: key,\n          invalidType: arg.inputTypes,\n          atLeastOne: false,\n          atMostOne: false,\n        },\n      })\n    }\n  }\n  // then the first\n  if (!inputType.isList) {\n    if (isInputArgType(inputType.type)) {\n      if (typeof value !== 'object') {\n        return getInvalidTypeArg(key, value, arg, inputType)\n      } else {\n        let val = cleanObject(value)\n        let error: AtMostOneError | AtLeastOneError | undefined\n        const keys = Object.keys(val || {})\n        const numKeys = keys.length\n\n        if (numKeys === 0 && (typeof inputType.type.constraints.minNumFields === 'number' && inputType.type.constraints.minNumFields > 0)) {\n          // continue here\n          error = {\n            type: 'atLeastOne',\n            key,\n            inputType: inputType.type,\n          }\n        } else if (numKeys > 1 && (typeof inputType.type.constraints.maxNumFields === 'number' && inputType.type.constraints.maxNumFields < 2)) {\n          error = {\n            type: 'atMostOne',\n            key,\n            inputType: inputType.type,\n            providedKeys: keys,\n          }\n        }\n\n        return new Arg({\n          key,\n          value:\n            val === null ? null : objectToArgs(val, inputType.type, arg.inputTypes),\n          isEnum: inputType.kind === 'enum',\n          error,\n          argType: inputType.type,\n          schemaArg: arg,\n        })\n      }\n    } else {\n      return scalarToArg(key, value, arg, inputType)\n    }\n  }\n\n  // the provided arg should be a list, but isn't\n  // that's fine for us as we can just turn this into a list with a single item\n  // and GraphQL even allows this. We're going the conservative route though\n  // and actually generate the [] around the value\n\n  if (!Array.isArray(value) && inputType.isList) {\n    // TODO: This \"if condition\" is just a hack until the query engine is fixed\n    if (key !== 'updateMany') {\n      value = [value]\n    }\n  }\n\n  if (inputType.kind === 'enum' || inputType.kind === 'scalar') {\n    // if no value is incorrect\n    return scalarToArg(key, value, arg, inputType)\n  }\n\n  const argInputType = inputType.type as DMMF.InputType\n  const hasAtLeastOneError = (typeof argInputType.constraints.minNumFields === 'number' && argInputType.constraints.minNumFields > 0)\n    ? Array.isArray(value) && value.some((v) => !v || Object.keys(cleanObject(v)).length === 0)\n    : false\n  let err: AtLeastOneError | undefined | AtMostOneError = hasAtLeastOneError\n    ? {\n      inputType: argInputType,\n      key,\n      type: 'atLeastOne',\n    }\n    : undefined\n  if (!err) {\n    const hasOneOfError = (typeof argInputType.constraints.maxNumFields === 'number' && argInputType.constraints.maxNumFields < 2)\n      ? Array.isArray(value) && value.find((v) => !v || Object.keys(cleanObject(v)).length !== 1)\n      : false\n    if (hasOneOfError) {\n      err = {\n        inputType: argInputType,\n        key,\n        type: 'atMostOne',\n        providedKeys: Object.keys(hasOneOfError),\n      }\n    }\n  }\n\n  if (!Array.isArray(value)) {\n    for (const argInputType of arg.inputTypes) {\n      const args = objectToArgs(value, argInputType.type as DMMF.InputType)\n      if (args.collectErrors().length === 0) {\n        return new Arg({ key, value: args, isEnum: false, argType: argInputType.type, schemaArg: arg, })\n      }\n    }\n  }\n\n\n  return new Arg({\n    key,\n    value: value.map((v) => {\n      if ((inputType.isList) && typeof v !== 'object') {\n        return v\n      }\n      if (typeof v !== 'object' || !value) {\n        return getInvalidTypeArg(key, v, arg, inputType)\n      }\n      return objectToArgs(v, argInputType)\n    }),\n    isEnum: false,\n    argType: argInputType,\n    schemaArg: arg,\n    error: err,\n  })\n}\n\nexport function isInputArgType(\n  argType: DMMF.ArgType,\n): argType is DMMF.InputType {\n  if (typeof argType === 'string') {\n    return false\n  }\n  if (argType.hasOwnProperty('values')) {\n    return false\n  }\n\n  return true\n}\n\nfunction scalarToArg(\n  key: string,\n  value: any,\n  arg: DMMF.SchemaArg,\n  inputType: DMMF.SchemaArgInputType,\n): Arg {\n  if (hasCorrectScalarType(value, arg, inputType)) {\n    return new Arg({\n      key,\n      value,\n      isEnum: arg.inputTypes[0].kind === 'enum',\n      argType: inputType.type,\n      schemaArg: arg,\n    })\n  }\n  return getInvalidTypeArg(key, value, arg, inputType)\n}\n\nfunction objectToArgs(\n  initialObj: any,\n  inputType: DMMF.InputType,\n  possibilities?: DMMF.SchemaArgInputType[],\n  outputType?: DMMF.OutputType,\n): Args {\n  // filter out undefined values and treat them if they weren't provided\n  const obj = cleanObject(initialObj)\n  const { fields: args, fieldMap } = inputType\n  const requiredArgs: any = args\n    .map((arg) => [arg.name, undefined])\n  const objEntries = Object.entries(obj || {})\n  const entries = unionBy(objEntries, requiredArgs, (a) => a[0])\n  const argsList = entries.reduce((acc, [argName, value]: any) => {\n    const schemaArg = fieldMap\n      ? fieldMap[argName]\n      : args.find((a) => a.name === argName)\n    if (!schemaArg) {\n      const didYouMeanField =\n        typeof value === 'boolean' &&\n          outputType &&\n          outputType.fields.some((f) => f.name === argName)\n          ? argName\n          : null\n      acc.push(\n        new Arg({\n          key: argName,\n          value,\n          error: {\n            type: 'invalidName',\n            providedName: argName,\n            providedValue: value,\n            didYouMeanField,\n            didYouMeanArg:\n              (!didYouMeanField &&\n                getSuggestion(argName, [\n                  ...args.map((a) => a.name),\n                  'select',\n                ])) ||\n              undefined,\n            originalType: inputType,\n            possibilities,\n            outputType,\n          },\n        }),\n      )\n      return acc\n    }\n\n    const arg = valueToArg(argName, value, schemaArg)\n\n    if (arg) {\n      acc.push(arg)\n    }\n\n    return acc\n  }, [] as Arg[])\n  // Also show optional neighbour args, if there is any arg missing\n  if (\n    (typeof inputType.constraints.minNumFields === 'number' && objEntries.length < inputType.constraints.minNumFields) ||\n    argsList.find((arg) => (arg.error?.type === 'missingArg' || arg.error?.type === 'atLeastOne'))\n  ) {\n    const optionalMissingArgs = inputType.fields.filter(\n      field => !field.isRequired && (obj && (typeof obj[field.name] === 'undefined' || obj[field.name] === null))\n    )\n    argsList.push(\n      ...optionalMissingArgs.map((arg) => {\n        const argInputType = arg.inputTypes[0]\n        return new Arg({\n          key: arg.name,\n          value: undefined,\n          isEnum: argInputType.kind === 'enum',\n          error: {\n            type: 'missingArg',\n            missingName: arg.name,\n            missingArg: arg,\n            atLeastOne: Boolean(inputType.constraints.minNumFields) || false,\n            atMostOne: inputType.constraints.maxNumFields === 1 || false,\n          },\n        })\n      }),\n    )\n  }\n  return new Args(argsList)\n}\n\nexport interface UnpackOptions {\n  document: Document\n  path: string[]\n  data: any\n}\n\n/**\n * Unpacks the result of a data object and maps DateTime fields to instances of `Date` inplace\n * @param options: UnpackOptions\n */\nexport function unpack({ document, path, data }: UnpackOptions): any {\n  const result = deepGet(data, path)\n\n  if (result === 'undefined') {\n    return null\n  }\n\n  if (typeof result !== 'object') {\n    return result\n  }\n\n  const field = getField(document, path)\n\n  return mapScalars({ field, data: result })\n}\n\nexport interface MapScalarsOptions {\n  field: Field\n  data: any\n}\n\nexport function mapScalars({ field, data }: MapScalarsOptions): any {\n  if (\n    !data ||\n    typeof data !== 'object' ||\n    !field.children ||\n    !field.schemaField\n  ) {\n    return data\n  }\n\n  const deserializers = {\n    'DateTime': value => new Date(value),\n    'Json': value => JSON.parse(value),\n    'Bytes': value => Buffer.from(value, 'base64'),\n    'Decimal': value => {\n      return new Decimal(value)\n    }\n  }\n\n  for (const child of field.children) {\n    const outputType = child.schemaField?.outputType.type\n    if (outputType && typeof outputType === 'string') {\n      const deserializer = deserializers[outputType]\n      if (deserializer) {\n        if (Array.isArray(data)) {\n          for (const entry of data) {\n            // in the very unlikely case, that a field is not there in the result, ignore it\n            if (typeof entry[child.name] !== 'undefined' && entry[child.name] !== null) {\n              entry[child.name] = deserializer(entry[child.name])\n            }\n          }\n        } else {\n          // same here, ignore it if it's undefined\n          if (typeof data[child.name] !== 'undefined' && data[child.name] !== null) {\n            data[child.name] = deserializer(data[child.name])\n          }\n        }\n      }\n    }\n\n    if (child.schemaField && child.schemaField.outputType.kind === 'object') {\n      if (Array.isArray(data)) {\n        for (const entry of data) {\n          mapScalars({ field: child, data: entry[child.name] })\n        }\n      } else {\n        mapScalars({ field: child, data: data[child.name] })\n      }\n    }\n  }\n\n  return data\n}\n\nexport function getField(document: Document, path: string[]): Field {\n  const todo = path.slice() // let's create a copy to not fiddle with the input argument\n  const firstElement = todo.shift()\n  // this might be slow because of the find\n  let pointer = document.children.find((c) => c.name === firstElement)\n\n  if (!pointer) {\n    throw new Error(\n      `Could not find field ${firstElement} in document ${document}`,\n    )\n  }\n\n  while (todo.length > 0) {\n    const key = todo.shift()\n    if (!pointer!.children) {\n      throw new Error(\n        `Can't get children for field ${pointer} with child ${key}`,\n      )\n    }\n    const child = pointer!.children.find((c) => c.name === key)\n    if (!child) {\n      throw new Error(`Can't find child ${key} of field ${pointer}`)\n    }\n    pointer = child!\n  }\n\n  return pointer!\n}\n\nfunction removeSelectFromPath(path: string): string {\n  return path\n    .split('.')\n    .filter((p) => p !== 'select')\n    .join('.')\n}\n\nfunction removeSelectFromObject(obj: object): object {\n  const type = Object.prototype.toString.call(obj)\n  if (type === '[object Object]') {\n    const copy = {}\n    for (const key in obj) {\n      if (key === 'select') {\n        for (const subKey in obj['select']) {\n          copy[subKey] = removeSelectFromObject(obj['select'][subKey])\n        }\n      } else {\n        copy[key] = removeSelectFromObject(obj[key])\n      }\n    }\n    return copy\n  }\n\n  return obj\n}\n\nfunction transformAggregatePrintJsonArgs({\n  ast,\n  keyPaths,\n  missingItems,\n  valuePaths,\n}: PrintJsonWithErrorsArgs): PrintJsonWithErrorsArgs {\n  const newKeyPaths = keyPaths.map(removeSelectFromPath)\n  const newValuePaths = valuePaths.map(removeSelectFromPath)\n  const newMissingItems = missingItems.map((item) => ({\n    path: removeSelectFromPath(item.path),\n    isRequired: item.isRequired,\n    type: item.type,\n  }))\n\n  const newAst = removeSelectFromObject(ast)\n  return {\n    ast: newAst,\n    keyPaths: newKeyPaths,\n    missingItems: newMissingItems,\n    valuePaths: newValuePaths,\n  }\n}\n", "// Taken from https://github.com/unclechu/node-deep-extend/blob/master/lib/deep-extend.js\n// es2017-ified, now it's about 2.5 times faster\n/*!\n * @description Recursive object extending\n * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>\n * @license MIT\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2013-2018 Viacheslav Lotsmanov\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/* tslint:disable */\n\nfunction isSpecificValue(val) {\n  return val instanceof Buffer || val instanceof Date || val instanceof RegExp\n    ? true\n    : false\n}\n\nfunction cloneSpecificValue(val) {\n  if (val instanceof Buffer) {\n    const x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length)\n    val.copy(x)\n    return x\n  } else if (val instanceof Date) {\n    return new Date(val.getTime())\n  } else if (val instanceof RegExp) {\n    return new RegExp(val)\n  } else {\n    throw new Error('Unexpected situation')\n  }\n}\n\n/**\n * Recursive cloning array.\n */\nfunction deepCloneArray(arr) {\n  const clone: any = []\n  arr.forEach(function (item, index) {\n    if (typeof item === 'object' && item !== null) {\n      if (Array.isArray(item)) {\n        clone[index] = deepCloneArray(item)\n      } else if (isSpecificValue(item)) {\n        clone[index] = cloneSpecificValue(item)\n      } else {\n        clone[index] = deepExtend({}, item)\n      }\n    } else {\n      clone[index] = item\n    }\n  })\n  return clone\n}\n\nfunction safeGetProperty(object, property) {\n  return property === '__proto__' ? undefined : object[property]\n}\n\n/**\n * Extening object that entered in first argument.\n *\n * Returns extended object or false if have no target object or incorrect type.\n *\n * If you wish to clone source object (without modify it), just use empty new\n * object as first argument, like this:\n *   deepExtend({}, yourObj_1, [yourObj_N]);\n */\nexport const deepExtend = function (target, ...args) {\n  if (!target || typeof target !== 'object') {\n    return false\n  }\n\n  if (args.length === 0) {\n    return target\n  }\n\n  let val, src\n\n  for (const obj of args) {\n    // skip argument if isn't an object, is null, or is an array\n    if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {\n      continue\n    }\n\n    for (const key of Object.keys(obj)) {\n      src = safeGetProperty(target, key) // source value\n      val = safeGetProperty(obj, key) // new value\n\n      // recursion prevention\n      if (val === target) {\n        continue\n\n        /**\n         * if new value isn't object then just overwrite by new value\n         * instead of extending.\n         */\n      } else if (typeof val !== 'object' || val === null) {\n        target[key] = val\n        continue\n\n        // just clone arrays (and recursive clone objects inside)\n      } else if (Array.isArray(val)) {\n        target[key] = deepCloneArray(val)\n        continue\n\n        // custom cloning and overwrite for specific objects\n      } else if (isSpecificValue(val)) {\n        target[key] = cloneSpecificValue(val)\n        continue\n\n        // overwrite by new value if source isn't object or array\n      } else if (\n        typeof src !== 'object' ||\n        src === null ||\n        Array.isArray(src)\n      ) {\n        target[key] = deepExtend({}, val)\n        continue\n\n        // source value and new value is objects both, extending...\n      } else {\n        target[key] = deepExtend(src, val)\n        continue\n      }\n    }\n  }\n\n  return target\n}\n\n// @ts-ignore-end\n", "// Taken from https://gist.github.com/LukeChannings/15c92cef5a016a8b21a0\n/* tslint:disable */\n\n// ensure the keys being passed is an array of key paths\n// example: 'a.b' becomes ['a', 'b'] unless it was already ['a', 'b']\nconst keys = (ks: string | string[]) => (Array.isArray(ks) ? ks : ks.split('.'))\n\n// traverse the set of keys left to right,\n// returning the current value in each iteration.\n// if at any point the value for the current key does not exist,\n// return the default value\nexport const deepGet = (o, kp: string[]) =>\n  keys(kp).reduce((o, k) => o && o[k], o)\n\n// traverse the set of keys right to left,\n// returning a new object containing both properties from the object\n// we were originally passed and our new property.\n//\n// Example:\n// If o = { a: { b: { c: 1 } } }\n//\n// deepSet(o, ['a', 'b', 'c'], 2) will progress thus:\n// 1. c = Object.assign({}, {c: 1}, { c: 2 })\n// 2. b = Object.assign({}, { b: { c: 1 } }, { b: c })\n// 3. returned = Object.assign({}, { a: { b: { c: 1 } } }, { a: b })\nexport const deepSet = (o: any, kp: string | string[], v: any) =>\n  keys(kp).reduceRight(\n    (v, k, i, ks) => Object.assign({}, deepGet(o, ks.slice(0, i)), { [k]: v }),\n    v,\n  )\n", "export function filterObject(obj, cb) {\n  if (\n    !obj ||\n    typeof obj !== 'object' ||\n    typeof obj.hasOwnProperty !== 'function'\n  ) {\n    return obj\n  }\n  const newObj = {}\n  for (const key in obj) {\n    const value = obj[key]\n    if (obj.hasOwnProperty(key) && cb(key, value)) {\n      newObj[key] = value\n    }\n  }\n  return newObj\n}\n", "// Due to a TypeScript bug, we're shipping these core types for now\nexport type Exclude<T, U> = T extends U ? never : T\n\nexport type Omit<T, K extends keyof any> = { [P in Exclude<keyof T, K>]: T[P] }\n\nexport function omit<T extends object, K extends keyof T>(\n  object: T,\n  path: K | K[],\n): Omit<T, K> {\n  const result: any = {}\n  const paths = Array.isArray(path) ? path : [path]\n  for (const key in object) {\n    if (object.hasOwnProperty(key) && !paths.includes(key as any)) {\n      result[key] = object[key]\n    }\n  }\n  return result\n}\n", "import chalk from 'chalk'\nimport stripAnsi from 'strip-ansi'\nimport { deepSet } from './deep-set'\nimport stringifyObject from './stringifyObject'\n\nexport interface MissingItem {\n  path: string\n  isRequired: boolean\n  type: string | object\n}\n\nconst DIM_TOKEN = '@@__DIM_POINTER__@@'\n\nexport type PrintJsonWithErrorsArgs = {\n  ast: object\n  keyPaths: string[]\n  valuePaths: string[]\n  missingItems: MissingItem[]\n}\n\nexport function printJsonWithErrors({\n  ast,\n  keyPaths,\n  valuePaths,\n  missingItems,\n}: PrintJsonWithErrorsArgs) {\n  let obj = ast\n  for (const { path, type } of missingItems) {\n    obj = deepSet(obj, path, type)\n  }\n\n  return stringifyObject(obj, {\n    indent: '  ',\n    transformLine: ({ indent, key, value, stringifiedValue, eol, path }) => {\n      const dottedPath = path.join('.')\n      const keyError = keyPaths.includes(dottedPath)\n      const valueError = valuePaths.includes(dottedPath)\n      const missingItem = missingItems.find((item) => item.path === dottedPath)\n\n      let valueStr = stringifiedValue\n\n      if (missingItem) {\n        // trim away the '' from the string\n        if (typeof value === 'string') {\n          valueStr = valueStr.slice(1, valueStr.length - 1)\n        }\n        const isRequiredStr = missingItem.isRequired ? '' : '?'\n        const prefix = missingItem.isRequired ? '+' : '?'\n        const color = missingItem.isRequired ? chalk.greenBright : chalk.green\n        let output = color(\n          prefixLines(\n            key + isRequiredStr + ': ' + valueStr + eol,\n            indent,\n            prefix,\n          ),\n        )\n        if (!missingItem.isRequired) {\n          output = chalk.dim(output)\n        }\n        return output\n      } else {\n        const isOnMissingItemPath = missingItems.some((item) =>\n          dottedPath.startsWith(item.path),\n        )\n        const isOptional = key[key.length - 2] === '?'\n        if (isOptional) {\n          key = key.slice(1, key.length - 1)\n        }\n        if (isOptional && typeof value === 'object' && value !== null) {\n          valueStr = valueStr\n            .split('\\n')\n            .map((line, index, arr) =>\n              index === arr.length - 1 ? line + DIM_TOKEN : line,\n            )\n            .join('\\n')\n        }\n        if (isOnMissingItemPath && typeof value === 'string') {\n          valueStr = valueStr.slice(1, valueStr.length - 1)\n          if (!isOptional) {\n            valueStr = chalk.bold(valueStr)\n          }\n        }\n        if (\n          (typeof value !== 'object' || value === null) &&\n          !valueError &&\n          !isOnMissingItemPath\n        ) {\n          valueStr = chalk.dim(valueStr)\n        }\n\n        const keyStr = keyError ? chalk.redBright(key) : key\n        valueStr = valueError ? chalk.redBright(valueStr) : valueStr\n        // valueStr can be multiple lines if it's an object\n        let output =\n          indent +\n          keyStr +\n          ': ' +\n          valueStr +\n          (isOnMissingItemPath ? eol : chalk.dim(eol))\n\n        // if there is an error, add the scribble lines\n        // 3 options:\n        // error in key, but not in value\n        // error in value, but not in key\n        // error in both\n        if (keyError || valueError) {\n          const lines = output.split('\\n')\n          const keyLength = String(key).length\n          const keyScribbles = keyError\n            ? chalk.redBright('~'.repeat(keyLength))\n            : ' '.repeat(keyLength)\n\n          const valueLength = valueError\n            ? getValueLength(indent, key, value, stringifiedValue)\n            : 0\n          const hideValueScribbles = Boolean(\n            valueError && typeof value === 'object' && value !== null,\n          )\n          const valueScribbles = valueError\n            ? '  ' + chalk.redBright('~'.repeat(valueLength))\n            : ''\n\n          // Either insert both keyScribles and valueScribbles in one line\n          if (keyScribbles && keyScribbles.length > 0 && !hideValueScribbles) {\n            lines.splice(1, 0, indent + keyScribbles + valueScribbles)\n          }\n\n          // or the valueScribbles for a multiline string\n          if (keyScribbles && keyScribbles.length > 0 && hideValueScribbles) {\n            lines.splice(\n              lines.length - 1,\n              0,\n              indent.slice(0, indent.length - 2) + valueScribbles,\n            )\n          }\n\n          output = lines.join('\\n')\n        }\n        return output\n      }\n    },\n  })\n}\n\nfunction getValueLength(\n  indent: string,\n  key: string,\n  value: any,\n  stringifiedValue: string,\n) {\n  if (value === null) {\n    return 4\n  }\n  if (typeof value === 'string') {\n    return value.length + 2 // +2 for the quotes\n  }\n\n  if (typeof value === 'object') {\n    return (\n      getLongestLine(`${key}: ${stripAnsi(stringifiedValue)}`) - indent.length\n    )\n  }\n\n  return String(value).length\n}\n\nfunction getLongestLine(str: string): number {\n  return str\n    .split('\\n')\n    .reduce((max, curr) => (curr.length > max ? curr.length : max), 0)\n}\n\nfunction prefixLines(str: string, indent: string, prefix: string): string {\n  return str\n    .split('\\n')\n    .map((line, index, arr) =>\n      index === 0\n        ? prefix + indent.slice(1) + line\n        : index < arr.length - 1\n        ? prefix + line.slice(1)\n        : line,\n    )\n    .map((line) => {\n      // we need to use a special token to \"mark\" a line a \"to be dimmed\", as chalk (or rather ansi) doesn't allow nesting of dimmed & colored content\n      return stripAnsi(line).includes(DIM_TOKEN)\n        ? chalk.dim(line.replace(DIM_TOKEN, ''))\n        : line.includes('?')\n        ? chalk.dim(line)\n        : line\n    })\n    .join('\\n')\n}\n", "'use strict'\nconst isRegexp = require('is-regexp')\nconst isObj = require('is-obj')\nconst getOwnEnumPropSymbols = require('get-own-enumerable-property-symbols')\n  .default\n\n// Fork of https://github.com/yeoman/stringify-object/blob/master/index.js\n// with possibility to overwrite the whole key-value pair (options.transformLine)\n\n/* tslint:disable */\n\nconst stringifyObject = (input, options?: any, pad?: any) => {\n  const seen: any[] = []\n\n  return (function stringifyObject(input, options = {}, pad = '', path = []) {\n    options.indent = options.indent || '\\t'\n\n    let tokens\n\n    if (options.inlineCharacterLimit === undefined) {\n      tokens = {\n        newLine: '\\n',\n        newLineOrSpace: '\\n',\n        pad,\n        indent: pad + options.indent,\n      }\n    } else {\n      tokens = {\n        newLine: '@@__STRINGIFY_OBJECT_NEW_LINE__@@',\n        newLineOrSpace: '@@__STRINGIFY_OBJECT_NEW_LINE_OR_SPACE__@@',\n        pad: '@@__STRINGIFY_OBJECT_PAD__@@',\n        indent: '@@__STRINGIFY_OBJECT_INDENT__@@',\n      }\n    }\n\n    const expandWhiteSpace = (string) => {\n      if (options.inlineCharacterLimit === undefined) {\n        return string\n      }\n\n      const oneLined = string\n        .replace(new RegExp(tokens.newLine, 'g'), '')\n        .replace(new RegExp(tokens.newLineOrSpace, 'g'), ' ')\n        .replace(new RegExp(tokens.pad + '|' + tokens.indent, 'g'), '')\n\n      if (oneLined.length <= options.inlineCharacterLimit) {\n        return oneLined\n      }\n\n      return string\n        .replace(\n          new RegExp(tokens.newLine + '|' + tokens.newLineOrSpace, 'g'),\n          '\\n',\n        )\n        .replace(new RegExp(tokens.pad, 'g'), pad)\n        .replace(new RegExp(tokens.indent, 'g'), pad + options.indent)\n    }\n\n    if (seen.indexOf(input) !== -1) {\n      return '\"[Circular]\"'\n    }\n\n    if (Buffer.isBuffer(input)) {\n      return `Buffer(${Buffer.length})`\n    }\n\n    if (\n      input === null ||\n      input === undefined ||\n      typeof input === 'number' ||\n      typeof input === 'boolean' ||\n      typeof input === 'function' ||\n      typeof input === 'symbol' ||\n      isRegexp(input)\n    ) {\n      return String(input)\n    }\n\n    if (input instanceof Date) {\n      return `new Date('${input.toISOString()}')`\n    }\n\n    if (Array.isArray(input)) {\n      if (input.length === 0) {\n        return '[]'\n      }\n\n      seen.push(input)\n\n      const ret =\n        '[' +\n        tokens.newLine +\n        input\n          .map((el, i) => {\n            const eol =\n              input.length - 1 === i\n                ? tokens.newLine\n                : ',' + tokens.newLineOrSpace\n\n            let value = stringifyObject(el, options, pad + options.indent, [\n              ...path,\n              i,\n            ] as any)\n            if (options.transformValue) {\n              value = options.transformValue(input, i, value)\n            }\n\n            return tokens.indent + value + eol\n          })\n          .join('') +\n        tokens.pad +\n        ']'\n\n      seen.pop()\n\n      return expandWhiteSpace(ret)\n    }\n\n    if (isObj(input)) {\n      let objKeys = Object.keys(input).concat(getOwnEnumPropSymbols(input))\n\n      if (options.filter) {\n        objKeys = objKeys.filter((el) => options.filter(input, el))\n      }\n\n      if (objKeys.length === 0) {\n        return '{}'\n      }\n\n      seen.push(input)\n\n      const ret =\n        '{' +\n        tokens.newLine +\n        objKeys\n          .map((el, i) => {\n            const eol =\n              objKeys.length - 1 === i\n                ? tokens.newLine\n                : ',' + tokens.newLineOrSpace\n            const isSymbol = typeof el === 'symbol'\n            const isClassic = !isSymbol && /^[a-z$_][a-z$_0-9]*$/i.test(el)\n            const key =\n              isSymbol || isClassic\n                ? el\n                : stringifyObject(el, options, undefined, [...path, el] as any)\n\n            let value = stringifyObject(\n              input[el],\n              options,\n              pad + options.indent,\n              [...path, el] as any,\n            )\n            if (options.transformValue) {\n              value = options.transformValue(input, el, value)\n            }\n\n            let line = tokens.indent + String(key) + ': ' + value + eol\n\n            if (options.transformLine) {\n              line = options.transformLine({\n                obj: input,\n                indent: tokens.indent,\n                key,\n                stringifiedValue: value,\n                value: input[el],\n                eol,\n                originalLine: line,\n                path: path.concat(key),\n              })\n            }\n\n            return line\n          })\n          .join('') +\n        tokens.pad +\n        '}'\n\n      seen.pop()\n\n      return expandWhiteSpace(ret)\n    }\n\n    input = String(input).replace(/[\\r\\n]/g, (x) =>\n      x === '\\n' ? '\\\\n' : '\\\\r',\n    )\n\n    if (options.singleQuotes === false) {\n      input = input.replace(/\"/g, '\\\\\"')\n      return `\"${input}\"`\n    }\n\n    input = input.replace(/\\\\?'/g, \"\\\\'\")\n    return `'${input}'`\n  })(input, options, pad)\n}\n\nexport default stringifyObject\n", "import chalk from 'chalk'\nimport stripAnsi from 'strip-ansi'\nimport { deepSet } from './deep-set'\nimport stringifyObject from './stringifyObject'\n\nexport interface MissingItem {\n  path: string\n  isRequired: boolean\n  type: string | object\n}\n\nconst DIM_TOKEN = '@@__DIM_POINTER__@@'\n\nexport type PrintJsonWithErrorsArgs = {\n  ast: object\n  keyPaths: string[]\n  valuePaths: string[]\n  missingItems: MissingItem[]\n}\n\nexport function printJsonWithErrors({\n  ast,\n  keyPaths,\n  valuePaths,\n  missingItems,\n}: PrintJsonWithErrorsArgs) {\n  let obj = ast\n  for (const { path, type } of missingItems) {\n    obj = deepSet(obj, path, type)\n  }\n\n  return stringifyObject(obj, {\n    indent: '  ',\n    transformLine: ({ indent, key, value, stringifiedValue, eol, path }) => {\n      const dottedPath = path.join('.')\n      const keyError = keyPaths.includes(dottedPath)\n      const valueError = valuePaths.includes(dottedPath)\n      const missingItem = missingItems.find((item) => item.path === dottedPath)\n\n      let valueStr = stringifiedValue\n\n      if (missingItem) {\n        // trim away the '' from the string\n        if (typeof value === 'string') {\n          valueStr = valueStr.slice(1, valueStr.length - 1)\n        }\n        const isRequiredStr = missingItem.isRequired ? '' : '?'\n        const prefix = missingItem.isRequired ? '+' : '?'\n        const color = missingItem.isRequired ? chalk.greenBright : chalk.green\n        let output = color(\n          prefixLines(\n            key + isRequiredStr + ': ' + valueStr + eol,\n            indent,\n            prefix,\n          ),\n        )\n        if (!missingItem.isRequired) {\n          output = chalk.dim(output)\n        }\n        return output\n      } else {\n        const isOnMissingItemPath = missingItems.some((item) =>\n          dottedPath.startsWith(item.path),\n        )\n        const isOptional = key[key.length - 2] === '?'\n        if (isOptional) {\n          key = key.slice(1, key.length - 1)\n        }\n        if (isOptional && typeof value === 'object' && value !== null) {\n          valueStr = valueStr\n            .split('\\n')\n            .map((line, index, arr) =>\n              index === arr.length - 1 ? line + DIM_TOKEN : line,\n            )\n            .join('\\n')\n        }\n        if (isOnMissingItemPath && typeof value === 'string') {\n          valueStr = valueStr.slice(1, valueStr.length - 1)\n          if (!isOptional) {\n            valueStr = chalk.bold(valueStr)\n          }\n        }\n        if (\n          (typeof value !== 'object' || value === null) &&\n          !valueError &&\n          !isOnMissingItemPath\n        ) {\n          valueStr = chalk.dim(valueStr)\n        }\n\n        const keyStr = keyError ? chalk.redBright(key) : key\n        valueStr = valueError ? chalk.redBright(valueStr) : valueStr\n        // valueStr can be multiple lines if it's an object\n        let output =\n          indent +\n          keyStr +\n          ': ' +\n          valueStr +\n          (isOnMissingItemPath ? eol : chalk.dim(eol))\n\n        // if there is an error, add the scribble lines\n        // 3 options:\n        // error in key, but not in value\n        // error in value, but not in key\n        // error in both\n        if (keyError || valueError) {\n          const lines = output.split('\\n')\n          const keyLength = String(key).length\n          const keyScribbles = keyError\n            ? chalk.redBright('~'.repeat(keyLength))\n            : ' '.repeat(keyLength)\n\n          const valueLength = valueError\n            ? getValueLength(indent, key, value, stringifiedValue)\n            : 0\n          const hideValueScribbles = Boolean(\n            valueError && typeof value === 'object' && value !== null,\n          )\n          const valueScribbles = valueError\n            ? '  ' + chalk.redBright('~'.repeat(valueLength))\n            : ''\n\n          // Either insert both keyScribles and valueScribbles in one line\n          if (keyScribbles && keyScribbles.length > 0 && !hideValueScribbles) {\n            lines.splice(1, 0, indent + keyScribbles + valueScribbles)\n          }\n\n          // or the valueScribbles for a multiline string\n          if (keyScribbles && keyScribbles.length > 0 && hideValueScribbles) {\n            lines.splice(\n              lines.length - 1,\n              0,\n              indent.slice(0, indent.length - 2) + valueScribbles,\n            )\n          }\n\n          output = lines.join('\\n')\n        }\n        return output\n      }\n    },\n  })\n}\n\nfunction getValueLength(\n  indent: string,\n  key: string,\n  value: any,\n  stringifiedValue: string,\n) {\n  if (value === null) {\n    return 4\n  }\n  if (typeof value === 'string') {\n    return value.length + 2 // +2 for the quotes\n  }\n\n  if (typeof value === 'object') {\n    return (\n      getLongestLine(`${key}: ${stripAnsi(stringifiedValue)}`) - indent.length\n    )\n  }\n\n  return String(value).length\n}\n\nfunction getLongestLine(str: string): number {\n  return str\n    .split('\\n')\n    .reduce((max, curr) => (curr.length > max ? curr.length : max), 0)\n}\n\nfunction prefixLines(str: string, indent: string, prefix: string): string {\n  return str\n    .split('\\n')\n    .map((line, index, arr) =>\n      index === 0\n        ? prefix + indent.slice(1) + line\n        : index < arr.length - 1\n        ? prefix + line.slice(1)\n        : line,\n    )\n    .map((line) => {\n      // we need to use a special token to \"mark\" a line a \"to be dimmed\", as chalk (or rather ansi) doesn't allow nesting of dimmed & colored content\n      return stripAnsi(line).includes(DIM_TOKEN)\n        ? chalk.dim(line.replace(DIM_TOKEN, ''))\n        : line.includes('?')\n        ? chalk.dim(line)\n        : line\n    })\n    .join('\\n')\n}\n", "import chalk from 'chalk'\nimport * as stackTraceParser from 'stacktrace-parser'\nimport { highlightTS } from '../highlight/highlight'\nimport { dedent } from './dedent'\n\nfunction renderN(n: number, max: number): string {\n  const wantedLetters = String(max).length\n  const hasLetters = String(n).length\n  if (hasLetters >= wantedLetters) {\n    return String(n)\n  }\n\n  return ' '.repeat(wantedLetters - hasLetters) + n\n}\n\nexport interface ErrorArgs {\n  callsite?: string\n  originalMethod: string\n  onUs?: boolean // is this on us or is it a user error?\n  showColors?: boolean\n  renderPathRelative?: boolean\n  printFullStack?: boolean\n  isValidationError?: boolean\n}\n\nexport interface PrintStackResult {\n  stack: string\n  indent: number\n  lastErrorHeight: number\n  afterLines: string\n}\n\nexport const printStack = ({\n  callsite,\n  originalMethod,\n  onUs,\n  showColors,\n  renderPathRelative,\n  printFullStack,\n  isValidationError,\n}: ErrorArgs): PrintStackResult => {\n  const lastErrorHeight = 20\n  let callsiteStr = ':'\n  let prevLines = '\\n'\n  let afterLines = ''\n  let indentValue = 0\n  let functionName = `prisma.${originalMethod}()`\n\n  // @ts-ignore\n  if (callsite && typeof window === 'undefined') {\n    const stack = stackTraceParser.parse(callsite)\n    // TODO: more resilient logic to check that it's not relative to cwd\n    const trace = stack.find((t, i) => {\n      if (i < 3) {\n        // the first few function calls can always be ignored\n        if (t.methodName.includes('Object.')) {\n          return false\n        }\n      }\n      return (\n        t.file &&\n        !t.file.includes('@prisma') &&\n        !t.file.includes('getPrismaClient') &&\n        !t.methodName.includes('new ') &&\n        !t.methodName.includes('_getCallsite') &&\n        t.methodName.split('.').length < 4\n      )\n    })\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      trace &&\n      trace.file &&\n      trace.lineNumber &&\n      trace.column &&\n      !trace.file.startsWith('internal/')\n    ) {\n      const lineNumber = trace.lineNumber\n      const printedFileName = renderPathRelative\n        ? require('path').relative(process.cwd(), trace.file)\n        : trace.file\n      callsiteStr = callsite\n        ? ` in\\n${chalk.underline(\n            `${printedFileName}:${trace.lineNumber}:${trace.column}`,\n          )}`\n        : ''\n      const height = process.stdout.rows || 20\n      const start = Math.max(0, lineNumber - 5)\n      const neededHeight = lastErrorHeight + lineNumber - start\n\n      if (height > neededHeight || printFullStack) {\n        const fs = require('fs')\n        const exists = fs.existsSync(trace.file)\n        if (exists) {\n          const file = fs.readFileSync(trace.file, 'utf-8')\n          const slicedFile = file\n            .split('\\n')\n            .slice(start, lineNumber)\n            .join('\\n')\n          const lines = dedent(slicedFile).split('\\n')\n\n          const theLine = lines[lines.length - 1]\n          if (!theLine || theLine.trim() === '') {\n            callsiteStr = ':'\n          } else {\n            // Why even all this effort? Because if a user calls the client instance \"db\", we want to be able to also say \"db.user.findMany\"\n            const prismaClientRegex = /(\\S+(create|updateMany|deleteMany|update|delete|findMany|findOne)\\()/\n            const match = theLine.match(prismaClientRegex)\n            if (match) {\n              functionName = `${match[1]})`\n            }\n            const slicePoint = theLine.indexOf('{')\n            const linesToHighlight = lines\n              .map((l, i, all) =>\n                !onUs && i === all.length - 1\n                  ? l.slice(0, slicePoint > -1 ? slicePoint : l.length - 1)\n                  : l,\n              )\n              .join('\\n')\n\n            const highlightedLines = showColors\n              ? highlightTS(linesToHighlight).split('\\n')\n              : linesToHighlight.split('\\n')\n\n            prevLines =\n              '\\n' +\n              highlightedLines\n                .map(\n                  (l, i) =>\n                    chalk.grey(\n                      renderN(i + start + 1, lineNumber + start + 1) + ' ',\n                    ) +\n                    chalk.reset() +\n                    l,\n                )\n                .map((l, i, arr) =>\n                  i === arr.length - 1\n                    ? `${chalk.red.bold('\u2192')} ${chalk.dim(l)}`\n                    : chalk.dim('  ' + l),\n                )\n                .join('\\n')\n            if (!match && !isValidationError) {\n              prevLines += '\\n\\n'\n            }\n            afterLines = ')'\n            indentValue =\n              String(lineNumber + start + 1).length +\n              getIndent(theLine) +\n              1 +\n              (match ? 2 : 0)\n          }\n        }\n      }\n    }\n  }\n\n  function getIndent(line: string): number {\n    let spaceCount = 0\n    for (let i = 0; i < line.length; i++) {\n      if (line.charAt(i) !== ' ') {\n        return spaceCount\n      }\n      spaceCount++\n    }\n\n    return spaceCount\n  }\n\n  const introText = onUs\n    ? chalk.red(`Oops, an unknown error occured! This is ${chalk.bold(\n        'on us',\n      )}, you did nothing wrong.\nIt occured in the ${chalk.bold(\n        `\\`${functionName}\\``,\n      )} invocation${callsiteStr}`)\n    : chalk.red(\n        `Invalid ${chalk.bold(`\\`${functionName}\\``)} invocation${callsiteStr}`,\n      )\n\n  const stackStr = `\\n${introText}\n${prevLines}${chalk.reset()}`\n\n  return { indent: indentValue, stack: stackStr, afterLines, lastErrorHeight }\n}\n", "import chalk from 'chalk'\nimport { Theme } from './types'\n\nexport const orange = chalk.rgb(246, 145, 95)\nexport const darkBrightBlue = chalk.rgb(107, 139, 140)\nexport const blue = chalk.cyan\nexport const brightBlue = chalk.rgb(127, 155, 155)\nexport const identity = (str) => str\n\nexport const theme: Theme = {\n  keyword: blue,\n  entity: blue,\n  value: brightBlue,\n  punctuation: darkBrightBlue,\n  directive: blue,\n  function: blue,\n  variable: brightBlue,\n  string: chalk.greenBright,\n  boolean: orange,\n  number: chalk.cyan,\n  comment: chalk.grey,\n}\n", "import { identity, theme } from './theme'\n\n/* tslint:disable */\n\n/* **********************************************\n     Begin prism-core.js\n********************************************** */\n\nvar _self: any = {}\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n * MIT license http://www.opensource.org/licenses/mit-license.php/\n * @author Lea Verou http://lea.verou.me\n */\n\n// Private helper vars\nvar uniqueId = 0\n\nexport var Prism: any = {\n  manual: _self.Prism && _self.Prism.manual,\n  disableWorkerMessageHandler:\n    _self.Prism && _self.Prism.disableWorkerMessageHandler,\n  util: {\n    encode: function (tokens: any) {\n      if (tokens instanceof Token) {\n        const anyTokens: any = tokens\n        return new Token(\n          anyTokens.type,\n          Prism.util.encode(anyTokens.content),\n          anyTokens.alias,\n        )\n      } else if (Array.isArray(tokens)) {\n        return tokens.map(Prism.util.encode)\n      } else {\n        return tokens\n          .replace(/&/g, '&amp;')\n          .replace(/</g, '&lt;')\n          .replace(/\\u00a0/g, ' ')\n      }\n    },\n\n    type: function (o) {\n      return Object.prototype.toString.call(o).slice(8, -1)\n    },\n\n    objId: function (obj) {\n      if (!obj['__id']) {\n        Object.defineProperty(obj, '__id', { value: ++uniqueId })\n      }\n      return obj['__id']\n    },\n\n    // Deep clone a language definition (e.g. to extend it)\n    clone: function deepClone(o, visited?: any) {\n      var clone,\n        id,\n        type = Prism.util.type(o)\n      visited = visited || {}\n\n      switch (type) {\n        case 'Object':\n          id = Prism.util.objId(o)\n          if (visited[id]) {\n            return visited[id]\n          }\n          clone = {}\n          visited[id] = clone\n\n          for (var key in o) {\n            if (o.hasOwnProperty(key)) {\n              clone[key] = deepClone(o[key], visited)\n            }\n          }\n\n          return clone\n\n        case 'Array':\n          id = Prism.util.objId(o)\n          if (visited[id]) {\n            return visited[id]\n          }\n          clone = []\n          visited[id] = clone\n\n          o.forEach(function (v, i) {\n            clone[i] = deepClone(v, visited)\n          })\n\n          return clone\n\n        default:\n          return o\n      }\n    },\n  },\n\n  languages: {\n    extend: function (id, redef) {\n      var lang = Prism.util.clone(Prism.languages[id])\n\n      for (var key in redef) {\n        lang[key] = redef[key]\n      }\n\n      return lang\n    },\n\n    /**\n     * Insert a token before another token in a language literal\n     * As this needs to recreate the object (we cannot actually insert before keys in object literals),\n     * we cannot just provide an object, we need an object and a key.\n     * @param inside The key (or language id) of the parent\n     * @param before The key to insert before.\n     * @param insert Object with the key/value pairs to insert\n     * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\n     */\n    insertBefore: function (inside, before, insert, root) {\n      root = root || Prism.languages\n      var grammar = root[inside]\n      var ret = {}\n\n      for (var token in grammar) {\n        if (grammar.hasOwnProperty(token)) {\n          if (token == before) {\n            for (var newToken in insert) {\n              if (insert.hasOwnProperty(newToken)) {\n                ret[newToken] = insert[newToken]\n              }\n            }\n          }\n\n          // Do not insert token which also occur in insert. See #1525\n          if (!insert.hasOwnProperty(token)) {\n            ret[token] = grammar[token]\n          }\n        }\n      }\n\n      var old = root[inside]\n      root[inside] = ret\n\n      // Update references in other language definitions\n      Prism.languages.DFS(Prism.languages, function (this: any, key, value) {\n        if (value === old && key != inside) {\n          this[key] = ret\n        }\n      })\n\n      return ret\n    },\n\n    // Traverse a language definition with Depth First Search\n    DFS: function DFS(o, callback, type?: any, visited?: any) {\n      visited = visited || {}\n\n      var objId = Prism.util.objId\n\n      for (var i in o) {\n        if (o.hasOwnProperty(i)) {\n          callback.call(o, i, o[i], type || i)\n\n          var property = o[i],\n            propertyType = Prism.util.type(property)\n\n          if (propertyType === 'Object' && !visited[objId(property)]) {\n            visited[objId(property)] = true\n            DFS(property, callback, null, visited)\n          } else if (propertyType === 'Array' && !visited[objId(property)]) {\n            visited[objId(property)] = true\n            DFS(property, callback, i, visited)\n          }\n        }\n      }\n    },\n  },\n  plugins: {},\n\n  highlight: function (text, grammar, language) {\n    var env: any = {\n      code: text,\n      grammar: grammar,\n      language: language,\n    }\n    Prism.hooks.run('before-tokenize', env)\n    env.tokens = Prism.tokenize(env.code, env.grammar)\n    Prism.hooks.run('after-tokenize', env)\n    return Token.stringify(Prism.util.encode(env.tokens), env.language)\n  },\n\n  matchGrammar: function (\n    text,\n    strarr,\n    grammar,\n    index,\n    startPos,\n    oneshot,\n    target?: any,\n  ) {\n    for (var token in grammar) {\n      if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n        continue\n      }\n\n      if (token == target) {\n        return\n      }\n\n      var patterns = grammar[token]\n      patterns = Prism.util.type(patterns) === 'Array' ? patterns : [patterns]\n\n      for (var j = 0; j < patterns.length; ++j) {\n        var pattern = patterns[j],\n          inside = pattern.inside,\n          lookbehind = !!pattern.lookbehind,\n          greedy = !!pattern.greedy,\n          lookbehindLength = 0,\n          alias = pattern.alias\n\n        if (greedy && !pattern.pattern.global) {\n          // Without the global flag, lastIndex won't work\n          var flags = pattern.pattern.toString().match(/[imuy]*$/)[0]\n          pattern.pattern = RegExp(pattern.pattern.source, flags + 'g')\n        }\n\n        pattern = pattern.pattern || pattern\n\n        // Don\u2019t cache length as it changes during the loop\n        for (\n          var i = index, pos = startPos;\n          i < strarr.length;\n          pos += strarr[i].length, ++i\n        ) {\n          var str = strarr[i]\n\n          if (strarr.length > text.length) {\n            // Something went terribly wrong, ABORT, ABORT!\n            return\n          }\n\n          if (str instanceof Token) {\n            continue\n          }\n\n          if (greedy && i != strarr.length - 1) {\n            pattern.lastIndex = pos\n            var match = pattern.exec(text)\n            if (!match) {\n              break\n            }\n\n            var from = match.index + (lookbehind ? match[1].length : 0),\n              to = match.index + match[0].length,\n              k = i,\n              p = pos\n\n            for (\n              var len = strarr.length;\n              k < len && (p < to || (!strarr[k].type && !strarr[k - 1].greedy));\n              ++k\n            ) {\n              p += strarr[k].length\n              // Move the index i to the element in strarr that is closest to from\n              if (from >= p) {\n                ++i\n                pos = p\n              }\n            }\n\n            // If strarr[i] is a Token, then the match starts inside another Token, which is invalid\n            if (strarr[i] instanceof Token) {\n              continue\n            }\n\n            // Number of tokens to delete and replace with the new match\n            delNum = k - i\n            str = text.slice(pos, p)\n            match.index -= pos\n          } else {\n            pattern.lastIndex = 0\n\n            var match = pattern.exec(str),\n              delNum = 1\n          }\n\n          if (!match) {\n            if (oneshot) {\n              break\n            }\n\n            continue\n          }\n\n          if (lookbehind) {\n            lookbehindLength = match[1] ? match[1].length : 0\n          }\n\n          var from = match.index + lookbehindLength,\n            match = match[0].slice(lookbehindLength),\n            to = from + match.length,\n            before = str.slice(0, from),\n            after = str.slice(to)\n\n          var args: any = [i, delNum]\n\n          if (before) {\n            ++i\n            pos += before.length\n            args.push(before)\n          }\n\n          var wrapped = new Token(\n            token,\n            inside ? Prism.tokenize(match, inside) : match,\n            alias,\n            match,\n            greedy,\n          )\n\n          args.push(wrapped)\n\n          if (after) {\n            args.push(after)\n          }\n\n          Array.prototype.splice.apply(strarr, args)\n\n          if (delNum != 1)\n            Prism.matchGrammar(text, strarr, grammar, i, pos, true, token)\n\n          if (oneshot) break\n        }\n      }\n    }\n  },\n\n  tokenize: function (text, grammar) {\n    var strarr = [text]\n\n    var rest = grammar.rest\n\n    if (rest) {\n      for (var token in rest) {\n        grammar[token] = rest[token]\n      }\n\n      delete grammar.rest\n    }\n\n    Prism.matchGrammar(text, strarr, grammar, 0, 0, false)\n\n    return strarr\n  },\n\n  hooks: {\n    all: {},\n\n    add: function (name, callback) {\n      var hooks = Prism.hooks.all\n\n      hooks[name] = hooks[name] || []\n\n      hooks[name].push(callback)\n    },\n\n    run: function (name, env) {\n      var callbacks = Prism.hooks.all[name]\n\n      if (!callbacks || !callbacks.length) {\n        return\n      }\n\n      for (var i = 0, callback; (callback = callbacks[i++]); ) {\n        callback(env)\n      }\n    },\n  },\n\n  Token: Token,\n}\n\nPrism.languages.clike = {\n  comment: [\n    {\n      pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n      lookbehind: true,\n    },\n    {\n      pattern: /(^|[^\\\\:])\\/\\/.*/,\n      lookbehind: true,\n      greedy: true,\n    },\n  ],\n  string: {\n    pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: true,\n  },\n  'class-name': {\n    pattern: /((?:\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[\\w.\\\\]+/i,\n    lookbehind: true,\n    inside: {\n      punctuation: /[.\\\\]/,\n    },\n  },\n  keyword: /\\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\n  boolean: /\\b(?:true|false)\\b/,\n  function: /\\w+(?=\\()/,\n  number: /\\b0x[\\da-f]+\\b|(?:\\b\\d+\\.?\\d*|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n  operator: /--?|\\+\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\|\\|?|\\?|\\*|\\/|~|\\^|%/,\n  punctuation: /[{}[\\];(),.:]/,\n}\n\nPrism.languages.javascript = Prism.languages.extend('clike', {\n  'class-name': [\n    Prism.languages.clike['class-name'],\n    {\n      pattern: /(^|[^$\\w\\xA0-\\uFFFF])[_$A-Z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\.(?:prototype|constructor))/,\n      lookbehind: true,\n    },\n  ],\n  keyword: [\n    {\n      pattern: /((?:^|})\\s*)(?:catch|finally)\\b/,\n      lookbehind: true,\n    },\n    {\n      pattern: /(^|[^.])\\b(?:as|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n      lookbehind: true,\n    },\n  ],\n  number: /\\b(?:(?:0[xX](?:[\\dA-Fa-f](?:_[\\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\\d(?:_\\d)?)+n|NaN|Infinity)\\b|(?:\\b(?:\\d(?:_\\d)?)+\\.?(?:\\d(?:_\\d)?)*|\\B\\.(?:\\d(?:_\\d)?)+)(?:[Ee][+-]?(?:\\d(?:_\\d)?)+)?/,\n  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n  function: /[_$a-zA-Z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n  operator: /-[-=]?|\\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\\|[|=]?|\\*\\*?=?|\\/=?|~|\\^=?|%=?|\\?|\\.{3}/,\n})\n\nPrism.languages.javascript[\n  'class-name'\n][0].pattern = /(\\b(?:class|interface|extends|implements|instanceof|new)\\s+)[\\w.\\\\]+/\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n  regex: {\n    pattern: /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s])\\s*)\\/(\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[gimyus]{0,6}(?=\\s*($|[\\r\\n,.;})\\]]))/,\n    lookbehind: true,\n    greedy: true,\n  },\n  // This must be declared before keyword because we use \"function\" inside the look-forward\n  'function-variable': {\n    pattern: /[_$a-zA-Z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|[_$a-zA-Z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*)\\s*=>))/,\n    alias: 'function',\n  },\n  parameter: [\n    {\n      pattern: /(function(?:\\s+[_$A-Za-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*)?\\s*\\(\\s*)(?!\\s)(?:[^()]|\\([^()]*\\))+?(?=\\s*\\))/,\n      lookbehind: true,\n      inside: Prism.languages.javascript,\n    },\n    {\n      pattern: /[_$a-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*=>)/i,\n      inside: Prism.languages.javascript,\n    },\n    {\n      pattern: /(\\(\\s*)(?!\\s)(?:[^()]|\\([^()]*\\))+?(?=\\s*\\)\\s*=>)/,\n      lookbehind: true,\n      inside: Prism.languages.javascript,\n    },\n    {\n      pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:[_$A-Za-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*\\s*)\\(\\s*)(?!\\s)(?:[^()]|\\([^()]*\\))+?(?=\\s*\\)\\s*\\{)/,\n      lookbehind: true,\n      inside: Prism.languages.javascript,\n    },\n  ],\n  constant: /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/,\n})\n\nif (Prism.languages.markup) {\n  Prism.languages.markup.tag.addInlined('script', 'javascript')\n}\n\nPrism.languages.js = Prism.languages.javascript\n\nPrism.languages.typescript = Prism.languages.extend('javascript', {\n  // From JavaScript Prism keyword list and TypeScript language spec: https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#221-reserved-words\n  keyword: /\\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\\b/,\n  builtin: /\\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\\b/,\n})\n\nPrism.languages.ts = Prism.languages.typescript\n\nexport function Token(\n  this: any,\n  type,\n  content,\n  alias,\n  matchedStr?: any,\n  greedy?: any,\n) {\n  this.type = type\n  this.content = content\n  this.alias = alias\n  // Copy of the full string this token was created from\n  this.length = (matchedStr || '').length | 0\n  this.greedy = !!greedy\n}\n\nToken.stringify = function (o, language?: any) {\n  if (typeof o == 'string') {\n    return o\n  }\n\n  if (Array.isArray(o)) {\n    return o\n      .map(function (element) {\n        return Token.stringify(element, language)\n      })\n      .join('')\n  }\n\n  return getColorForSyntaxKind(o.type)(o.content)\n}\n\nfunction getColorForSyntaxKind(syntaxKind: string) {\n  return theme[syntaxKind] || identity\n}\n", "import { Prism, Token } from './prism'\nimport { SyntaxDefinition } from './types'\n\nexport function highlightTS(str: string) {\n  return highlight(str, Prism.languages.javascript)\n}\n\nfunction highlight(str: string, grammar: SyntaxDefinition) {\n  const tokens = Prism.tokenize(str, grammar)\n  return tokens.map((t) => Token.stringify(t)).join('')\n}\n", "import strip from 'strip-indent'\nexport function dedent(str: string): string {\n  return strip(str)\n}\n", "import chalk from 'chalk'\nimport * as stackTraceParser from 'stacktrace-parser'\nimport { highlightTS } from '../highlight/highlight'\nimport { dedent } from './dedent'\n\nfunction renderN(n: number, max: number): string {\n  const wantedLetters = String(max).length\n  const hasLetters = String(n).length\n  if (hasLetters >= wantedLetters) {\n    return String(n)\n  }\n\n  return ' '.repeat(wantedLetters - hasLetters) + n\n}\n\nexport interface ErrorArgs {\n  callsite?: string\n  originalMethod: string\n  onUs?: boolean // is this on us or is it a user error?\n  showColors?: boolean\n  renderPathRelative?: boolean\n  printFullStack?: boolean\n  isValidationError?: boolean\n}\n\nexport interface PrintStackResult {\n  stack: string\n  indent: number\n  lastErrorHeight: number\n  afterLines: string\n}\n\nexport const printStack = ({\n  callsite,\n  originalMethod,\n  onUs,\n  showColors,\n  renderPathRelative,\n  printFullStack,\n  isValidationError,\n}: ErrorArgs): PrintStackResult => {\n  const lastErrorHeight = 20\n  let callsiteStr = ':'\n  let prevLines = '\\n'\n  let afterLines = ''\n  let indentValue = 0\n  let functionName = `prisma.${originalMethod}()`\n\n  // @ts-ignore\n  if (callsite && typeof window === 'undefined') {\n    const stack = stackTraceParser.parse(callsite)\n    // TODO: more resilient logic to check that it's not relative to cwd\n    const trace = stack.find((t, i) => {\n      if (i < 3) {\n        // the first few function calls can always be ignored\n        if (t.methodName.includes('Object.')) {\n          return false\n        }\n      }\n      return (\n        t.file &&\n        !t.file.includes('@prisma') &&\n        !t.file.includes('getPrismaClient') &&\n        !t.methodName.includes('new ') &&\n        !t.methodName.includes('_getCallsite') &&\n        t.methodName.split('.').length < 4\n      )\n    })\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      trace &&\n      trace.file &&\n      trace.lineNumber &&\n      trace.column &&\n      !trace.file.startsWith('internal/')\n    ) {\n      const lineNumber = trace.lineNumber\n      const printedFileName = renderPathRelative\n        ? require('path').relative(process.cwd(), trace.file)\n        : trace.file\n      callsiteStr = callsite\n        ? ` in\\n${chalk.underline(\n            `${printedFileName}:${trace.lineNumber}:${trace.column}`,\n          )}`\n        : ''\n      const height = process.stdout.rows || 20\n      const start = Math.max(0, lineNumber - 5)\n      const neededHeight = lastErrorHeight + lineNumber - start\n\n      if (height > neededHeight || printFullStack) {\n        const fs = require('fs')\n        const exists = fs.existsSync(trace.file)\n        if (exists) {\n          const file = fs.readFileSync(trace.file, 'utf-8')\n          const slicedFile = file\n            .split('\\n')\n            .slice(start, lineNumber)\n            .join('\\n')\n          const lines = dedent(slicedFile).split('\\n')\n\n          const theLine = lines[lines.length - 1]\n          if (!theLine || theLine.trim() === '') {\n            callsiteStr = ':'\n          } else {\n            // Why even all this effort? Because if a user calls the client instance \"db\", we want to be able to also say \"db.user.findMany\"\n            const prismaClientRegex = /(\\S+(create|updateMany|deleteMany|update|delete|findMany|findOne)\\()/\n            const match = theLine.match(prismaClientRegex)\n            if (match) {\n              functionName = `${match[1]})`\n            }\n            const slicePoint = theLine.indexOf('{')\n            const linesToHighlight = lines\n              .map((l, i, all) =>\n                !onUs && i === all.length - 1\n                  ? l.slice(0, slicePoint > -1 ? slicePoint : l.length - 1)\n                  : l,\n              )\n              .join('\\n')\n\n            const highlightedLines = showColors\n              ? highlightTS(linesToHighlight).split('\\n')\n              : linesToHighlight.split('\\n')\n\n            prevLines =\n              '\\n' +\n              highlightedLines\n                .map(\n                  (l, i) =>\n                    chalk.grey(\n                      renderN(i + start + 1, lineNumber + start + 1) + ' ',\n                    ) +\n                    chalk.reset() +\n                    l,\n                )\n                .map((l, i, arr) =>\n                  i === arr.length - 1\n                    ? `${chalk.red.bold('\u2192')} ${chalk.dim(l)}`\n                    : chalk.dim('  ' + l),\n                )\n                .join('\\n')\n            if (!match && !isValidationError) {\n              prevLines += '\\n\\n'\n            }\n            afterLines = ')'\n            indentValue =\n              String(lineNumber + start + 1).length +\n              getIndent(theLine) +\n              1 +\n              (match ? 2 : 0)\n          }\n        }\n      }\n    }\n  }\n\n  function getIndent(line: string): number {\n    let spaceCount = 0\n    for (let i = 0; i < line.length; i++) {\n      if (line.charAt(i) !== ' ') {\n        return spaceCount\n      }\n      spaceCount++\n    }\n\n    return spaceCount\n  }\n\n  const introText = onUs\n    ? chalk.red(`Oops, an unknown error occured! This is ${chalk.bold(\n        'on us',\n      )}, you did nothing wrong.\nIt occured in the ${chalk.bold(\n        `\\`${functionName}\\``,\n      )} invocation${callsiteStr}`)\n    : chalk.red(\n        `Invalid ${chalk.bold(`\\`${functionName}\\``)} invocation${callsiteStr}`,\n      )\n\n  const stackStr = `\\n${introText}\n${prevLines}${chalk.reset()}`\n\n  return { indent: indentValue, stack: stackStr, afterLines, lastErrorHeight }\n}\n", "import chalk from 'chalk'\nimport indent from 'indent-string'\nimport { /*dmmf, */ DMMFClass } from './dmmf'\nimport { DMMF } from './dmmf-types'\nimport {\n  ArgError,\n  AtLeastOneError,\n  AtMostOneError,\n  FieldError,\n  InvalidArgError,\n  InvalidFieldError,\n  MissingArgError,\n} from './error-types'\nimport {\n  getGraphQLType,\n  getInputTypeName,\n  getOutputTypeName,\n  getSuggestion,\n  inputTypeToJson,\n  stringifyGraphQLType,\n  stringifyInputType,\n  unionBy,\n  wrapWithList,\n} from './utils/common'\nimport { deepExtend } from './utils/deep-extend'\nimport { deepGet } from './utils/deep-set'\nimport { filterObject } from './utils/filterObject'\nimport { omit } from './utils/omit'\nimport {\n  MissingItem,\n  printJsonWithErrors,\n  PrintJsonWithErrorsArgs,\n} from './utils/printJsonErrors'\nimport { printStack } from './utils/printStack'\nimport stringifyObject from './utils/stringifyObject'\nimport stripAnsi from 'strip-ansi'\nimport { flatMap } from './utils/flatMap'\nimport Decimal from 'decimal.js'\n\nconst tab = 2\n\nexport class Document {\n  constructor(\n    public readonly type: 'query' | 'mutation',\n    public readonly children: Field[],\n  ) {\n    this.type = type\n    this.children = children\n  }\n  public toString() {\n    return `${this.type} {\n${indent(this.children.map(String).join('\\n'), tab)}\n}`\n  }\n  public validate(\n    select?: any,\n    isTopLevelQuery: boolean = false,\n    originalMethod?: string,\n    errorFormat?: 'pretty' | 'minimal' | 'colorless',\n    validationCallsite?: any,\n  ) {\n    if (!select) {\n      select = {}\n    }\n    const invalidChildren = this.children.filter(\n      (child) => child.hasInvalidChild || child.hasInvalidArg,\n    )\n    if (invalidChildren.length === 0) {\n      return\n    }\n\n    const fieldErrors: FieldError[] = []\n    const argErrors: ArgError[] = []\n    const prefix =\n      select && select.select\n        ? 'select'\n        : select.include\n          ? 'include'\n          : undefined\n\n    for (const child of invalidChildren) {\n      const errors = child.collectErrors(prefix)\n      fieldErrors.push(\n        ...errors.fieldErrors.map((e) => ({\n          ...e,\n          path: isTopLevelQuery ? e.path : e.path.slice(1),\n        })),\n      )\n      argErrors.push(\n        ...errors.argErrors.map((e) => ({\n          ...e,\n          path: isTopLevelQuery ? e.path : e.path.slice(1),\n        })),\n      )\n    }\n\n    const topLevelQueryName = this.children[0].name\n    const queryName = isTopLevelQuery ? this.type : topLevelQueryName\n    const keyPaths: string[] = []\n    const valuePaths: string[] = []\n    const missingItems: MissingItem[] = []\n    for (const fieldError of fieldErrors) {\n      const path = this.normalizePath(fieldError.path, select).join('.')\n      if (fieldError.error.type === 'invalidFieldName') {\n        keyPaths.push(path)\n\n        const fieldType = fieldError.error.outputType\n        const { isInclude } = fieldError.error\n        fieldType.fields\n          .filter((field) =>\n            isInclude ? field.outputType.kind === 'object' : true,\n          )\n          .forEach((field) => {\n            const splittedPath = path.split('.')\n            missingItems.push({\n              path: `${splittedPath\n                .slice(0, splittedPath.length - 1)\n                .join('.')}.${field.name}`,\n              type: 'true',\n              isRequired: false,\n            })\n          })\n      } else if (fieldError.error.type === 'includeAndSelect') {\n        keyPaths.push('select')\n        keyPaths.push('include')\n      } else {\n        valuePaths.push(path)\n      }\n      if (\n        fieldError.error.type === 'emptySelect' ||\n        fieldError.error.type === 'noTrueSelect' ||\n        fieldError.error.type === 'emptyInclude'\n      ) {\n        const selectPathArray = this.normalizePath(fieldError.path, select)\n        const selectPath = selectPathArray\n          .slice(0, selectPathArray.length - 1)\n          .join('.')\n\n        const fieldType = fieldError.error.field.outputType\n          .type as DMMF.OutputType\n\n        fieldType.fields\n          .filter((field) =>\n            fieldError.error.type === 'emptyInclude'\n              ? field.outputType.kind === 'object'\n              : true,\n          )\n          .forEach((field) => {\n            missingItems.push({\n              path: `${selectPath}.${field.name}`,\n              type: 'true',\n              isRequired: false,\n            })\n          })\n      }\n    }\n    // an arg error can either be an invalid key or invalid value\n    for (const argError of argErrors) {\n      const path = this.normalizePath(argError.path, select).join('.')\n      if (argError.error.type === 'invalidName') {\n        keyPaths.push(path)\n      } else if (\n        argError.error.type !== 'missingArg' &&\n        argError.error.type !== 'atLeastOne'\n      ) {\n        valuePaths.push(path)\n      } else if (argError.error.type === 'missingArg') {\n        const type =\n          argError.error.missingArg.inputTypes.length === 1\n            ? argError.error.missingArg.inputTypes[0].type\n            : argError.error.missingArg.inputTypes\n              .map((t) => {\n                const inputTypeName = getInputTypeName(t.type)\n                if (inputTypeName === 'Null') {\n                  return 'null'\n                }\n                if (t.isList) {\n                  return inputTypeName + '[]'\n                }\n                return inputTypeName\n              })\n              .join(' | ')\n        missingItems.push({\n          path,\n          type: inputTypeToJson(type, true, path.split('where.').length === 2),\n          isRequired: argError.error.missingArg.isRequired\n        })\n      }\n    }\n\n    const renderErrorStr = (callsite?: string) => {\n      const hasRequiredMissingArgsErrors = argErrors.some(\n        (e) =>\n          e.error.type === 'missingArg' && e.error.missingArg.isRequired,\n      )\n      const hasOptionalMissingArgsErrors = Boolean(argErrors.find(\n        (e) =>\n          e.error.type === 'missingArg' && !e.error.missingArg.isRequired,\n      ))\n      const hasMissingArgsErrors =\n        hasOptionalMissingArgsErrors || hasRequiredMissingArgsErrors\n\n      let missingArgsLegend = ''\n      if (hasRequiredMissingArgsErrors) {\n        missingArgsLegend += `\\n${chalk.dim(\n          'Note: Lines with ',\n        )}${chalk.reset.greenBright('+')} ${chalk.dim('are required')}`\n      }\n\n      if (hasOptionalMissingArgsErrors) {\n        if (missingArgsLegend.length === 0) {\n          missingArgsLegend = '\\n'\n        }\n        if (hasRequiredMissingArgsErrors) {\n          missingArgsLegend += chalk.dim(\n            `, lines with ${chalk.green('?')} are optional`,\n          )\n        } else {\n          missingArgsLegend += chalk.dim(\n            `Note: Lines with ${chalk.green('?')} are optional`,\n          )\n        }\n        missingArgsLegend += chalk.dim('.')\n      }\n\n      const errorMessages = `${argErrors\n        .filter(\n          (e) =>\n            e.error.type !== 'missingArg' || e.error.missingArg.isRequired,\n        )\n        .map((e) =>\n          this.printArgError(\n            e,\n            hasMissingArgsErrors,\n            errorFormat === 'minimal',\n          ),\n        ) // if no callsite is provided, just render the minimal error\n        .join('\\n')}\n${fieldErrors\n          .map((e) => this.printFieldError(e, missingItems, errorFormat === 'minimal'))\n          .join('\\n')}`\n\n      if (errorFormat === 'minimal') {\n        return stripAnsi(errorMessages)\n      }\n\n      const { stack, indent: indentValue, afterLines } = printStack({\n        callsite,\n        originalMethod: originalMethod || queryName,\n        showColors: errorFormat && errorFormat === 'pretty',\n        isValidationError: true,\n      })\n\n      let printJsonArgs: PrintJsonWithErrorsArgs = {\n        ast: isTopLevelQuery ? { [topLevelQueryName]: select } : select,\n        keyPaths,\n        valuePaths,\n        missingItems,\n      }\n\n      // as for aggregate we simplify the api to not include `select`\n      // we need to map this here so the errors make sense\n      if (originalMethod?.endsWith('aggregate')) {\n        printJsonArgs = transformAggregatePrintJsonArgs(printJsonArgs)\n      }\n\n      const errorStr = `${stack}${indent(\n        printJsonWithErrors(printJsonArgs),\n        indentValue,\n      ).slice(indentValue)}${chalk.dim(afterLines)}\n\n${errorMessages}${missingArgsLegend}\\n`\n\n      if (process.env.NO_COLOR || errorFormat === 'colorless') {\n        return stripAnsi(errorStr)\n      }\n      return errorStr\n    }\n    // end renderErrorStr definition\n\n    const error = new PrismaClientValidationError(\n      renderErrorStr(validationCallsite),\n    )\n\n    // @ts-ignore\n    if (process.env.NODE_ENV !== 'production') {\n      Object.defineProperty(error, 'render', {\n        get: () => renderErrorStr,\n        enumerable: false,\n      })\n    }\n    throw error\n  }\n  protected printFieldError = (\n    { error, path }: FieldError,\n    missingItems: MissingItem[],\n    minimal: boolean,\n  ) => {\n    if (error.type === 'emptySelect') {\n      const additional = minimal\n        ? ''\n        : ` Available options are listed in ${chalk.greenBright.dim('green')}.`\n      return `The ${chalk.redBright(\n        '`select`',\n      )} statement for type ${chalk.bold(\n        getOutputTypeName(error.field.outputType.type),\n      )} must not be empty.${additional}`\n    }\n    if (error.type === 'emptyInclude') {\n      if (missingItems.length === 0) {\n        return `${chalk.bold(\n          getOutputTypeName(error.field.outputType.type),\n        )} does not have any relation and therefore can't have an ${chalk.redBright(\n          '`include`',\n        )} statement.`\n      }\n      const additional = minimal\n        ? ''\n        : ` Available options are listed in ${chalk.greenBright.dim('green')}.`\n      return `The ${chalk.redBright(\n        '`include`',\n      )} statement for type ${chalk.bold(\n        getOutputTypeName(error.field.outputType.type),\n      )} must not be empty.${additional}`\n    }\n    if (error.type === 'noTrueSelect') {\n      return `The ${chalk.redBright(\n        '`select`',\n      )} statement for type ${chalk.bold(\n        getOutputTypeName(error.field.outputType.type),\n      )} needs ${chalk.bold('at least one truthy value')}.`\n    }\n    if (error.type === 'includeAndSelect') {\n      return `Please ${chalk.bold('either')} use ${chalk.greenBright(\n        '`include`',\n      )} or ${chalk.greenBright('`select`')}, but ${chalk.redBright(\n        'not both',\n      )} at the same time.`\n    }\n    if (error.type === 'invalidFieldName') {\n      const statement = error.isInclude ? 'include' : 'select'\n      const wording = error.isIncludeScalar ? 'Invalid scalar' : 'Unknown'\n      const additional = minimal\n        ? ''\n        : error.isInclude && missingItems.length === 0\n          ? `\\nThis model has no relations, so you can't use ${chalk.redBright(\n            'include',\n          )} with it.`\n          : ` Available options are listed in ${chalk.greenBright.dim('green')}.`\n      let str = `${wording} field ${chalk.redBright(\n        `\\`${error.providedName}\\``,\n      )} for ${chalk.bold(statement)} statement on model ${chalk.bold.white(\n        error.modelName,\n      )}.${additional}`\n\n      if (error.didYouMean) {\n        str += ` Did you mean ${chalk.greenBright(`\\`${error.didYouMean}\\``)}?`\n      }\n\n      if (error.isIncludeScalar) {\n        str += `\\nNote, that ${chalk.bold(\n          'include',\n        )} statements only accept relation fields.`\n      }\n\n      return str\n    }\n    if (error.type === 'invalidFieldType') {\n      const str = `Invalid value ${chalk.redBright(\n        `${stringifyObject(error.providedValue)}`,\n      )} of type ${chalk.redBright(\n        getGraphQLType(error.providedValue, undefined),\n      )} for field ${chalk.bold(\n        `${error.fieldName}`,\n      )} on model ${chalk.bold.white(\n        error.modelName,\n      )}. Expected either ${chalk.greenBright('true')} or ${chalk.greenBright(\n        'false',\n      )}.`\n\n      return str\n    }\n  }\n  protected printArgError = (\n    { error, path }: ArgError,\n    hasMissingItems: boolean,\n    minimal: boolean,\n  ) => {\n    if (error.type === 'invalidName') {\n      let str = `Unknown arg ${chalk.redBright(\n        `\\`${error.providedName}\\``,\n      )} in ${chalk.bold(path.join('.'))} for type ${chalk.bold(\n        error.outputType\n          ? error.outputType.name\n          : getInputTypeName(error.originalType),\n      )}.`\n      if (error.didYouMeanField) {\n        str += `\\n\u2192 Did you forget to wrap it with \\`${chalk.greenBright(\n          'select',\n        )}\\`? ${chalk.dim(\n          'e.g. ' +\n          chalk.greenBright(\n            `{ select: { ${error.providedName}: ${error.providedValue} } }`,\n          ),\n        )}`\n      } else if (error.didYouMeanArg) {\n        str += ` Did you mean \\`${chalk.greenBright(error.didYouMeanArg)}\\`?`\n        if (!hasMissingItems && !minimal) {\n          str +=\n            ` ${chalk.dim('Available args:')}\\n` +\n            stringifyInputType(error.originalType, true)\n        }\n      } else {\n        if ((error.originalType as DMMF.InputType).fields.length === 0) {\n          str += ` The field ${chalk.bold(\n            (error.originalType as DMMF.InputType).name,\n          )} has no arguments.`\n        } else if (!hasMissingItems && !minimal) {\n          str +=\n            ` Available args:\\n\\n` +\n            stringifyInputType(error.originalType, true)\n        }\n      }\n      return str\n    }\n\n    if (error.type === 'invalidType') {\n      let valueStr = stringifyObject(error.providedValue, { indent: '  ' })\n      const multilineValue = valueStr.split('\\n').length > 1\n      if (multilineValue) {\n        valueStr = `\\n${valueStr}\\n`\n      }\n      // TODO: we don't yet support enums in a union with a non enum. This is mostly due to not implemented error handling\n      // at this code part.\n      if (error.requiredType.bestFittingType.kind === 'enum') {\n        return `Argument ${chalk.bold(\n          error.argName,\n        )}: Provided value ${chalk.redBright(valueStr)}${multilineValue ? '' : ' '\n          }of type ${chalk.redBright(\n            getGraphQLType(error.providedValue),\n          )} on ${chalk.bold(\n            `prisma.${this.children[0].name}`,\n          )} is not a ${chalk.greenBright(\n            wrapWithList(\n              stringifyGraphQLType(error.requiredType.bestFittingType.kind),\n              error.requiredType.bestFittingType.isList,\n            ),\n          )}.\n\u2192 Possible values: ${(error.requiredType.bestFittingType\n            .type as DMMF.SchemaEnum).values\n            .map((v) =>\n              chalk.greenBright(\n                `${stringifyGraphQLType(\n                  error.requiredType.bestFittingType.type,\n                )}.${v}`,\n              ),\n            )\n            .join(', ')}`\n      }\n\n      let typeStr = '.'\n      if (isInputArgType(error.requiredType.bestFittingType.type)) {\n        typeStr =\n          ':\\n' + stringifyInputType(error.requiredType.bestFittingType.type)\n      }\n      let expected = `${error.requiredType.inputType\n        .map((t) =>\n          chalk.greenBright(\n            wrapWithList(\n              stringifyGraphQLType(t.type),\n              error.requiredType.bestFittingType.isList,\n            ),\n          ),\n        )\n        .join(' or ')}${typeStr}`\n      const inputType: null | DMMF.SchemaArgInputType =\n        (error.requiredType.inputType.length === 2 &&\n          error.requiredType.inputType.find((t) => isInputArgType(t.type))) ||\n        null\n      if (inputType) {\n        expected += `\\n` + stringifyInputType(inputType.type, true)\n      }\n      return `Argument ${chalk.bold(\n        error.argName,\n      )}: Got invalid value ${chalk.redBright(valueStr)}${multilineValue ? '' : ' '\n        }on ${chalk.bold(\n          `prisma.${this.children[0].name}`,\n        )}. Provided ${chalk.redBright(\n          getGraphQLType(error.providedValue),\n        )}, expected ${expected}`\n    }\n\n    if (error.type === 'invalidNullArg') {\n      const forStr =\n        path.length === 1 && path[0] === error.name\n          ? ''\n          : ` for ${chalk.bold(`${path.join('.')}`)}`\n      const undefinedTip = ` Please use ${chalk.bold.greenBright(\n        'undefined',\n      )} instead.`\n      return `Argument ${chalk.greenBright(\n        error.name,\n      )}${forStr} must not be ${chalk.bold('null')}.${undefinedTip}`\n    }\n\n    if (error.type === 'missingArg') {\n      const forStr =\n        path.length === 1 && path[0] === error.missingName\n          ? ''\n          : ` for ${chalk.bold(`${path.join('.')}`)}`\n      return `Argument ${chalk.greenBright(\n        error.missingName,\n      )}${forStr} is missing.`\n    }\n\n    if (error.type === 'atLeastOne') {\n      const additional = minimal\n        ? ''\n        : ` Available args are listed in ${chalk.dim.green('green')}.`\n      return `Argument ${chalk.bold(path.join('.'))} of type ${chalk.bold(\n        error.inputType.name,\n      )} needs ${chalk.greenBright('at least one')} argument.${additional}`\n    }\n\n    if (error.type === 'atMostOne') {\n      const additional = minimal\n        ? ''\n        : ` Please choose one. ${chalk.dim(\n          'Available args:',\n        )} \\n${stringifyInputType(error.inputType, true)}`\n      return `Argument ${chalk.bold(path.join('.'))} of type ${chalk.bold(\n        error.inputType.name,\n      )} needs ${chalk.greenBright(\n        'exactly one',\n      )} argument, but you provided ${error.providedKeys\n        .map((key) => chalk.redBright(key))\n        .join(' and ')}.${additional}`\n    }\n  }\n  /**\n   * As we're allowing both single objects and array of objects for list inputs, we need to remove incorrect\n   * zero indexes from the path\n   * @param inputPath e.g. ['where', 'AND', 0, 'id']\n   * @param select select object\n   */\n  private normalizePath(inputPath: Array<string | number>, select: any) {\n    const path = inputPath.slice()\n    const newPath: Array<string | number> = []\n    let key: undefined | string | number\n    let pointer = select\n    // tslint:disable-next-line:no-conditional-assignment\n    while ((key = path.shift()) !== undefined) {\n      if (!Array.isArray(pointer) && key === 0) {\n        continue\n      }\n      if (key === 'select') {\n        // TODO: Remove this logic! It shouldn't be needed\n        if (!pointer[key]) {\n          pointer = pointer.include\n        } else {\n          pointer = pointer[key]\n        }\n      } else if (pointer && pointer[key]) {\n        pointer = pointer[key]\n      }\n\n      newPath.push(key)\n    }\n    return newPath\n  }\n}\n\nexport class PrismaClientValidationError extends Error { }\n\nexport interface FieldArgs {\n  name: string\n  schemaField?: DMMF.SchemaField // optional as we want to even build up invalid queries to collect all errors\n  args?: Args\n  children?: Field[]\n  error?: InvalidFieldError\n}\n\nexport class Field {\n  public readonly name: string\n  public readonly args?: Args\n  public readonly children?: Field[]\n  public readonly error?: InvalidFieldError\n  public readonly hasInvalidChild: boolean\n  public readonly hasInvalidArg: boolean\n  public readonly schemaField?: DMMF.SchemaField\n  constructor({ name, args, children, error, schemaField }: FieldArgs) {\n    this.name = name\n    this.args = args\n    this.children = children\n    this.error = error\n    this.schemaField = schemaField\n    this.hasInvalidChild = children\n      ? children.some((child) =>\n        Boolean(child.error || child.hasInvalidArg || child.hasInvalidChild),\n      )\n      : false\n    this.hasInvalidArg = args ? args.hasInvalidArg : false\n  }\n  public toString() {\n    let str = this.name\n\n    if (this.error) {\n      return str + ' # INVALID_FIELD'\n    }\n\n    if (this.args && this.args.args && this.args.args.length > 0) {\n      if (this.args.args.length === 1) {\n        str += `(${this.args.toString()})`\n      } else {\n        str += `(\\n${indent(this.args.toString(), tab)}\\n)`\n      }\n    }\n\n    if (this.children) {\n      str += ` {\n${indent(this.children.map(String).join('\\n'), tab)}\n}`\n    }\n\n    return str\n  }\n  public collectErrors(\n    prefix = 'select',\n  ): { fieldErrors: FieldError[]; argErrors: ArgError[] } {\n    const fieldErrors: FieldError[] = []\n    const argErrors: ArgError[] = []\n\n    if (this.error) {\n      fieldErrors.push({\n        path: [this.name],\n        error: this.error,\n      })\n    }\n\n    // get all errors from fields\n    if (this.children) {\n      for (const child of this.children) {\n        const errors = child.collectErrors(prefix)\n        // Field -> Field always goes through a 'select'\n        fieldErrors.push(\n          ...errors.fieldErrors.map((e) => ({\n            ...e,\n            path: [this.name, prefix, ...e.path],\n          })),\n        )\n        argErrors.push(\n          ...errors.argErrors.map((e) => ({\n            ...e,\n            path: [this.name, prefix, ...e.path],\n          })),\n        )\n      }\n    }\n\n    // get all errors from args\n    if (this.args) {\n      argErrors.push(\n        ...this.args\n          .collectErrors()\n          .map((e) => ({ ...e, path: [this.name, ...e.path] })),\n      )\n    }\n\n    return {\n      fieldErrors,\n      argErrors,\n    }\n  }\n}\n\nexport class Args {\n  public args: Arg[]\n  public readonly hasInvalidArg: boolean\n  constructor(args: Arg[] = []) {\n    this.args = args\n    this.hasInvalidArg = args\n      ? args.some((arg) => Boolean(arg.hasError))\n      : false\n  }\n  public toString() {\n    if (this.args.length === 0) {\n      return ''\n    }\n    return `${this.args\n      .map((arg) => arg.toString())\n      .filter((a) => a)\n      .join('\\n')}`\n  }\n  public collectErrors(): ArgError[] {\n    if (!this.hasInvalidArg) {\n      return []\n    }\n\n    return flatMap(this.args, (arg) => arg.collectErrors())\n  }\n}\n\n/**\n * Custom stringify which turns undefined into null - needed by GraphQL\n * @param obj to stringify\n * @param _\n * @param tab\n */\nfunction stringify(\n  obj,\n  _?: any,\n  tabbing?: string | number,\n  isEnum?: boolean,\n  isJson?: boolean,\n) {\n  if (Buffer.isBuffer(obj)) {\n    return JSON.stringify(obj.toString('base64'))\n  }\n\n  if (isJson) {\n    if (obj === null) {\n      return 'null'\n    }\n    if (obj && obj.values && obj.__prismaRawParamaters__) {\n      return JSON.stringify(obj.values)\n    }\n    return JSON.stringify(JSON.stringify(obj))\n  }\n\n  if (obj === undefined) {\n    return null\n  }\n\n  if (obj === null) {\n    return 'null'\n  }\n\n  if (Decimal.isDecimal(obj)) {\n    return obj.toString()\n  }\n\n  if (isEnum && typeof obj === 'string') {\n    return obj\n  }\n\n  if (isEnum && Array.isArray(obj)) {\n    return `[${obj.join(', ')}]`\n  }\n\n  return JSON.stringify(obj, _, tabbing)\n}\n\ninterface ArgOptions {\n  key: string\n  value: ArgValue\n  argType?: DMMF.ArgType // just needed to transform the ast\n  isEnum?: boolean\n  error?: InvalidArgError\n  schemaArg?: DMMF.SchemaArg\n}\n\nexport class Arg {\n  public key: string\n  // not readonly, as we later need to transform it\n  public value: ArgValue\n  public error?: InvalidArgError\n  public hasError: boolean\n  public isEnum: boolean\n  public schemaArg?: DMMF.SchemaArg\n  public argType?: DMMF.ArgType\n  public isNullable: boolean\n\n  constructor({\n    key,\n    value,\n    argType,\n    isEnum = false,\n    error,\n    schemaArg,\n  }: ArgOptions) {\n    this.key = key\n    this.value = value\n    this.argType = argType\n    this.isEnum = isEnum\n    this.error = error\n    this.schemaArg = schemaArg\n    this.isNullable =\n      schemaArg?.inputTypes.reduce<boolean>(\n        (isNullable, inputType) => isNullable && schemaArg.isNullable,\n        true,\n      ) || false\n    this.hasError =\n      Boolean(error) ||\n      (value instanceof Args ? value.hasInvalidArg : false) ||\n      (Array.isArray(value) &&\n        value.some((v) => (v instanceof Args ? v.hasInvalidArg : false)))\n  }\n  public _toString(value: ArgValue, key: string): string | undefined {\n    if (typeof value === 'undefined') {\n      return undefined\n    }\n\n    if (value instanceof Args) {\n      if (\n        value.args.length === 1 &&\n        value.args[0].key === 'set' &&\n        value.args[0].schemaArg?.inputTypes[0].type === 'Json'\n      ) {\n        return `${key}: {\n  set: ${stringify(value.args[0].value, null, 2, this.isEnum, true)}\n}`\n      }\n      return `${key}: {\n${indent(value.toString(), 2)}\n}`\n    }\n\n    if (Array.isArray(value)) {\n      if (this.argType === 'Json') {\n        return `${key}: ${stringify(\n          value,\n          null,\n          2,\n          this.isEnum,\n          this.argType === 'Json',\n        )}`\n      }\n\n      const isScalar = !(value as any[]).some((v) => typeof v === 'object')\n      return `${key}: [${isScalar ? '' : '\\n'}${indent(\n        (value as any[])\n          .map((nestedValue) => {\n            if (nestedValue instanceof Args) {\n              return `{\\n${indent(nestedValue.toString(), tab)}\\n}`\n            }\n            return stringify(nestedValue, null, 2, this.isEnum)\n          })\n          .join(`,${isScalar ? ' ' : '\\n'}`),\n        isScalar ? 0 : tab,\n      )}${isScalar ? '' : '\\n'}]`\n    }\n\n    return `${key}: ${stringify(\n      value,\n      null,\n      2,\n      this.isEnum,\n      this.argType === 'Json',\n    )}`\n  }\n  public toString() {\n    return this._toString(this.value, this.key)\n  }\n  public collectErrors(): ArgError[] {\n    if (!this.hasError) {\n      return []\n    }\n\n    const errors: ArgError[] = []\n\n    // add the own arg\n    if (this.error) {\n      errors.push({\n        error: this.error,\n        path: [this.key],\n      })\n    }\n\n    if (Array.isArray(this.value)) {\n      errors.push(\n        ...(flatMap(this.value as any[], (val, index) => {\n          if (!val.collectErrors) {\n            return []\n          }\n\n          return val.collectErrors().map((e) => {\n            return { ...e, path: [this.key, index, ...e.path] }\n          })\n        }) as any[]),\n      )\n    }\n\n    // collect errors of children if there are any\n    if (this.value instanceof Args) {\n      errors.push(\n        ...this.value\n          .collectErrors()\n          .map((e) => ({ ...e, path: [this.key, ...e.path] })),\n      )\n    }\n\n    return errors\n  }\n}\n\nexport type ArgValue =\n  | string\n  | boolean\n  | number\n  | undefined\n  | Args\n  | string[]\n  | boolean[]\n  | number[]\n  | Args[]\n  | null\n\nexport interface DocumentInput {\n  dmmf: DMMFClass\n  rootTypeName: 'query' | 'mutation'\n  rootField: string\n  select?: any\n}\n\nexport function makeDocument({\n  dmmf,\n  rootTypeName,\n  rootField,\n  select,\n}: DocumentInput): Document {\n  if (!select) {\n    select = {}\n  }\n  const rootType = rootTypeName === 'query' ? dmmf.queryType : dmmf.mutationType\n  // Create a fake toplevel field for easier implementation\n  const fakeRootField: DMMF.SchemaField = {\n    args: [],\n    outputType: {\n      isList: false,\n      type: rootType,\n      kind: 'object',\n    },\n    isRequired: true,\n    name: rootTypeName,\n  }\n  const children = selectionToFields(\n    dmmf,\n    { [rootField]: select },\n    fakeRootField,\n    [rootTypeName],\n  )\n  return new Document(rootTypeName, children) as any\n}\n\n// TODO: get rid of this function\nexport function transformDocument(document: Document): Document {\n  return document\n}\n\nfunction isArgsArray(input: any): input is Args[] {\n  if (Array.isArray(input)) {\n    return input.every((arg) => arg instanceof Args)\n  }\n\n  return false\n}\n\nfunction getFilterArgName(arg: string, filter: string) {\n  if (filter === 'equals') {\n    return arg\n  }\n\n  return `${arg}_${convertToSnakeCase(filter)}`\n}\n\nfunction convertToSnakeCase(str: string): string {\n  return str\n    .split(/(?=[A-Z])/)\n    .join('_')\n    .toLowerCase()\n}\n\nexport function selectionToFields(\n  dmmf: DMMFClass,\n  selection: any,\n  schemaField: DMMF.SchemaField,\n  path: string[],\n): Field[] {\n  const outputType = schemaField.outputType.type as DMMF.OutputType\n  return Object.entries(selection).reduce((acc, [name, value]: any) => {\n    const field = outputType.fieldMap\n      ? outputType.fieldMap[name]\n      : outputType.fields.find((f) => f.name === name)\n\n    if (!field) {\n      // if the field name is incorrect, we ignore the args and child fields altogether\n      acc.push(\n        new Field({\n          name,\n          children: [],\n          // @ts-ignore\n          error: {\n            type: 'invalidFieldName',\n            modelName: outputType.name,\n            providedName: name,\n            didYouMean: getSuggestion(\n              name,\n              outputType.fields.map((f) => f.name),\n            ),\n            outputType,\n          },\n        }),\n      )\n\n      return acc\n    }\n\n    if (\n      typeof value !== 'boolean' &&\n      field.outputType.kind === 'scalar' &&\n      field.name !== 'executeRaw' &&\n      field.name !== 'queryRaw' &&\n      outputType.name !== 'Query' &&\n      !name.startsWith('aggregate') &&\n      field.name !== 'count' // TODO: Find a cleaner solution\n    ) {\n      acc.push(\n        new Field({\n          name,\n          children: [],\n          error: {\n            type: 'invalidFieldType',\n            modelName: outputType.name,\n            fieldName: name,\n            providedValue: value,\n          },\n        }),\n      )\n\n      return acc\n    }\n    if (value === false) {\n      return acc\n    }\n\n    const transformedField = {\n      name: field.name,\n      fields: field.args,\n      constraints: {\n        minNumFields: null,\n        maxNumFields: null\n      }\n    }\n    const argsWithoutIncludeAndSelect =\n      typeof value === 'object' ? omit(value, ['include', 'select']) : undefined\n    const args = argsWithoutIncludeAndSelect\n      ? objectToArgs(\n        argsWithoutIncludeAndSelect,\n        transformedField,\n        [],\n        typeof field === 'string'\n          ? undefined\n          : (field.outputType.type as DMMF.OutputType),\n      )\n      : undefined\n    const isRelation = field.outputType.kind === 'object'\n\n    // TODO: use default selection for `include` again\n\n    // check for empty select\n    if (value) {\n      if (value.select && value.include) {\n        acc.push(\n          new Field({\n            name,\n            children: [\n              new Field({\n                name: 'include',\n                args: new Args(),\n                error: {\n                  type: 'includeAndSelect',\n                  field,\n                },\n              }),\n            ],\n          }),\n        )\n      } else if (value.include) {\n        const keys = Object.keys(value.include)\n\n        if (keys.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: 'include',\n                  args: new Args(),\n                  error: {\n                    type: 'emptyInclude',\n                    field,\n                  },\n                }),\n              ],\n            }),\n          )\n\n          return acc\n        }\n\n        // TODO: unify with select validation logic\n        /**\n         * Error handling for `include` statements\n         */\n        if (field.outputType.kind === 'object') {\n          const fieldOutputType = field.outputType.type as DMMF.OutputType\n          const allowedKeys = fieldOutputType.fields\n            .filter((f) => f.outputType.kind === 'object')\n            .map((f) => f.name)\n          const invalidKeys = keys.filter((key) => !allowedKeys.includes(key))\n          if (invalidKeys.length > 0) {\n            acc.push(\n              ...invalidKeys.map(\n                (invalidKey) =>\n                  new Field({\n                    name: invalidKey,\n                    children: [\n                      new Field({\n                        name: invalidKey,\n                        args: new Args(),\n                        error: {\n                          type: 'invalidFieldName',\n                          modelName: fieldOutputType.name,\n                          outputType: fieldOutputType,\n                          providedName: invalidKey,\n                          didYouMean:\n                            getSuggestion(invalidKey, allowedKeys) || undefined,\n                          isInclude: true,\n                          isIncludeScalar: fieldOutputType.fields.some(\n                            (f) => f.name === invalidKey,\n                          ),\n                        },\n                      }),\n                    ],\n                    // @ts-ignore\n                  }),\n              ),\n            )\n            return acc\n          }\n        }\n      } else if (value.select) {\n        const values = Object.values(value.select)\n        if (values.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: 'select',\n                  args: new Args(),\n                  error: {\n                    type: 'emptySelect',\n                    field,\n                  },\n                }),\n              ],\n            }),\n          )\n\n          return acc\n        }\n\n        // check if there is at least one truthy value\n        const truthyValues = values.filter((v) => v)\n        if (truthyValues.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: 'select',\n                  args: new Args(),\n                  error: {\n                    type: 'noTrueSelect',\n                    field,\n                  },\n                }),\n              ],\n            }),\n          )\n\n          return acc\n        }\n      }\n    }\n    // either use select or default selection, but not both at the same time\n    const defaultSelection = isRelation\n      ? getDefaultSelection(field.outputType.type as DMMF.OutputType)\n      : null\n    let select = defaultSelection\n    if (value) {\n      if (value.select) {\n        select = value.select\n      } else if (value.include) {\n        select = deepExtend(defaultSelection, value.include)\n      }\n    }\n    const children =\n      select !== false && isRelation\n        ? selectionToFields(dmmf, select, field, [...path, name])\n        : undefined\n\n    acc.push(new Field({ name, args, children, schemaField: field }))\n\n    return acc\n  }, [] as Field[])\n}\n\nfunction getDefaultSelection(outputType: DMMF.OutputType) {\n  return outputType.fields.reduce((acc, f) => {\n    if (f.outputType.kind === 'scalar' || f.outputType.kind === 'enum') {\n      acc[f.name] = true\n    } else {\n      // otherwise field is a relation. Only continue if it's an embedded type\n      // as normal types don't end up in the default selection\n      if ((f.outputType.type as DMMF.OutputType).isEmbedded) {\n        acc[f.name] = {\n          select: getDefaultSelection(f.outputType.type as DMMF.OutputType),\n        }\n      }\n    }\n\n    return acc\n  }, {})\n}\n\nfunction getInvalidTypeArg(\n  key: string,\n  value: any,\n  arg: DMMF.SchemaArg,\n  bestFittingType: DMMF.SchemaArgInputType,\n): Arg {\n  const arrg = new Arg({\n    key,\n    value,\n    isEnum: bestFittingType.kind === 'enum',\n    argType: bestFittingType.type,\n    error: {\n      type: 'invalidType',\n      providedValue: value,\n      argName: key,\n      requiredType: {\n        inputType: arg.inputTypes,\n\n        bestFittingType,\n      },\n    },\n  })\n\n  return arrg\n}\n\nfunction hasCorrectScalarType(\n  value: any,\n  arg: DMMF.SchemaArg,\n  inputType: DMMF.SchemaArgInputType,\n): boolean {\n  const { type, isList } = inputType\n  const expectedType = wrapWithList(stringifyGraphQLType(type), isList)\n  const graphQLType = getGraphQLType(value, type)\n\n  if (graphQLType === expectedType) {\n    return true\n  }\n\n  if (isList && graphQLType === 'List<>') {\n    return true\n  }\n\n  if (expectedType === 'Json') {\n    return true\n  }\n\n  if ((graphQLType === 'Int' || graphQLType === 'Float') && expectedType === 'Decimal') {\n    return true\n  }\n\n  // DateTime is a subset of string\n  if (graphQLType === 'DateTime' && expectedType === 'String') {\n    return true\n  }\n  if (graphQLType === 'List<DateTime>' && expectedType === 'List<String>') {\n    return true\n  }\n\n  // UUID is a subset of string\n  if (graphQLType === 'UUID' && expectedType === 'String') {\n    return true\n  }\n  if (graphQLType === 'List<UUID>' && expectedType === 'List<String>') {\n    return true\n  }\n\n  if (graphQLType === 'String' && expectedType === 'ID') {\n    return true\n  }\n  if (graphQLType === 'List<String>' && expectedType === 'List<ID>') {\n    return true\n  }\n  if (\n    expectedType === 'List<String>' &&\n    (graphQLType === 'List<String | UUID>' ||\n      graphQLType === 'List<UUID | String>')\n  ) {\n    return true\n  }\n\n  // Int is a subset of Float\n  if (graphQLType === 'Int' && expectedType === 'Float') {\n    return true\n  }\n  if (graphQLType === 'List<Int>' && expectedType === 'List<Float>') {\n    return true\n  }\n  // Int is a subset of Long\n  if (graphQLType === 'Int' && expectedType === 'Long') {\n    return true\n  }\n  if (graphQLType === 'List<Int>' && expectedType === 'List<Long>') {\n    return true\n  }\n\n  // to match all strings which are valid decimals\n  // from https://github.com/MikeMcl/decimal.js/blob/master/decimal.js#L115\n  if (graphQLType === 'String' && /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i.test(value) && expectedType === 'Decimal') {\n    return true\n  }\n\n  if (!arg.isRequired && value === null) {\n    return true\n  }\n  return false\n}\n\n\nconst cleanObject = (obj) => filterObject(obj, (k, v) => v !== undefined)\n\nfunction valueToArg(key: string, value: any, arg: DMMF.SchemaArg): Arg | null {\n  /**\n   * Go through the possible union input types.\n   * Stop on the first successful one\n   */\n  let maybeArg: Arg | null = null\n  for (const inputType of arg.inputTypes) {\n    maybeArg = tryInferArgs(key, value, arg, inputType)\n    if (maybeArg?.collectErrors().length === 0) {\n      return maybeArg\n    }\n  }\n\n  return maybeArg\n}\n\n/**\n * Running through the possible input types of a union.\n * @param key \n * @param value \n * @param arg \n * @param inputType \n */\nfunction tryInferArgs(key: string, value: any, arg: DMMF.SchemaArg, inputType: DMMF.SchemaArgInputType): Arg | null {\n  if (typeof value === 'undefined') {\n    // the arg is undefined and not required - we're fine\n    if (!arg.isRequired) {\n      return null\n    }\n\n    // the provided value is 'undefined' but shouldn't be\n    return new Arg({\n      key,\n      value,\n      isEnum: inputType.kind === 'enum',\n      error: {\n        type: 'missingArg',\n        missingName: key,\n        missingArg: arg,\n        atLeastOne: false,\n        atMostOne: false,\n      },\n    })\n  }\n\n  const { isNullable, isRequired } = arg\n\n  if (value === null && !isNullable && !isRequired) {\n    // we don't need to execute this ternery if not necessary\n    const isAtLeastOne = isInputArgType(inputType.type)\n      ? (inputType.type.constraints.minNumFields !== null && inputType.type.constraints.minNumFields > 0)\n      : false\n    if (!isAtLeastOne) {\n      return new Arg({\n        key,\n        value,\n        isEnum: inputType.kind === 'enum',\n        error: {\n          type: 'invalidNullArg',\n          name: key,\n          invalidType: arg.inputTypes,\n          atLeastOne: false,\n          atMostOne: false,\n        },\n      })\n    }\n  }\n  // then the first\n  if (!inputType.isList) {\n    if (isInputArgType(inputType.type)) {\n      if (typeof value !== 'object') {\n        return getInvalidTypeArg(key, value, arg, inputType)\n      } else {\n        let val = cleanObject(value)\n        let error: AtMostOneError | AtLeastOneError | undefined\n        const keys = Object.keys(val || {})\n        const numKeys = keys.length\n\n        if (numKeys === 0 && (typeof inputType.type.constraints.minNumFields === 'number' && inputType.type.constraints.minNumFields > 0)) {\n          // continue here\n          error = {\n            type: 'atLeastOne',\n            key,\n            inputType: inputType.type,\n          }\n        } else if (numKeys > 1 && (typeof inputType.type.constraints.maxNumFields === 'number' && inputType.type.constraints.maxNumFields < 2)) {\n          error = {\n            type: 'atMostOne',\n            key,\n            inputType: inputType.type,\n            providedKeys: keys,\n          }\n        }\n\n        return new Arg({\n          key,\n          value:\n            val === null ? null : objectToArgs(val, inputType.type, arg.inputTypes),\n          isEnum: inputType.kind === 'enum',\n          error,\n          argType: inputType.type,\n          schemaArg: arg,\n        })\n      }\n    } else {\n      return scalarToArg(key, value, arg, inputType)\n    }\n  }\n\n  // the provided arg should be a list, but isn't\n  // that's fine for us as we can just turn this into a list with a single item\n  // and GraphQL even allows this. We're going the conservative route though\n  // and actually generate the [] around the value\n\n  if (!Array.isArray(value) && inputType.isList) {\n    // TODO: This \"if condition\" is just a hack until the query engine is fixed\n    if (key !== 'updateMany') {\n      value = [value]\n    }\n  }\n\n  if (inputType.kind === 'enum' || inputType.kind === 'scalar') {\n    // if no value is incorrect\n    return scalarToArg(key, value, arg, inputType)\n  }\n\n  const argInputType = inputType.type as DMMF.InputType\n  const hasAtLeastOneError = (typeof argInputType.constraints.minNumFields === 'number' && argInputType.constraints.minNumFields > 0)\n    ? Array.isArray(value) && value.some((v) => !v || Object.keys(cleanObject(v)).length === 0)\n    : false\n  let err: AtLeastOneError | undefined | AtMostOneError = hasAtLeastOneError\n    ? {\n      inputType: argInputType,\n      key,\n      type: 'atLeastOne',\n    }\n    : undefined\n  if (!err) {\n    const hasOneOfError = (typeof argInputType.constraints.maxNumFields === 'number' && argInputType.constraints.maxNumFields < 2)\n      ? Array.isArray(value) && value.find((v) => !v || Object.keys(cleanObject(v)).length !== 1)\n      : false\n    if (hasOneOfError) {\n      err = {\n        inputType: argInputType,\n        key,\n        type: 'atMostOne',\n        providedKeys: Object.keys(hasOneOfError),\n      }\n    }\n  }\n\n  if (!Array.isArray(value)) {\n    for (const argInputType of arg.inputTypes) {\n      const args = objectToArgs(value, argInputType.type as DMMF.InputType)\n      if (args.collectErrors().length === 0) {\n        return new Arg({ key, value: args, isEnum: false, argType: argInputType.type, schemaArg: arg, })\n      }\n    }\n  }\n\n\n  return new Arg({\n    key,\n    value: value.map((v) => {\n      if ((inputType.isList) && typeof v !== 'object') {\n        return v\n      }\n      if (typeof v !== 'object' || !value) {\n        return getInvalidTypeArg(key, v, arg, inputType)\n      }\n      return objectToArgs(v, argInputType)\n    }),\n    isEnum: false,\n    argType: argInputType,\n    schemaArg: arg,\n    error: err,\n  })\n}\n\nexport function isInputArgType(\n  argType: DMMF.ArgType,\n): argType is DMMF.InputType {\n  if (typeof argType === 'string') {\n    return false\n  }\n  if (argType.hasOwnProperty('values')) {\n    return false\n  }\n\n  return true\n}\n\nfunction scalarToArg(\n  key: string,\n  value: any,\n  arg: DMMF.SchemaArg,\n  inputType: DMMF.SchemaArgInputType,\n): Arg {\n  if (hasCorrectScalarType(value, arg, inputType)) {\n    return new Arg({\n      key,\n      value,\n      isEnum: arg.inputTypes[0].kind === 'enum',\n      argType: inputType.type,\n      schemaArg: arg,\n    })\n  }\n  return getInvalidTypeArg(key, value, arg, inputType)\n}\n\nfunction objectToArgs(\n  initialObj: any,\n  inputType: DMMF.InputType,\n  possibilities?: DMMF.SchemaArgInputType[],\n  outputType?: DMMF.OutputType,\n): Args {\n  // filter out undefined values and treat them if they weren't provided\n  const obj = cleanObject(initialObj)\n  const { fields: args, fieldMap } = inputType\n  const requiredArgs: any = args\n    .map((arg) => [arg.name, undefined])\n  const objEntries = Object.entries(obj || {})\n  const entries = unionBy(objEntries, requiredArgs, (a) => a[0])\n  const argsList = entries.reduce((acc, [argName, value]: any) => {\n    const schemaArg = fieldMap\n      ? fieldMap[argName]\n      : args.find((a) => a.name === argName)\n    if (!schemaArg) {\n      const didYouMeanField =\n        typeof value === 'boolean' &&\n          outputType &&\n          outputType.fields.some((f) => f.name === argName)\n          ? argName\n          : null\n      acc.push(\n        new Arg({\n          key: argName,\n          value,\n          error: {\n            type: 'invalidName',\n            providedName: argName,\n            providedValue: value,\n            didYouMeanField,\n            didYouMeanArg:\n              (!didYouMeanField &&\n                getSuggestion(argName, [\n                  ...args.map((a) => a.name),\n                  'select',\n                ])) ||\n              undefined,\n            originalType: inputType,\n            possibilities,\n            outputType,\n          },\n        }),\n      )\n      return acc\n    }\n\n    const arg = valueToArg(argName, value, schemaArg)\n\n    if (arg) {\n      acc.push(arg)\n    }\n\n    return acc\n  }, [] as Arg[])\n  // Also show optional neighbour args, if there is any arg missing\n  if (\n    (typeof inputType.constraints.minNumFields === 'number' && objEntries.length < inputType.constraints.minNumFields) ||\n    argsList.find((arg) => (arg.error?.type === 'missingArg' || arg.error?.type === 'atLeastOne'))\n  ) {\n    const optionalMissingArgs = inputType.fields.filter(\n      field => !field.isRequired && (obj && (typeof obj[field.name] === 'undefined' || obj[field.name] === null))\n    )\n    argsList.push(\n      ...optionalMissingArgs.map((arg) => {\n        const argInputType = arg.inputTypes[0]\n        return new Arg({\n          key: arg.name,\n          value: undefined,\n          isEnum: argInputType.kind === 'enum',\n          error: {\n            type: 'missingArg',\n            missingName: arg.name,\n            missingArg: arg,\n            atLeastOne: Boolean(inputType.constraints.minNumFields) || false,\n            atMostOne: inputType.constraints.maxNumFields === 1 || false,\n          },\n        })\n      }),\n    )\n  }\n  return new Args(argsList)\n}\n\nexport interface UnpackOptions {\n  document: Document\n  path: string[]\n  data: any\n}\n\n/**\n * Unpacks the result of a data object and maps DateTime fields to instances of `Date` inplace\n * @param options: UnpackOptions\n */\nexport function unpack({ document, path, data }: UnpackOptions): any {\n  const result = deepGet(data, path)\n\n  if (result === 'undefined') {\n    return null\n  }\n\n  if (typeof result !== 'object') {\n    return result\n  }\n\n  const field = getField(document, path)\n\n  return mapScalars({ field, data: result })\n}\n\nexport interface MapScalarsOptions {\n  field: Field\n  data: any\n}\n\nexport function mapScalars({ field, data }: MapScalarsOptions): any {\n  if (\n    !data ||\n    typeof data !== 'object' ||\n    !field.children ||\n    !field.schemaField\n  ) {\n    return data\n  }\n\n  const deserializers = {\n    'DateTime': value => new Date(value),\n    'Json': value => JSON.parse(value),\n    'Bytes': value => Buffer.from(value, 'base64'),\n    'Decimal': value => {\n      return new Decimal(value)\n    }\n  }\n\n  for (const child of field.children) {\n    const outputType = child.schemaField?.outputType.type\n    if (outputType && typeof outputType === 'string') {\n      const deserializer = deserializers[outputType]\n      if (deserializer) {\n        if (Array.isArray(data)) {\n          for (const entry of data) {\n            // in the very unlikely case, that a field is not there in the result, ignore it\n            if (typeof entry[child.name] !== 'undefined' && entry[child.name] !== null) {\n              entry[child.name] = deserializer(entry[child.name])\n            }\n          }\n        } else {\n          // same here, ignore it if it's undefined\n          if (typeof data[child.name] !== 'undefined' && data[child.name] !== null) {\n            data[child.name] = deserializer(data[child.name])\n          }\n        }\n      }\n    }\n\n    if (child.schemaField && child.schemaField.outputType.kind === 'object') {\n      if (Array.isArray(data)) {\n        for (const entry of data) {\n          mapScalars({ field: child, data: entry[child.name] })\n        }\n      } else {\n        mapScalars({ field: child, data: data[child.name] })\n      }\n    }\n  }\n\n  return data\n}\n\nexport function getField(document: Document, path: string[]): Field {\n  const todo = path.slice() // let's create a copy to not fiddle with the input argument\n  const firstElement = todo.shift()\n  // this might be slow because of the find\n  let pointer = document.children.find((c) => c.name === firstElement)\n\n  if (!pointer) {\n    throw new Error(\n      `Could not find field ${firstElement} in document ${document}`,\n    )\n  }\n\n  while (todo.length > 0) {\n    const key = todo.shift()\n    if (!pointer!.children) {\n      throw new Error(\n        `Can't get children for field ${pointer} with child ${key}`,\n      )\n    }\n    const child = pointer!.children.find((c) => c.name === key)\n    if (!child) {\n      throw new Error(`Can't find child ${key} of field ${pointer}`)\n    }\n    pointer = child!\n  }\n\n  return pointer!\n}\n\nfunction removeSelectFromPath(path: string): string {\n  return path\n    .split('.')\n    .filter((p) => p !== 'select')\n    .join('.')\n}\n\nfunction removeSelectFromObject(obj: object): object {\n  const type = Object.prototype.toString.call(obj)\n  if (type === '[object Object]') {\n    const copy = {}\n    for (const key in obj) {\n      if (key === 'select') {\n        for (const subKey in obj['select']) {\n          copy[subKey] = removeSelectFromObject(obj['select'][subKey])\n        }\n      } else {\n        copy[key] = removeSelectFromObject(obj[key])\n      }\n    }\n    return copy\n  }\n\n  return obj\n}\n\nfunction transformAggregatePrintJsonArgs({\n  ast,\n  keyPaths,\n  missingItems,\n  valuePaths,\n}: PrintJsonWithErrorsArgs): PrintJsonWithErrorsArgs {\n  const newKeyPaths = keyPaths.map(removeSelectFromPath)\n  const newValuePaths = valuePaths.map(removeSelectFromPath)\n  const newMissingItems = missingItems.map((item) => ({\n    path: removeSelectFromPath(item.path),\n    isRequired: item.isRequired,\n    type: item.type,\n  }))\n\n  const newAst = removeSelectFromObject(ast)\n  return {\n    ast: newAst,\n    keyPaths: newKeyPaths,\n    missingItems: newMissingItems,\n    valuePaths: newValuePaths,\n  }\n}\n", "function flatten(array) {\n  return Array.prototype.concat.apply([], array)\n}\n\nexport function flatMap<T, U>(\n  array: T[],\n  callbackFn: (value: T, index: number, array: T[]) => U[],\n  thisArg?: any,\n): U[] {\n  return flatten(array.map(callbackFn, thisArg))\n}\n", "import chalk from 'chalk'\nimport indent from 'indent-string'\nimport { /*dmmf, */ DMMFClass } from './dmmf'\nimport { DMMF } from './dmmf-types'\nimport {\n  ArgError,\n  AtLeastOneError,\n  AtMostOneError,\n  FieldError,\n  InvalidArgError,\n  InvalidFieldError,\n  MissingArgError,\n} from './error-types'\nimport {\n  getGraphQLType,\n  getInputTypeName,\n  getOutputTypeName,\n  getSuggestion,\n  inputTypeToJson,\n  stringifyGraphQLType,\n  stringifyInputType,\n  unionBy,\n  wrapWithList,\n} from './utils/common'\nimport { deepExtend } from './utils/deep-extend'\nimport { deepGet } from './utils/deep-set'\nimport { filterObject } from './utils/filterObject'\nimport { omit } from './utils/omit'\nimport {\n  MissingItem,\n  printJsonWithErrors,\n  PrintJsonWithErrorsArgs,\n} from './utils/printJsonErrors'\nimport { printStack } from './utils/printStack'\nimport stringifyObject from './utils/stringifyObject'\nimport stripAnsi from 'strip-ansi'\nimport { flatMap } from './utils/flatMap'\nimport Decimal from 'decimal.js'\n\nconst tab = 2\n\nexport class Document {\n  constructor(\n    public readonly type: 'query' | 'mutation',\n    public readonly children: Field[],\n  ) {\n    this.type = type\n    this.children = children\n  }\n  public toString() {\n    return `${this.type} {\n${indent(this.children.map(String).join('\\n'), tab)}\n}`\n  }\n  public validate(\n    select?: any,\n    isTopLevelQuery: boolean = false,\n    originalMethod?: string,\n    errorFormat?: 'pretty' | 'minimal' | 'colorless',\n    validationCallsite?: any,\n  ) {\n    if (!select) {\n      select = {}\n    }\n    const invalidChildren = this.children.filter(\n      (child) => child.hasInvalidChild || child.hasInvalidArg,\n    )\n    if (invalidChildren.length === 0) {\n      return\n    }\n\n    const fieldErrors: FieldError[] = []\n    const argErrors: ArgError[] = []\n    const prefix =\n      select && select.select\n        ? 'select'\n        : select.include\n          ? 'include'\n          : undefined\n\n    for (const child of invalidChildren) {\n      const errors = child.collectErrors(prefix)\n      fieldErrors.push(\n        ...errors.fieldErrors.map((e) => ({\n          ...e,\n          path: isTopLevelQuery ? e.path : e.path.slice(1),\n        })),\n      )\n      argErrors.push(\n        ...errors.argErrors.map((e) => ({\n          ...e,\n          path: isTopLevelQuery ? e.path : e.path.slice(1),\n        })),\n      )\n    }\n\n    const topLevelQueryName = this.children[0].name\n    const queryName = isTopLevelQuery ? this.type : topLevelQueryName\n    const keyPaths: string[] = []\n    const valuePaths: string[] = []\n    const missingItems: MissingItem[] = []\n    for (const fieldError of fieldErrors) {\n      const path = this.normalizePath(fieldError.path, select).join('.')\n      if (fieldError.error.type === 'invalidFieldName') {\n        keyPaths.push(path)\n\n        const fieldType = fieldError.error.outputType\n        const { isInclude } = fieldError.error\n        fieldType.fields\n          .filter((field) =>\n            isInclude ? field.outputType.kind === 'object' : true,\n          )\n          .forEach((field) => {\n            const splittedPath = path.split('.')\n            missingItems.push({\n              path: `${splittedPath\n                .slice(0, splittedPath.length - 1)\n                .join('.')}.${field.name}`,\n              type: 'true',\n              isRequired: false,\n            })\n          })\n      } else if (fieldError.error.type === 'includeAndSelect') {\n        keyPaths.push('select')\n        keyPaths.push('include')\n      } else {\n        valuePaths.push(path)\n      }\n      if (\n        fieldError.error.type === 'emptySelect' ||\n        fieldError.error.type === 'noTrueSelect' ||\n        fieldError.error.type === 'emptyInclude'\n      ) {\n        const selectPathArray = this.normalizePath(fieldError.path, select)\n        const selectPath = selectPathArray\n          .slice(0, selectPathArray.length - 1)\n          .join('.')\n\n        const fieldType = fieldError.error.field.outputType\n          .type as DMMF.OutputType\n\n        fieldType.fields\n          .filter((field) =>\n            fieldError.error.type === 'emptyInclude'\n              ? field.outputType.kind === 'object'\n              : true,\n          )\n          .forEach((field) => {\n            missingItems.push({\n              path: `${selectPath}.${field.name}`,\n              type: 'true',\n              isRequired: false,\n            })\n          })\n      }\n    }\n    // an arg error can either be an invalid key or invalid value\n    for (const argError of argErrors) {\n      const path = this.normalizePath(argError.path, select).join('.')\n      if (argError.error.type === 'invalidName') {\n        keyPaths.push(path)\n      } else if (\n        argError.error.type !== 'missingArg' &&\n        argError.error.type !== 'atLeastOne'\n      ) {\n        valuePaths.push(path)\n      } else if (argError.error.type === 'missingArg') {\n        const type =\n          argError.error.missingArg.inputTypes.length === 1\n            ? argError.error.missingArg.inputTypes[0].type\n            : argError.error.missingArg.inputTypes\n              .map((t) => {\n                const inputTypeName = getInputTypeName(t.type)\n                if (inputTypeName === 'Null') {\n                  return 'null'\n                }\n                if (t.isList) {\n                  return inputTypeName + '[]'\n                }\n                return inputTypeName\n              })\n              .join(' | ')\n        missingItems.push({\n          path,\n          type: inputTypeToJson(type, true, path.split('where.').length === 2),\n          isRequired: argError.error.missingArg.isRequired\n        })\n      }\n    }\n\n    const renderErrorStr = (callsite?: string) => {\n      const hasRequiredMissingArgsErrors = argErrors.some(\n        (e) =>\n          e.error.type === 'missingArg' && e.error.missingArg.isRequired,\n      )\n      const hasOptionalMissingArgsErrors = Boolean(argErrors.find(\n        (e) =>\n          e.error.type === 'missingArg' && !e.error.missingArg.isRequired,\n      ))\n      const hasMissingArgsErrors =\n        hasOptionalMissingArgsErrors || hasRequiredMissingArgsErrors\n\n      let missingArgsLegend = ''\n      if (hasRequiredMissingArgsErrors) {\n        missingArgsLegend += `\\n${chalk.dim(\n          'Note: Lines with ',\n        )}${chalk.reset.greenBright('+')} ${chalk.dim('are required')}`\n      }\n\n      if (hasOptionalMissingArgsErrors) {\n        if (missingArgsLegend.length === 0) {\n          missingArgsLegend = '\\n'\n        }\n        if (hasRequiredMissingArgsErrors) {\n          missingArgsLegend += chalk.dim(\n            `, lines with ${chalk.green('?')} are optional`,\n          )\n        } else {\n          missingArgsLegend += chalk.dim(\n            `Note: Lines with ${chalk.green('?')} are optional`,\n          )\n        }\n        missingArgsLegend += chalk.dim('.')\n      }\n\n      const errorMessages = `${argErrors\n        .filter(\n          (e) =>\n            e.error.type !== 'missingArg' || e.error.missingArg.isRequired,\n        )\n        .map((e) =>\n          this.printArgError(\n            e,\n            hasMissingArgsErrors,\n            errorFormat === 'minimal',\n          ),\n        ) // if no callsite is provided, just render the minimal error\n        .join('\\n')}\n${fieldErrors\n          .map((e) => this.printFieldError(e, missingItems, errorFormat === 'minimal'))\n          .join('\\n')}`\n\n      if (errorFormat === 'minimal') {\n        return stripAnsi(errorMessages)\n      }\n\n      const { stack, indent: indentValue, afterLines } = printStack({\n        callsite,\n        originalMethod: originalMethod || queryName,\n        showColors: errorFormat && errorFormat === 'pretty',\n        isValidationError: true,\n      })\n\n      let printJsonArgs: PrintJsonWithErrorsArgs = {\n        ast: isTopLevelQuery ? { [topLevelQueryName]: select } : select,\n        keyPaths,\n        valuePaths,\n        missingItems,\n      }\n\n      // as for aggregate we simplify the api to not include `select`\n      // we need to map this here so the errors make sense\n      if (originalMethod?.endsWith('aggregate')) {\n        printJsonArgs = transformAggregatePrintJsonArgs(printJsonArgs)\n      }\n\n      const errorStr = `${stack}${indent(\n        printJsonWithErrors(printJsonArgs),\n        indentValue,\n      ).slice(indentValue)}${chalk.dim(afterLines)}\n\n${errorMessages}${missingArgsLegend}\\n`\n\n      if (process.env.NO_COLOR || errorFormat === 'colorless') {\n        return stripAnsi(errorStr)\n      }\n      return errorStr\n    }\n    // end renderErrorStr definition\n\n    const error = new PrismaClientValidationError(\n      renderErrorStr(validationCallsite),\n    )\n\n    // @ts-ignore\n    if (process.env.NODE_ENV !== 'production') {\n      Object.defineProperty(error, 'render', {\n        get: () => renderErrorStr,\n        enumerable: false,\n      })\n    }\n    throw error\n  }\n  protected printFieldError = (\n    { error, path }: FieldError,\n    missingItems: MissingItem[],\n    minimal: boolean,\n  ) => {\n    if (error.type === 'emptySelect') {\n      const additional = minimal\n        ? ''\n        : ` Available options are listed in ${chalk.greenBright.dim('green')}.`\n      return `The ${chalk.redBright(\n        '`select`',\n      )} statement for type ${chalk.bold(\n        getOutputTypeName(error.field.outputType.type),\n      )} must not be empty.${additional}`\n    }\n    if (error.type === 'emptyInclude') {\n      if (missingItems.length === 0) {\n        return `${chalk.bold(\n          getOutputTypeName(error.field.outputType.type),\n        )} does not have any relation and therefore can't have an ${chalk.redBright(\n          '`include`',\n        )} statement.`\n      }\n      const additional = minimal\n        ? ''\n        : ` Available options are listed in ${chalk.greenBright.dim('green')}.`\n      return `The ${chalk.redBright(\n        '`include`',\n      )} statement for type ${chalk.bold(\n        getOutputTypeName(error.field.outputType.type),\n      )} must not be empty.${additional}`\n    }\n    if (error.type === 'noTrueSelect') {\n      return `The ${chalk.redBright(\n        '`select`',\n      )} statement for type ${chalk.bold(\n        getOutputTypeName(error.field.outputType.type),\n      )} needs ${chalk.bold('at least one truthy value')}.`\n    }\n    if (error.type === 'includeAndSelect') {\n      return `Please ${chalk.bold('either')} use ${chalk.greenBright(\n        '`include`',\n      )} or ${chalk.greenBright('`select`')}, but ${chalk.redBright(\n        'not both',\n      )} at the same time.`\n    }\n    if (error.type === 'invalidFieldName') {\n      const statement = error.isInclude ? 'include' : 'select'\n      const wording = error.isIncludeScalar ? 'Invalid scalar' : 'Unknown'\n      const additional = minimal\n        ? ''\n        : error.isInclude && missingItems.length === 0\n          ? `\\nThis model has no relations, so you can't use ${chalk.redBright(\n            'include',\n          )} with it.`\n          : ` Available options are listed in ${chalk.greenBright.dim('green')}.`\n      let str = `${wording} field ${chalk.redBright(\n        `\\`${error.providedName}\\``,\n      )} for ${chalk.bold(statement)} statement on model ${chalk.bold.white(\n        error.modelName,\n      )}.${additional}`\n\n      if (error.didYouMean) {\n        str += ` Did you mean ${chalk.greenBright(`\\`${error.didYouMean}\\``)}?`\n      }\n\n      if (error.isIncludeScalar) {\n        str += `\\nNote, that ${chalk.bold(\n          'include',\n        )} statements only accept relation fields.`\n      }\n\n      return str\n    }\n    if (error.type === 'invalidFieldType') {\n      const str = `Invalid value ${chalk.redBright(\n        `${stringifyObject(error.providedValue)}`,\n      )} of type ${chalk.redBright(\n        getGraphQLType(error.providedValue, undefined),\n      )} for field ${chalk.bold(\n        `${error.fieldName}`,\n      )} on model ${chalk.bold.white(\n        error.modelName,\n      )}. Expected either ${chalk.greenBright('true')} or ${chalk.greenBright(\n        'false',\n      )}.`\n\n      return str\n    }\n  }\n  protected printArgError = (\n    { error, path }: ArgError,\n    hasMissingItems: boolean,\n    minimal: boolean,\n  ) => {\n    if (error.type === 'invalidName') {\n      let str = `Unknown arg ${chalk.redBright(\n        `\\`${error.providedName}\\``,\n      )} in ${chalk.bold(path.join('.'))} for type ${chalk.bold(\n        error.outputType\n          ? error.outputType.name\n          : getInputTypeName(error.originalType),\n      )}.`\n      if (error.didYouMeanField) {\n        str += `\\n\u2192 Did you forget to wrap it with \\`${chalk.greenBright(\n          'select',\n        )}\\`? ${chalk.dim(\n          'e.g. ' +\n          chalk.greenBright(\n            `{ select: { ${error.providedName}: ${error.providedValue} } }`,\n          ),\n        )}`\n      } else if (error.didYouMeanArg) {\n        str += ` Did you mean \\`${chalk.greenBright(error.didYouMeanArg)}\\`?`\n        if (!hasMissingItems && !minimal) {\n          str +=\n            ` ${chalk.dim('Available args:')}\\n` +\n            stringifyInputType(error.originalType, true)\n        }\n      } else {\n        if ((error.originalType as DMMF.InputType).fields.length === 0) {\n          str += ` The field ${chalk.bold(\n            (error.originalType as DMMF.InputType).name,\n          )} has no arguments.`\n        } else if (!hasMissingItems && !minimal) {\n          str +=\n            ` Available args:\\n\\n` +\n            stringifyInputType(error.originalType, true)\n        }\n      }\n      return str\n    }\n\n    if (error.type === 'invalidType') {\n      let valueStr = stringifyObject(error.providedValue, { indent: '  ' })\n      const multilineValue = valueStr.split('\\n').length > 1\n      if (multilineValue) {\n        valueStr = `\\n${valueStr}\\n`\n      }\n      // TODO: we don't yet support enums in a union with a non enum. This is mostly due to not implemented error handling\n      // at this code part.\n      if (error.requiredType.bestFittingType.kind === 'enum') {\n        return `Argument ${chalk.bold(\n          error.argName,\n        )}: Provided value ${chalk.redBright(valueStr)}${multilineValue ? '' : ' '\n          }of type ${chalk.redBright(\n            getGraphQLType(error.providedValue),\n          )} on ${chalk.bold(\n            `prisma.${this.children[0].name}`,\n          )} is not a ${chalk.greenBright(\n            wrapWithList(\n              stringifyGraphQLType(error.requiredType.bestFittingType.kind),\n              error.requiredType.bestFittingType.isList,\n            ),\n          )}.\n\u2192 Possible values: ${(error.requiredType.bestFittingType\n            .type as DMMF.SchemaEnum).values\n            .map((v) =>\n              chalk.greenBright(\n                `${stringifyGraphQLType(\n                  error.requiredType.bestFittingType.type,\n                )}.${v}`,\n              ),\n            )\n            .join(', ')}`\n      }\n\n      let typeStr = '.'\n      if (isInputArgType(error.requiredType.bestFittingType.type)) {\n        typeStr =\n          ':\\n' + stringifyInputType(error.requiredType.bestFittingType.type)\n      }\n      let expected = `${error.requiredType.inputType\n        .map((t) =>\n          chalk.greenBright(\n            wrapWithList(\n              stringifyGraphQLType(t.type),\n              error.requiredType.bestFittingType.isList,\n            ),\n          ),\n        )\n        .join(' or ')}${typeStr}`\n      const inputType: null | DMMF.SchemaArgInputType =\n        (error.requiredType.inputType.length === 2 &&\n          error.requiredType.inputType.find((t) => isInputArgType(t.type))) ||\n        null\n      if (inputType) {\n        expected += `\\n` + stringifyInputType(inputType.type, true)\n      }\n      return `Argument ${chalk.bold(\n        error.argName,\n      )}: Got invalid value ${chalk.redBright(valueStr)}${multilineValue ? '' : ' '\n        }on ${chalk.bold(\n          `prisma.${this.children[0].name}`,\n        )}. Provided ${chalk.redBright(\n          getGraphQLType(error.providedValue),\n        )}, expected ${expected}`\n    }\n\n    if (error.type === 'invalidNullArg') {\n      const forStr =\n        path.length === 1 && path[0] === error.name\n          ? ''\n          : ` for ${chalk.bold(`${path.join('.')}`)}`\n      const undefinedTip = ` Please use ${chalk.bold.greenBright(\n        'undefined',\n      )} instead.`\n      return `Argument ${chalk.greenBright(\n        error.name,\n      )}${forStr} must not be ${chalk.bold('null')}.${undefinedTip}`\n    }\n\n    if (error.type === 'missingArg') {\n      const forStr =\n        path.length === 1 && path[0] === error.missingName\n          ? ''\n          : ` for ${chalk.bold(`${path.join('.')}`)}`\n      return `Argument ${chalk.greenBright(\n        error.missingName,\n      )}${forStr} is missing.`\n    }\n\n    if (error.type === 'atLeastOne') {\n      const additional = minimal\n        ? ''\n        : ` Available args are listed in ${chalk.dim.green('green')}.`\n      return `Argument ${chalk.bold(path.join('.'))} of type ${chalk.bold(\n        error.inputType.name,\n      )} needs ${chalk.greenBright('at least one')} argument.${additional}`\n    }\n\n    if (error.type === 'atMostOne') {\n      const additional = minimal\n        ? ''\n        : ` Please choose one. ${chalk.dim(\n          'Available args:',\n        )} \\n${stringifyInputType(error.inputType, true)}`\n      return `Argument ${chalk.bold(path.join('.'))} of type ${chalk.bold(\n        error.inputType.name,\n      )} needs ${chalk.greenBright(\n        'exactly one',\n      )} argument, but you provided ${error.providedKeys\n        .map((key) => chalk.redBright(key))\n        .join(' and ')}.${additional}`\n    }\n  }\n  /**\n   * As we're allowing both single objects and array of objects for list inputs, we need to remove incorrect\n   * zero indexes from the path\n   * @param inputPath e.g. ['where', 'AND', 0, 'id']\n   * @param select select object\n   */\n  private normalizePath(inputPath: Array<string | number>, select: any) {\n    const path = inputPath.slice()\n    const newPath: Array<string | number> = []\n    let key: undefined | string | number\n    let pointer = select\n    // tslint:disable-next-line:no-conditional-assignment\n    while ((key = path.shift()) !== undefined) {\n      if (!Array.isArray(pointer) && key === 0) {\n        continue\n      }\n      if (key === 'select') {\n        // TODO: Remove this logic! It shouldn't be needed\n        if (!pointer[key]) {\n          pointer = pointer.include\n        } else {\n          pointer = pointer[key]\n        }\n      } else if (pointer && pointer[key]) {\n        pointer = pointer[key]\n      }\n\n      newPath.push(key)\n    }\n    return newPath\n  }\n}\n\nexport class PrismaClientValidationError extends Error { }\n\nexport interface FieldArgs {\n  name: string\n  schemaField?: DMMF.SchemaField // optional as we want to even build up invalid queries to collect all errors\n  args?: Args\n  children?: Field[]\n  error?: InvalidFieldError\n}\n\nexport class Field {\n  public readonly name: string\n  public readonly args?: Args\n  public readonly children?: Field[]\n  public readonly error?: InvalidFieldError\n  public readonly hasInvalidChild: boolean\n  public readonly hasInvalidArg: boolean\n  public readonly schemaField?: DMMF.SchemaField\n  constructor({ name, args, children, error, schemaField }: FieldArgs) {\n    this.name = name\n    this.args = args\n    this.children = children\n    this.error = error\n    this.schemaField = schemaField\n    this.hasInvalidChild = children\n      ? children.some((child) =>\n        Boolean(child.error || child.hasInvalidArg || child.hasInvalidChild),\n      )\n      : false\n    this.hasInvalidArg = args ? args.hasInvalidArg : false\n  }\n  public toString() {\n    let str = this.name\n\n    if (this.error) {\n      return str + ' # INVALID_FIELD'\n    }\n\n    if (this.args && this.args.args && this.args.args.length > 0) {\n      if (this.args.args.length === 1) {\n        str += `(${this.args.toString()})`\n      } else {\n        str += `(\\n${indent(this.args.toString(), tab)}\\n)`\n      }\n    }\n\n    if (this.children) {\n      str += ` {\n${indent(this.children.map(String).join('\\n'), tab)}\n}`\n    }\n\n    return str\n  }\n  public collectErrors(\n    prefix = 'select',\n  ): { fieldErrors: FieldError[]; argErrors: ArgError[] } {\n    const fieldErrors: FieldError[] = []\n    const argErrors: ArgError[] = []\n\n    if (this.error) {\n      fieldErrors.push({\n        path: [this.name],\n        error: this.error,\n      })\n    }\n\n    // get all errors from fields\n    if (this.children) {\n      for (const child of this.children) {\n        const errors = child.collectErrors(prefix)\n        // Field -> Field always goes through a 'select'\n        fieldErrors.push(\n          ...errors.fieldErrors.map((e) => ({\n            ...e,\n            path: [this.name, prefix, ...e.path],\n          })),\n        )\n        argErrors.push(\n          ...errors.argErrors.map((e) => ({\n            ...e,\n            path: [this.name, prefix, ...e.path],\n          })),\n        )\n      }\n    }\n\n    // get all errors from args\n    if (this.args) {\n      argErrors.push(\n        ...this.args\n          .collectErrors()\n          .map((e) => ({ ...e, path: [this.name, ...e.path] })),\n      )\n    }\n\n    return {\n      fieldErrors,\n      argErrors,\n    }\n  }\n}\n\nexport class Args {\n  public args: Arg[]\n  public readonly hasInvalidArg: boolean\n  constructor(args: Arg[] = []) {\n    this.args = args\n    this.hasInvalidArg = args\n      ? args.some((arg) => Boolean(arg.hasError))\n      : false\n  }\n  public toString() {\n    if (this.args.length === 0) {\n      return ''\n    }\n    return `${this.args\n      .map((arg) => arg.toString())\n      .filter((a) => a)\n      .join('\\n')}`\n  }\n  public collectErrors(): ArgError[] {\n    if (!this.hasInvalidArg) {\n      return []\n    }\n\n    return flatMap(this.args, (arg) => arg.collectErrors())\n  }\n}\n\n/**\n * Custom stringify which turns undefined into null - needed by GraphQL\n * @param obj to stringify\n * @param _\n * @param tab\n */\nfunction stringify(\n  obj,\n  _?: any,\n  tabbing?: string | number,\n  isEnum?: boolean,\n  isJson?: boolean,\n) {\n  if (Buffer.isBuffer(obj)) {\n    return JSON.stringify(obj.toString('base64'))\n  }\n\n  if (isJson) {\n    if (obj === null) {\n      return 'null'\n    }\n    if (obj && obj.values && obj.__prismaRawParamaters__) {\n      return JSON.stringify(obj.values)\n    }\n    return JSON.stringify(JSON.stringify(obj))\n  }\n\n  if (obj === undefined) {\n    return null\n  }\n\n  if (obj === null) {\n    return 'null'\n  }\n\n  if (Decimal.isDecimal(obj)) {\n    return obj.toString()\n  }\n\n  if (isEnum && typeof obj === 'string') {\n    return obj\n  }\n\n  if (isEnum && Array.isArray(obj)) {\n    return `[${obj.join(', ')}]`\n  }\n\n  return JSON.stringify(obj, _, tabbing)\n}\n\ninterface ArgOptions {\n  key: string\n  value: ArgValue\n  argType?: DMMF.ArgType // just needed to transform the ast\n  isEnum?: boolean\n  error?: InvalidArgError\n  schemaArg?: DMMF.SchemaArg\n}\n\nexport class Arg {\n  public key: string\n  // not readonly, as we later need to transform it\n  public value: ArgValue\n  public error?: InvalidArgError\n  public hasError: boolean\n  public isEnum: boolean\n  public schemaArg?: DMMF.SchemaArg\n  public argType?: DMMF.ArgType\n  public isNullable: boolean\n\n  constructor({\n    key,\n    value,\n    argType,\n    isEnum = false,\n    error,\n    schemaArg,\n  }: ArgOptions) {\n    this.key = key\n    this.value = value\n    this.argType = argType\n    this.isEnum = isEnum\n    this.error = error\n    this.schemaArg = schemaArg\n    this.isNullable =\n      schemaArg?.inputTypes.reduce<boolean>(\n        (isNullable, inputType) => isNullable && schemaArg.isNullable,\n        true,\n      ) || false\n    this.hasError =\n      Boolean(error) ||\n      (value instanceof Args ? value.hasInvalidArg : false) ||\n      (Array.isArray(value) &&\n        value.some((v) => (v instanceof Args ? v.hasInvalidArg : false)))\n  }\n  public _toString(value: ArgValue, key: string): string | undefined {\n    if (typeof value === 'undefined') {\n      return undefined\n    }\n\n    if (value instanceof Args) {\n      if (\n        value.args.length === 1 &&\n        value.args[0].key === 'set' &&\n        value.args[0].schemaArg?.inputTypes[0].type === 'Json'\n      ) {\n        return `${key}: {\n  set: ${stringify(value.args[0].value, null, 2, this.isEnum, true)}\n}`\n      }\n      return `${key}: {\n${indent(value.toString(), 2)}\n}`\n    }\n\n    if (Array.isArray(value)) {\n      if (this.argType === 'Json') {\n        return `${key}: ${stringify(\n          value,\n          null,\n          2,\n          this.isEnum,\n          this.argType === 'Json',\n        )}`\n      }\n\n      const isScalar = !(value as any[]).some((v) => typeof v === 'object')\n      return `${key}: [${isScalar ? '' : '\\n'}${indent(\n        (value as any[])\n          .map((nestedValue) => {\n            if (nestedValue instanceof Args) {\n              return `{\\n${indent(nestedValue.toString(), tab)}\\n}`\n            }\n            return stringify(nestedValue, null, 2, this.isEnum)\n          })\n          .join(`,${isScalar ? ' ' : '\\n'}`),\n        isScalar ? 0 : tab,\n      )}${isScalar ? '' : '\\n'}]`\n    }\n\n    return `${key}: ${stringify(\n      value,\n      null,\n      2,\n      this.isEnum,\n      this.argType === 'Json',\n    )}`\n  }\n  public toString() {\n    return this._toString(this.value, this.key)\n  }\n  public collectErrors(): ArgError[] {\n    if (!this.hasError) {\n      return []\n    }\n\n    const errors: ArgError[] = []\n\n    // add the own arg\n    if (this.error) {\n      errors.push({\n        error: this.error,\n        path: [this.key],\n      })\n    }\n\n    if (Array.isArray(this.value)) {\n      errors.push(\n        ...(flatMap(this.value as any[], (val, index) => {\n          if (!val.collectErrors) {\n            return []\n          }\n\n          return val.collectErrors().map((e) => {\n            return { ...e, path: [this.key, index, ...e.path] }\n          })\n        }) as any[]),\n      )\n    }\n\n    // collect errors of children if there are any\n    if (this.value instanceof Args) {\n      errors.push(\n        ...this.value\n          .collectErrors()\n          .map((e) => ({ ...e, path: [this.key, ...e.path] })),\n      )\n    }\n\n    return errors\n  }\n}\n\nexport type ArgValue =\n  | string\n  | boolean\n  | number\n  | undefined\n  | Args\n  | string[]\n  | boolean[]\n  | number[]\n  | Args[]\n  | null\n\nexport interface DocumentInput {\n  dmmf: DMMFClass\n  rootTypeName: 'query' | 'mutation'\n  rootField: string\n  select?: any\n}\n\nexport function makeDocument({\n  dmmf,\n  rootTypeName,\n  rootField,\n  select,\n}: DocumentInput): Document {\n  if (!select) {\n    select = {}\n  }\n  const rootType = rootTypeName === 'query' ? dmmf.queryType : dmmf.mutationType\n  // Create a fake toplevel field for easier implementation\n  const fakeRootField: DMMF.SchemaField = {\n    args: [],\n    outputType: {\n      isList: false,\n      type: rootType,\n      kind: 'object',\n    },\n    isRequired: true,\n    name: rootTypeName,\n  }\n  const children = selectionToFields(\n    dmmf,\n    { [rootField]: select },\n    fakeRootField,\n    [rootTypeName],\n  )\n  return new Document(rootTypeName, children) as any\n}\n\n// TODO: get rid of this function\nexport function transformDocument(document: Document): Document {\n  return document\n}\n\nfunction isArgsArray(input: any): input is Args[] {\n  if (Array.isArray(input)) {\n    return input.every((arg) => arg instanceof Args)\n  }\n\n  return false\n}\n\nfunction getFilterArgName(arg: string, filter: string) {\n  if (filter === 'equals') {\n    return arg\n  }\n\n  return `${arg}_${convertToSnakeCase(filter)}`\n}\n\nfunction convertToSnakeCase(str: string): string {\n  return str\n    .split(/(?=[A-Z])/)\n    .join('_')\n    .toLowerCase()\n}\n\nexport function selectionToFields(\n  dmmf: DMMFClass,\n  selection: any,\n  schemaField: DMMF.SchemaField,\n  path: string[],\n): Field[] {\n  const outputType = schemaField.outputType.type as DMMF.OutputType\n  return Object.entries(selection).reduce((acc, [name, value]: any) => {\n    const field = outputType.fieldMap\n      ? outputType.fieldMap[name]\n      : outputType.fields.find((f) => f.name === name)\n\n    if (!field) {\n      // if the field name is incorrect, we ignore the args and child fields altogether\n      acc.push(\n        new Field({\n          name,\n          children: [],\n          // @ts-ignore\n          error: {\n            type: 'invalidFieldName',\n            modelName: outputType.name,\n            providedName: name,\n            didYouMean: getSuggestion(\n              name,\n              outputType.fields.map((f) => f.name),\n            ),\n            outputType,\n          },\n        }),\n      )\n\n      return acc\n    }\n\n    if (\n      typeof value !== 'boolean' &&\n      field.outputType.kind === 'scalar' &&\n      field.name !== 'executeRaw' &&\n      field.name !== 'queryRaw' &&\n      outputType.name !== 'Query' &&\n      !name.startsWith('aggregate') &&\n      field.name !== 'count' // TODO: Find a cleaner solution\n    ) {\n      acc.push(\n        new Field({\n          name,\n          children: [],\n          error: {\n            type: 'invalidFieldType',\n            modelName: outputType.name,\n            fieldName: name,\n            providedValue: value,\n          },\n        }),\n      )\n\n      return acc\n    }\n    if (value === false) {\n      return acc\n    }\n\n    const transformedField = {\n      name: field.name,\n      fields: field.args,\n      constraints: {\n        minNumFields: null,\n        maxNumFields: null\n      }\n    }\n    const argsWithoutIncludeAndSelect =\n      typeof value === 'object' ? omit(value, ['include', 'select']) : undefined\n    const args = argsWithoutIncludeAndSelect\n      ? objectToArgs(\n        argsWithoutIncludeAndSelect,\n        transformedField,\n        [],\n        typeof field === 'string'\n          ? undefined\n          : (field.outputType.type as DMMF.OutputType),\n      )\n      : undefined\n    const isRelation = field.outputType.kind === 'object'\n\n    // TODO: use default selection for `include` again\n\n    // check for empty select\n    if (value) {\n      if (value.select && value.include) {\n        acc.push(\n          new Field({\n            name,\n            children: [\n              new Field({\n                name: 'include',\n                args: new Args(),\n                error: {\n                  type: 'includeAndSelect',\n                  field,\n                },\n              }),\n            ],\n          }),\n        )\n      } else if (value.include) {\n        const keys = Object.keys(value.include)\n\n        if (keys.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: 'include',\n                  args: new Args(),\n                  error: {\n                    type: 'emptyInclude',\n                    field,\n                  },\n                }),\n              ],\n            }),\n          )\n\n          return acc\n        }\n\n        // TODO: unify with select validation logic\n        /**\n         * Error handling for `include` statements\n         */\n        if (field.outputType.kind === 'object') {\n          const fieldOutputType = field.outputType.type as DMMF.OutputType\n          const allowedKeys = fieldOutputType.fields\n            .filter((f) => f.outputType.kind === 'object')\n            .map((f) => f.name)\n          const invalidKeys = keys.filter((key) => !allowedKeys.includes(key))\n          if (invalidKeys.length > 0) {\n            acc.push(\n              ...invalidKeys.map(\n                (invalidKey) =>\n                  new Field({\n                    name: invalidKey,\n                    children: [\n                      new Field({\n                        name: invalidKey,\n                        args: new Args(),\n                        error: {\n                          type: 'invalidFieldName',\n                          modelName: fieldOutputType.name,\n                          outputType: fieldOutputType,\n                          providedName: invalidKey,\n                          didYouMean:\n                            getSuggestion(invalidKey, allowedKeys) || undefined,\n                          isInclude: true,\n                          isIncludeScalar: fieldOutputType.fields.some(\n                            (f) => f.name === invalidKey,\n                          ),\n                        },\n                      }),\n                    ],\n                    // @ts-ignore\n                  }),\n              ),\n            )\n            return acc\n          }\n        }\n      } else if (value.select) {\n        const values = Object.values(value.select)\n        if (values.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: 'select',\n                  args: new Args(),\n                  error: {\n                    type: 'emptySelect',\n                    field,\n                  },\n                }),\n              ],\n            }),\n          )\n\n          return acc\n        }\n\n        // check if there is at least one truthy value\n        const truthyValues = values.filter((v) => v)\n        if (truthyValues.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: 'select',\n                  args: new Args(),\n                  error: {\n                    type: 'noTrueSelect',\n                    field,\n                  },\n                }),\n              ],\n            }),\n          )\n\n          return acc\n        }\n      }\n    }\n    // either use select or default selection, but not both at the same time\n    const defaultSelection = isRelation\n      ? getDefaultSelection(field.outputType.type as DMMF.OutputType)\n      : null\n    let select = defaultSelection\n    if (value) {\n      if (value.select) {\n        select = value.select\n      } else if (value.include) {\n        select = deepExtend(defaultSelection, value.include)\n      }\n    }\n    const children =\n      select !== false && isRelation\n        ? selectionToFields(dmmf, select, field, [...path, name])\n        : undefined\n\n    acc.push(new Field({ name, args, children, schemaField: field }))\n\n    return acc\n  }, [] as Field[])\n}\n\nfunction getDefaultSelection(outputType: DMMF.OutputType) {\n  return outputType.fields.reduce((acc, f) => {\n    if (f.outputType.kind === 'scalar' || f.outputType.kind === 'enum') {\n      acc[f.name] = true\n    } else {\n      // otherwise field is a relation. Only continue if it's an embedded type\n      // as normal types don't end up in the default selection\n      if ((f.outputType.type as DMMF.OutputType).isEmbedded) {\n        acc[f.name] = {\n          select: getDefaultSelection(f.outputType.type as DMMF.OutputType),\n        }\n      }\n    }\n\n    return acc\n  }, {})\n}\n\nfunction getInvalidTypeArg(\n  key: string,\n  value: any,\n  arg: DMMF.SchemaArg,\n  bestFittingType: DMMF.SchemaArgInputType,\n): Arg {\n  const arrg = new Arg({\n    key,\n    value,\n    isEnum: bestFittingType.kind === 'enum',\n    argType: bestFittingType.type,\n    error: {\n      type: 'invalidType',\n      providedValue: value,\n      argName: key,\n      requiredType: {\n        inputType: arg.inputTypes,\n\n        bestFittingType,\n      },\n    },\n  })\n\n  return arrg\n}\n\nfunction hasCorrectScalarType(\n  value: any,\n  arg: DMMF.SchemaArg,\n  inputType: DMMF.SchemaArgInputType,\n): boolean {\n  const { type, isList } = inputType\n  const expectedType = wrapWithList(stringifyGraphQLType(type), isList)\n  const graphQLType = getGraphQLType(value, type)\n\n  if (graphQLType === expectedType) {\n    return true\n  }\n\n  if (isList && graphQLType === 'List<>') {\n    return true\n  }\n\n  if (expectedType === 'Json') {\n    return true\n  }\n\n  if ((graphQLType === 'Int' || graphQLType === 'Float') && expectedType === 'Decimal') {\n    return true\n  }\n\n  // DateTime is a subset of string\n  if (graphQLType === 'DateTime' && expectedType === 'String') {\n    return true\n  }\n  if (graphQLType === 'List<DateTime>' && expectedType === 'List<String>') {\n    return true\n  }\n\n  // UUID is a subset of string\n  if (graphQLType === 'UUID' && expectedType === 'String') {\n    return true\n  }\n  if (graphQLType === 'List<UUID>' && expectedType === 'List<String>') {\n    return true\n  }\n\n  if (graphQLType === 'String' && expectedType === 'ID') {\n    return true\n  }\n  if (graphQLType === 'List<String>' && expectedType === 'List<ID>') {\n    return true\n  }\n  if (\n    expectedType === 'List<String>' &&\n    (graphQLType === 'List<String | UUID>' ||\n      graphQLType === 'List<UUID | String>')\n  ) {\n    return true\n  }\n\n  // Int is a subset of Float\n  if (graphQLType === 'Int' && expectedType === 'Float') {\n    return true\n  }\n  if (graphQLType === 'List<Int>' && expectedType === 'List<Float>') {\n    return true\n  }\n  // Int is a subset of Long\n  if (graphQLType === 'Int' && expectedType === 'Long') {\n    return true\n  }\n  if (graphQLType === 'List<Int>' && expectedType === 'List<Long>') {\n    return true\n  }\n\n  // to match all strings which are valid decimals\n  // from https://github.com/MikeMcl/decimal.js/blob/master/decimal.js#L115\n  if (graphQLType === 'String' && /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i.test(value) && expectedType === 'Decimal') {\n    return true\n  }\n\n  if (!arg.isRequired && value === null) {\n    return true\n  }\n  return false\n}\n\n\nconst cleanObject = (obj) => filterObject(obj, (k, v) => v !== undefined)\n\nfunction valueToArg(key: string, value: any, arg: DMMF.SchemaArg): Arg | null {\n  /**\n   * Go through the possible union input types.\n   * Stop on the first successful one\n   */\n  let maybeArg: Arg | null = null\n  for (const inputType of arg.inputTypes) {\n    maybeArg = tryInferArgs(key, value, arg, inputType)\n    if (maybeArg?.collectErrors().length === 0) {\n      return maybeArg\n    }\n  }\n\n  return maybeArg\n}\n\n/**\n * Running through the possible input types of a union.\n * @param key \n * @param value \n * @param arg \n * @param inputType \n */\nfunction tryInferArgs(key: string, value: any, arg: DMMF.SchemaArg, inputType: DMMF.SchemaArgInputType): Arg | null {\n  if (typeof value === 'undefined') {\n    // the arg is undefined and not required - we're fine\n    if (!arg.isRequired) {\n      return null\n    }\n\n    // the provided value is 'undefined' but shouldn't be\n    return new Arg({\n      key,\n      value,\n      isEnum: inputType.kind === 'enum',\n      error: {\n        type: 'missingArg',\n        missingName: key,\n        missingArg: arg,\n        atLeastOne: false,\n        atMostOne: false,\n      },\n    })\n  }\n\n  const { isNullable, isRequired } = arg\n\n  if (value === null && !isNullable && !isRequired) {\n    // we don't need to execute this ternery if not necessary\n    const isAtLeastOne = isInputArgType(inputType.type)\n      ? (inputType.type.constraints.minNumFields !== null && inputType.type.constraints.minNumFields > 0)\n      : false\n    if (!isAtLeastOne) {\n      return new Arg({\n        key,\n        value,\n        isEnum: inputType.kind === 'enum',\n        error: {\n          type: 'invalidNullArg',\n          name: key,\n          invalidType: arg.inputTypes,\n          atLeastOne: false,\n          atMostOne: false,\n        },\n      })\n    }\n  }\n  // then the first\n  if (!inputType.isList) {\n    if (isInputArgType(inputType.type)) {\n      if (typeof value !== 'object') {\n        return getInvalidTypeArg(key, value, arg, inputType)\n      } else {\n        let val = cleanObject(value)\n        let error: AtMostOneError | AtLeastOneError | undefined\n        const keys = Object.keys(val || {})\n        const numKeys = keys.length\n\n        if (numKeys === 0 && (typeof inputType.type.constraints.minNumFields === 'number' && inputType.type.constraints.minNumFields > 0)) {\n          // continue here\n          error = {\n            type: 'atLeastOne',\n            key,\n            inputType: inputType.type,\n          }\n        } else if (numKeys > 1 && (typeof inputType.type.constraints.maxNumFields === 'number' && inputType.type.constraints.maxNumFields < 2)) {\n          error = {\n            type: 'atMostOne',\n            key,\n            inputType: inputType.type,\n            providedKeys: keys,\n          }\n        }\n\n        return new Arg({\n          key,\n          value:\n            val === null ? null : objectToArgs(val, inputType.type, arg.inputTypes),\n          isEnum: inputType.kind === 'enum',\n          error,\n          argType: inputType.type,\n          schemaArg: arg,\n        })\n      }\n    } else {\n      return scalarToArg(key, value, arg, inputType)\n    }\n  }\n\n  // the provided arg should be a list, but isn't\n  // that's fine for us as we can just turn this into a list with a single item\n  // and GraphQL even allows this. We're going the conservative route though\n  // and actually generate the [] around the value\n\n  if (!Array.isArray(value) && inputType.isList) {\n    // TODO: This \"if condition\" is just a hack until the query engine is fixed\n    if (key !== 'updateMany') {\n      value = [value]\n    }\n  }\n\n  if (inputType.kind === 'enum' || inputType.kind === 'scalar') {\n    // if no value is incorrect\n    return scalarToArg(key, value, arg, inputType)\n  }\n\n  const argInputType = inputType.type as DMMF.InputType\n  const hasAtLeastOneError = (typeof argInputType.constraints.minNumFields === 'number' && argInputType.constraints.minNumFields > 0)\n    ? Array.isArray(value) && value.some((v) => !v || Object.keys(cleanObject(v)).length === 0)\n    : false\n  let err: AtLeastOneError | undefined | AtMostOneError = hasAtLeastOneError\n    ? {\n      inputType: argInputType,\n      key,\n      type: 'atLeastOne',\n    }\n    : undefined\n  if (!err) {\n    const hasOneOfError = (typeof argInputType.constraints.maxNumFields === 'number' && argInputType.constraints.maxNumFields < 2)\n      ? Array.isArray(value) && value.find((v) => !v || Object.keys(cleanObject(v)).length !== 1)\n      : false\n    if (hasOneOfError) {\n      err = {\n        inputType: argInputType,\n        key,\n        type: 'atMostOne',\n        providedKeys: Object.keys(hasOneOfError),\n      }\n    }\n  }\n\n  if (!Array.isArray(value)) {\n    for (const argInputType of arg.inputTypes) {\n      const args = objectToArgs(value, argInputType.type as DMMF.InputType)\n      if (args.collectErrors().length === 0) {\n        return new Arg({ key, value: args, isEnum: false, argType: argInputType.type, schemaArg: arg, })\n      }\n    }\n  }\n\n\n  return new Arg({\n    key,\n    value: value.map((v) => {\n      if ((inputType.isList) && typeof v !== 'object') {\n        return v\n      }\n      if (typeof v !== 'object' || !value) {\n        return getInvalidTypeArg(key, v, arg, inputType)\n      }\n      return objectToArgs(v, argInputType)\n    }),\n    isEnum: false,\n    argType: argInputType,\n    schemaArg: arg,\n    error: err,\n  })\n}\n\nexport function isInputArgType(\n  argType: DMMF.ArgType,\n): argType is DMMF.InputType {\n  if (typeof argType === 'string') {\n    return false\n  }\n  if (argType.hasOwnProperty('values')) {\n    return false\n  }\n\n  return true\n}\n\nfunction scalarToArg(\n  key: string,\n  value: any,\n  arg: DMMF.SchemaArg,\n  inputType: DMMF.SchemaArgInputType,\n): Arg {\n  if (hasCorrectScalarType(value, arg, inputType)) {\n    return new Arg({\n      key,\n      value,\n      isEnum: arg.inputTypes[0].kind === 'enum',\n      argType: inputType.type,\n      schemaArg: arg,\n    })\n  }\n  return getInvalidTypeArg(key, value, arg, inputType)\n}\n\nfunction objectToArgs(\n  initialObj: any,\n  inputType: DMMF.InputType,\n  possibilities?: DMMF.SchemaArgInputType[],\n  outputType?: DMMF.OutputType,\n): Args {\n  // filter out undefined values and treat them if they weren't provided\n  const obj = cleanObject(initialObj)\n  const { fields: args, fieldMap } = inputType\n  const requiredArgs: any = args\n    .map((arg) => [arg.name, undefined])\n  const objEntries = Object.entries(obj || {})\n  const entries = unionBy(objEntries, requiredArgs, (a) => a[0])\n  const argsList = entries.reduce((acc, [argName, value]: any) => {\n    const schemaArg = fieldMap\n      ? fieldMap[argName]\n      : args.find((a) => a.name === argName)\n    if (!schemaArg) {\n      const didYouMeanField =\n        typeof value === 'boolean' &&\n          outputType &&\n          outputType.fields.some((f) => f.name === argName)\n          ? argName\n          : null\n      acc.push(\n        new Arg({\n          key: argName,\n          value,\n          error: {\n            type: 'invalidName',\n            providedName: argName,\n            providedValue: value,\n            didYouMeanField,\n            didYouMeanArg:\n              (!didYouMeanField &&\n                getSuggestion(argName, [\n                  ...args.map((a) => a.name),\n                  'select',\n                ])) ||\n              undefined,\n            originalType: inputType,\n            possibilities,\n            outputType,\n          },\n        }),\n      )\n      return acc\n    }\n\n    const arg = valueToArg(argName, value, schemaArg)\n\n    if (arg) {\n      acc.push(arg)\n    }\n\n    return acc\n  }, [] as Arg[])\n  // Also show optional neighbour args, if there is any arg missing\n  if (\n    (typeof inputType.constraints.minNumFields === 'number' && objEntries.length < inputType.constraints.minNumFields) ||\n    argsList.find((arg) => (arg.error?.type === 'missingArg' || arg.error?.type === 'atLeastOne'))\n  ) {\n    const optionalMissingArgs = inputType.fields.filter(\n      field => !field.isRequired && (obj && (typeof obj[field.name] === 'undefined' || obj[field.name] === null))\n    )\n    argsList.push(\n      ...optionalMissingArgs.map((arg) => {\n        const argInputType = arg.inputTypes[0]\n        return new Arg({\n          key: arg.name,\n          value: undefined,\n          isEnum: argInputType.kind === 'enum',\n          error: {\n            type: 'missingArg',\n            missingName: arg.name,\n            missingArg: arg,\n            atLeastOne: Boolean(inputType.constraints.minNumFields) || false,\n            atMostOne: inputType.constraints.maxNumFields === 1 || false,\n          },\n        })\n      }),\n    )\n  }\n  return new Args(argsList)\n}\n\nexport interface UnpackOptions {\n  document: Document\n  path: string[]\n  data: any\n}\n\n/**\n * Unpacks the result of a data object and maps DateTime fields to instances of `Date` inplace\n * @param options: UnpackOptions\n */\nexport function unpack({ document, path, data }: UnpackOptions): any {\n  const result = deepGet(data, path)\n\n  if (result === 'undefined') {\n    return null\n  }\n\n  if (typeof result !== 'object') {\n    return result\n  }\n\n  const field = getField(document, path)\n\n  return mapScalars({ field, data: result })\n}\n\nexport interface MapScalarsOptions {\n  field: Field\n  data: any\n}\n\nexport function mapScalars({ field, data }: MapScalarsOptions): any {\n  if (\n    !data ||\n    typeof data !== 'object' ||\n    !field.children ||\n    !field.schemaField\n  ) {\n    return data\n  }\n\n  const deserializers = {\n    'DateTime': value => new Date(value),\n    'Json': value => JSON.parse(value),\n    'Bytes': value => Buffer.from(value, 'base64'),\n    'Decimal': value => {\n      return new Decimal(value)\n    }\n  }\n\n  for (const child of field.children) {\n    const outputType = child.schemaField?.outputType.type\n    if (outputType && typeof outputType === 'string') {\n      const deserializer = deserializers[outputType]\n      if (deserializer) {\n        if (Array.isArray(data)) {\n          for (const entry of data) {\n            // in the very unlikely case, that a field is not there in the result, ignore it\n            if (typeof entry[child.name] !== 'undefined' && entry[child.name] !== null) {\n              entry[child.name] = deserializer(entry[child.name])\n            }\n          }\n        } else {\n          // same here, ignore it if it's undefined\n          if (typeof data[child.name] !== 'undefined' && data[child.name] !== null) {\n            data[child.name] = deserializer(data[child.name])\n          }\n        }\n      }\n    }\n\n    if (child.schemaField && child.schemaField.outputType.kind === 'object') {\n      if (Array.isArray(data)) {\n        for (const entry of data) {\n          mapScalars({ field: child, data: entry[child.name] })\n        }\n      } else {\n        mapScalars({ field: child, data: data[child.name] })\n      }\n    }\n  }\n\n  return data\n}\n\nexport function getField(document: Document, path: string[]): Field {\n  const todo = path.slice() // let's create a copy to not fiddle with the input argument\n  const firstElement = todo.shift()\n  // this might be slow because of the find\n  let pointer = document.children.find((c) => c.name === firstElement)\n\n  if (!pointer) {\n    throw new Error(\n      `Could not find field ${firstElement} in document ${document}`,\n    )\n  }\n\n  while (todo.length > 0) {\n    const key = todo.shift()\n    if (!pointer!.children) {\n      throw new Error(\n        `Can't get children for field ${pointer} with child ${key}`,\n      )\n    }\n    const child = pointer!.children.find((c) => c.name === key)\n    if (!child) {\n      throw new Error(`Can't find child ${key} of field ${pointer}`)\n    }\n    pointer = child!\n  }\n\n  return pointer!\n}\n\nfunction removeSelectFromPath(path: string): string {\n  return path\n    .split('.')\n    .filter((p) => p !== 'select')\n    .join('.')\n}\n\nfunction removeSelectFromObject(obj: object): object {\n  const type = Object.prototype.toString.call(obj)\n  if (type === '[object Object]') {\n    const copy = {}\n    for (const key in obj) {\n      if (key === 'select') {\n        for (const subKey in obj['select']) {\n          copy[subKey] = removeSelectFromObject(obj['select'][subKey])\n        }\n      } else {\n        copy[key] = removeSelectFromObject(obj[key])\n      }\n    }\n    return copy\n  }\n\n  return obj\n}\n\nfunction transformAggregatePrintJsonArgs({\n  ast,\n  keyPaths,\n  missingItems,\n  valuePaths,\n}: PrintJsonWithErrorsArgs): PrintJsonWithErrorsArgs {\n  const newKeyPaths = keyPaths.map(removeSelectFromPath)\n  const newValuePaths = valuePaths.map(removeSelectFromPath)\n  const newMissingItems = missingItems.map((item) => ({\n    path: removeSelectFromPath(item.path),\n    isRequired: item.isRequired,\n    type: item.type,\n  }))\n\n  const newAst = removeSelectFromObject(ast)\n  return {\n    ast: newAst,\n    keyPaths: newKeyPaths,\n    missingItems: newMissingItems,\n    valuePaths: newValuePaths,\n  }\n}\n", "import chalk from 'chalk'\nimport indent from 'indent-string'\nimport { /*dmmf, */ DMMFClass } from './dmmf'\nimport { DMMF } from './dmmf-types'\nimport {\n  ArgError,\n  AtLeastOneError,\n  AtMostOneError,\n  FieldError,\n  InvalidArgError,\n  InvalidFieldError,\n  MissingArgError,\n} from './error-types'\nimport {\n  getGraphQLType,\n  getInputTypeName,\n  getOutputTypeName,\n  getSuggestion,\n  inputTypeToJson,\n  stringifyGraphQLType,\n  stringifyInputType,\n  unionBy,\n  wrapWithList,\n} from './utils/common'\nimport { deepExtend } from './utils/deep-extend'\nimport { deepGet } from './utils/deep-set'\nimport { filterObject } from './utils/filterObject'\nimport { omit } from './utils/omit'\nimport {\n  MissingItem,\n  printJsonWithErrors,\n  PrintJsonWithErrorsArgs,\n} from './utils/printJsonErrors'\nimport { printStack } from './utils/printStack'\nimport stringifyObject from './utils/stringifyObject'\nimport stripAnsi from 'strip-ansi'\nimport { flatMap } from './utils/flatMap'\nimport Decimal from 'decimal.js'\n\nconst tab = 2\n\nexport class Document {\n  constructor(\n    public readonly type: 'query' | 'mutation',\n    public readonly children: Field[],\n  ) {\n    this.type = type\n    this.children = children\n  }\n  public toString() {\n    return `${this.type} {\n${indent(this.children.map(String).join('\\n'), tab)}\n}`\n  }\n  public validate(\n    select?: any,\n    isTopLevelQuery: boolean = false,\n    originalMethod?: string,\n    errorFormat?: 'pretty' | 'minimal' | 'colorless',\n    validationCallsite?: any,\n  ) {\n    if (!select) {\n      select = {}\n    }\n    const invalidChildren = this.children.filter(\n      (child) => child.hasInvalidChild || child.hasInvalidArg,\n    )\n    if (invalidChildren.length === 0) {\n      return\n    }\n\n    const fieldErrors: FieldError[] = []\n    const argErrors: ArgError[] = []\n    const prefix =\n      select && select.select\n        ? 'select'\n        : select.include\n          ? 'include'\n          : undefined\n\n    for (const child of invalidChildren) {\n      const errors = child.collectErrors(prefix)\n      fieldErrors.push(\n        ...errors.fieldErrors.map((e) => ({\n          ...e,\n          path: isTopLevelQuery ? e.path : e.path.slice(1),\n        })),\n      )\n      argErrors.push(\n        ...errors.argErrors.map((e) => ({\n          ...e,\n          path: isTopLevelQuery ? e.path : e.path.slice(1),\n        })),\n      )\n    }\n\n    const topLevelQueryName = this.children[0].name\n    const queryName = isTopLevelQuery ? this.type : topLevelQueryName\n    const keyPaths: string[] = []\n    const valuePaths: string[] = []\n    const missingItems: MissingItem[] = []\n    for (const fieldError of fieldErrors) {\n      const path = this.normalizePath(fieldError.path, select).join('.')\n      if (fieldError.error.type === 'invalidFieldName') {\n        keyPaths.push(path)\n\n        const fieldType = fieldError.error.outputType\n        const { isInclude } = fieldError.error\n        fieldType.fields\n          .filter((field) =>\n            isInclude ? field.outputType.kind === 'object' : true,\n          )\n          .forEach((field) => {\n            const splittedPath = path.split('.')\n            missingItems.push({\n              path: `${splittedPath\n                .slice(0, splittedPath.length - 1)\n                .join('.')}.${field.name}`,\n              type: 'true',\n              isRequired: false,\n            })\n          })\n      } else if (fieldError.error.type === 'includeAndSelect') {\n        keyPaths.push('select')\n        keyPaths.push('include')\n      } else {\n        valuePaths.push(path)\n      }\n      if (\n        fieldError.error.type === 'emptySelect' ||\n        fieldError.error.type === 'noTrueSelect' ||\n        fieldError.error.type === 'emptyInclude'\n      ) {\n        const selectPathArray = this.normalizePath(fieldError.path, select)\n        const selectPath = selectPathArray\n          .slice(0, selectPathArray.length - 1)\n          .join('.')\n\n        const fieldType = fieldError.error.field.outputType\n          .type as DMMF.OutputType\n\n        fieldType.fields\n          .filter((field) =>\n            fieldError.error.type === 'emptyInclude'\n              ? field.outputType.kind === 'object'\n              : true,\n          )\n          .forEach((field) => {\n            missingItems.push({\n              path: `${selectPath}.${field.name}`,\n              type: 'true',\n              isRequired: false,\n            })\n          })\n      }\n    }\n    // an arg error can either be an invalid key or invalid value\n    for (const argError of argErrors) {\n      const path = this.normalizePath(argError.path, select).join('.')\n      if (argError.error.type === 'invalidName') {\n        keyPaths.push(path)\n      } else if (\n        argError.error.type !== 'missingArg' &&\n        argError.error.type !== 'atLeastOne'\n      ) {\n        valuePaths.push(path)\n      } else if (argError.error.type === 'missingArg') {\n        const type =\n          argError.error.missingArg.inputTypes.length === 1\n            ? argError.error.missingArg.inputTypes[0].type\n            : argError.error.missingArg.inputTypes\n              .map((t) => {\n                const inputTypeName = getInputTypeName(t.type)\n                if (inputTypeName === 'Null') {\n                  return 'null'\n                }\n                if (t.isList) {\n                  return inputTypeName + '[]'\n                }\n                return inputTypeName\n              })\n              .join(' | ')\n        missingItems.push({\n          path,\n          type: inputTypeToJson(type, true, path.split('where.').length === 2),\n          isRequired: argError.error.missingArg.isRequired\n        })\n      }\n    }\n\n    const renderErrorStr = (callsite?: string) => {\n      const hasRequiredMissingArgsErrors = argErrors.some(\n        (e) =>\n          e.error.type === 'missingArg' && e.error.missingArg.isRequired,\n      )\n      const hasOptionalMissingArgsErrors = Boolean(argErrors.find(\n        (e) =>\n          e.error.type === 'missingArg' && !e.error.missingArg.isRequired,\n      ))\n      const hasMissingArgsErrors =\n        hasOptionalMissingArgsErrors || hasRequiredMissingArgsErrors\n\n      let missingArgsLegend = ''\n      if (hasRequiredMissingArgsErrors) {\n        missingArgsLegend += `\\n${chalk.dim(\n          'Note: Lines with ',\n        )}${chalk.reset.greenBright('+')} ${chalk.dim('are required')}`\n      }\n\n      if (hasOptionalMissingArgsErrors) {\n        if (missingArgsLegend.length === 0) {\n          missingArgsLegend = '\\n'\n        }\n        if (hasRequiredMissingArgsErrors) {\n          missingArgsLegend += chalk.dim(\n            `, lines with ${chalk.green('?')} are optional`,\n          )\n        } else {\n          missingArgsLegend += chalk.dim(\n            `Note: Lines with ${chalk.green('?')} are optional`,\n          )\n        }\n        missingArgsLegend += chalk.dim('.')\n      }\n\n      const errorMessages = `${argErrors\n        .filter(\n          (e) =>\n            e.error.type !== 'missingArg' || e.error.missingArg.isRequired,\n        )\n        .map((e) =>\n          this.printArgError(\n            e,\n            hasMissingArgsErrors,\n            errorFormat === 'minimal',\n          ),\n        ) // if no callsite is provided, just render the minimal error\n        .join('\\n')}\n${fieldErrors\n          .map((e) => this.printFieldError(e, missingItems, errorFormat === 'minimal'))\n          .join('\\n')}`\n\n      if (errorFormat === 'minimal') {\n        return stripAnsi(errorMessages)\n      }\n\n      const { stack, indent: indentValue, afterLines } = printStack({\n        callsite,\n        originalMethod: originalMethod || queryName,\n        showColors: errorFormat && errorFormat === 'pretty',\n        isValidationError: true,\n      })\n\n      let printJsonArgs: PrintJsonWithErrorsArgs = {\n        ast: isTopLevelQuery ? { [topLevelQueryName]: select } : select,\n        keyPaths,\n        valuePaths,\n        missingItems,\n      }\n\n      // as for aggregate we simplify the api to not include `select`\n      // we need to map this here so the errors make sense\n      if (originalMethod?.endsWith('aggregate')) {\n        printJsonArgs = transformAggregatePrintJsonArgs(printJsonArgs)\n      }\n\n      const errorStr = `${stack}${indent(\n        printJsonWithErrors(printJsonArgs),\n        indentValue,\n      ).slice(indentValue)}${chalk.dim(afterLines)}\n\n${errorMessages}${missingArgsLegend}\\n`\n\n      if (process.env.NO_COLOR || errorFormat === 'colorless') {\n        return stripAnsi(errorStr)\n      }\n      return errorStr\n    }\n    // end renderErrorStr definition\n\n    const error = new PrismaClientValidationError(\n      renderErrorStr(validationCallsite),\n    )\n\n    // @ts-ignore\n    if (process.env.NODE_ENV !== 'production') {\n      Object.defineProperty(error, 'render', {\n        get: () => renderErrorStr,\n        enumerable: false,\n      })\n    }\n    throw error\n  }\n  protected printFieldError = (\n    { error, path }: FieldError,\n    missingItems: MissingItem[],\n    minimal: boolean,\n  ) => {\n    if (error.type === 'emptySelect') {\n      const additional = minimal\n        ? ''\n        : ` Available options are listed in ${chalk.greenBright.dim('green')}.`\n      return `The ${chalk.redBright(\n        '`select`',\n      )} statement for type ${chalk.bold(\n        getOutputTypeName(error.field.outputType.type),\n      )} must not be empty.${additional}`\n    }\n    if (error.type === 'emptyInclude') {\n      if (missingItems.length === 0) {\n        return `${chalk.bold(\n          getOutputTypeName(error.field.outputType.type),\n        )} does not have any relation and therefore can't have an ${chalk.redBright(\n          '`include`',\n        )} statement.`\n      }\n      const additional = minimal\n        ? ''\n        : ` Available options are listed in ${chalk.greenBright.dim('green')}.`\n      return `The ${chalk.redBright(\n        '`include`',\n      )} statement for type ${chalk.bold(\n        getOutputTypeName(error.field.outputType.type),\n      )} must not be empty.${additional}`\n    }\n    if (error.type === 'noTrueSelect') {\n      return `The ${chalk.redBright(\n        '`select`',\n      )} statement for type ${chalk.bold(\n        getOutputTypeName(error.field.outputType.type),\n      )} needs ${chalk.bold('at least one truthy value')}.`\n    }\n    if (error.type === 'includeAndSelect') {\n      return `Please ${chalk.bold('either')} use ${chalk.greenBright(\n        '`include`',\n      )} or ${chalk.greenBright('`select`')}, but ${chalk.redBright(\n        'not both',\n      )} at the same time.`\n    }\n    if (error.type === 'invalidFieldName') {\n      const statement = error.isInclude ? 'include' : 'select'\n      const wording = error.isIncludeScalar ? 'Invalid scalar' : 'Unknown'\n      const additional = minimal\n        ? ''\n        : error.isInclude && missingItems.length === 0\n          ? `\\nThis model has no relations, so you can't use ${chalk.redBright(\n            'include',\n          )} with it.`\n          : ` Available options are listed in ${chalk.greenBright.dim('green')}.`\n      let str = `${wording} field ${chalk.redBright(\n        `\\`${error.providedName}\\``,\n      )} for ${chalk.bold(statement)} statement on model ${chalk.bold.white(\n        error.modelName,\n      )}.${additional}`\n\n      if (error.didYouMean) {\n        str += ` Did you mean ${chalk.greenBright(`\\`${error.didYouMean}\\``)}?`\n      }\n\n      if (error.isIncludeScalar) {\n        str += `\\nNote, that ${chalk.bold(\n          'include',\n        )} statements only accept relation fields.`\n      }\n\n      return str\n    }\n    if (error.type === 'invalidFieldType') {\n      const str = `Invalid value ${chalk.redBright(\n        `${stringifyObject(error.providedValue)}`,\n      )} of type ${chalk.redBright(\n        getGraphQLType(error.providedValue, undefined),\n      )} for field ${chalk.bold(\n        `${error.fieldName}`,\n      )} on model ${chalk.bold.white(\n        error.modelName,\n      )}. Expected either ${chalk.greenBright('true')} or ${chalk.greenBright(\n        'false',\n      )}.`\n\n      return str\n    }\n  }\n  protected printArgError = (\n    { error, path }: ArgError,\n    hasMissingItems: boolean,\n    minimal: boolean,\n  ) => {\n    if (error.type === 'invalidName') {\n      let str = `Unknown arg ${chalk.redBright(\n        `\\`${error.providedName}\\``,\n      )} in ${chalk.bold(path.join('.'))} for type ${chalk.bold(\n        error.outputType\n          ? error.outputType.name\n          : getInputTypeName(error.originalType),\n      )}.`\n      if (error.didYouMeanField) {\n        str += `\\n\u2192 Did you forget to wrap it with \\`${chalk.greenBright(\n          'select',\n        )}\\`? ${chalk.dim(\n          'e.g. ' +\n          chalk.greenBright(\n            `{ select: { ${error.providedName}: ${error.providedValue} } }`,\n          ),\n        )}`\n      } else if (error.didYouMeanArg) {\n        str += ` Did you mean \\`${chalk.greenBright(error.didYouMeanArg)}\\`?`\n        if (!hasMissingItems && !minimal) {\n          str +=\n            ` ${chalk.dim('Available args:')}\\n` +\n            stringifyInputType(error.originalType, true)\n        }\n      } else {\n        if ((error.originalType as DMMF.InputType).fields.length === 0) {\n          str += ` The field ${chalk.bold(\n            (error.originalType as DMMF.InputType).name,\n          )} has no arguments.`\n        } else if (!hasMissingItems && !minimal) {\n          str +=\n            ` Available args:\\n\\n` +\n            stringifyInputType(error.originalType, true)\n        }\n      }\n      return str\n    }\n\n    if (error.type === 'invalidType') {\n      let valueStr = stringifyObject(error.providedValue, { indent: '  ' })\n      const multilineValue = valueStr.split('\\n').length > 1\n      if (multilineValue) {\n        valueStr = `\\n${valueStr}\\n`\n      }\n      // TODO: we don't yet support enums in a union with a non enum. This is mostly due to not implemented error handling\n      // at this code part.\n      if (error.requiredType.bestFittingType.kind === 'enum') {\n        return `Argument ${chalk.bold(\n          error.argName,\n        )}: Provided value ${chalk.redBright(valueStr)}${multilineValue ? '' : ' '\n          }of type ${chalk.redBright(\n            getGraphQLType(error.providedValue),\n          )} on ${chalk.bold(\n            `prisma.${this.children[0].name}`,\n          )} is not a ${chalk.greenBright(\n            wrapWithList(\n              stringifyGraphQLType(error.requiredType.bestFittingType.kind),\n              error.requiredType.bestFittingType.isList,\n            ),\n          )}.\n\u2192 Possible values: ${(error.requiredType.bestFittingType\n            .type as DMMF.SchemaEnum).values\n            .map((v) =>\n              chalk.greenBright(\n                `${stringifyGraphQLType(\n                  error.requiredType.bestFittingType.type,\n                )}.${v}`,\n              ),\n            )\n            .join(', ')}`\n      }\n\n      let typeStr = '.'\n      if (isInputArgType(error.requiredType.bestFittingType.type)) {\n        typeStr =\n          ':\\n' + stringifyInputType(error.requiredType.bestFittingType.type)\n      }\n      let expected = `${error.requiredType.inputType\n        .map((t) =>\n          chalk.greenBright(\n            wrapWithList(\n              stringifyGraphQLType(t.type),\n              error.requiredType.bestFittingType.isList,\n            ),\n          ),\n        )\n        .join(' or ')}${typeStr}`\n      const inputType: null | DMMF.SchemaArgInputType =\n        (error.requiredType.inputType.length === 2 &&\n          error.requiredType.inputType.find((t) => isInputArgType(t.type))) ||\n        null\n      if (inputType) {\n        expected += `\\n` + stringifyInputType(inputType.type, true)\n      }\n      return `Argument ${chalk.bold(\n        error.argName,\n      )}: Got invalid value ${chalk.redBright(valueStr)}${multilineValue ? '' : ' '\n        }on ${chalk.bold(\n          `prisma.${this.children[0].name}`,\n        )}. Provided ${chalk.redBright(\n          getGraphQLType(error.providedValue),\n        )}, expected ${expected}`\n    }\n\n    if (error.type === 'invalidNullArg') {\n      const forStr =\n        path.length === 1 && path[0] === error.name\n          ? ''\n          : ` for ${chalk.bold(`${path.join('.')}`)}`\n      const undefinedTip = ` Please use ${chalk.bold.greenBright(\n        'undefined',\n      )} instead.`\n      return `Argument ${chalk.greenBright(\n        error.name,\n      )}${forStr} must not be ${chalk.bold('null')}.${undefinedTip}`\n    }\n\n    if (error.type === 'missingArg') {\n      const forStr =\n        path.length === 1 && path[0] === error.missingName\n          ? ''\n          : ` for ${chalk.bold(`${path.join('.')}`)}`\n      return `Argument ${chalk.greenBright(\n        error.missingName,\n      )}${forStr} is missing.`\n    }\n\n    if (error.type === 'atLeastOne') {\n      const additional = minimal\n        ? ''\n        : ` Available args are listed in ${chalk.dim.green('green')}.`\n      return `Argument ${chalk.bold(path.join('.'))} of type ${chalk.bold(\n        error.inputType.name,\n      )} needs ${chalk.greenBright('at least one')} argument.${additional}`\n    }\n\n    if (error.type === 'atMostOne') {\n      const additional = minimal\n        ? ''\n        : ` Please choose one. ${chalk.dim(\n          'Available args:',\n        )} \\n${stringifyInputType(error.inputType, true)}`\n      return `Argument ${chalk.bold(path.join('.'))} of type ${chalk.bold(\n        error.inputType.name,\n      )} needs ${chalk.greenBright(\n        'exactly one',\n      )} argument, but you provided ${error.providedKeys\n        .map((key) => chalk.redBright(key))\n        .join(' and ')}.${additional}`\n    }\n  }\n  /**\n   * As we're allowing both single objects and array of objects for list inputs, we need to remove incorrect\n   * zero indexes from the path\n   * @param inputPath e.g. ['where', 'AND', 0, 'id']\n   * @param select select object\n   */\n  private normalizePath(inputPath: Array<string | number>, select: any) {\n    const path = inputPath.slice()\n    const newPath: Array<string | number> = []\n    let key: undefined | string | number\n    let pointer = select\n    // tslint:disable-next-line:no-conditional-assignment\n    while ((key = path.shift()) !== undefined) {\n      if (!Array.isArray(pointer) && key === 0) {\n        continue\n      }\n      if (key === 'select') {\n        // TODO: Remove this logic! It shouldn't be needed\n        if (!pointer[key]) {\n          pointer = pointer.include\n        } else {\n          pointer = pointer[key]\n        }\n      } else if (pointer && pointer[key]) {\n        pointer = pointer[key]\n      }\n\n      newPath.push(key)\n    }\n    return newPath\n  }\n}\n\nexport class PrismaClientValidationError extends Error { }\n\nexport interface FieldArgs {\n  name: string\n  schemaField?: DMMF.SchemaField // optional as we want to even build up invalid queries to collect all errors\n  args?: Args\n  children?: Field[]\n  error?: InvalidFieldError\n}\n\nexport class Field {\n  public readonly name: string\n  public readonly args?: Args\n  public readonly children?: Field[]\n  public readonly error?: InvalidFieldError\n  public readonly hasInvalidChild: boolean\n  public readonly hasInvalidArg: boolean\n  public readonly schemaField?: DMMF.SchemaField\n  constructor({ name, args, children, error, schemaField }: FieldArgs) {\n    this.name = name\n    this.args = args\n    this.children = children\n    this.error = error\n    this.schemaField = schemaField\n    this.hasInvalidChild = children\n      ? children.some((child) =>\n        Boolean(child.error || child.hasInvalidArg || child.hasInvalidChild),\n      )\n      : false\n    this.hasInvalidArg = args ? args.hasInvalidArg : false\n  }\n  public toString() {\n    let str = this.name\n\n    if (this.error) {\n      return str + ' # INVALID_FIELD'\n    }\n\n    if (this.args && this.args.args && this.args.args.length > 0) {\n      if (this.args.args.length === 1) {\n        str += `(${this.args.toString()})`\n      } else {\n        str += `(\\n${indent(this.args.toString(), tab)}\\n)`\n      }\n    }\n\n    if (this.children) {\n      str += ` {\n${indent(this.children.map(String).join('\\n'), tab)}\n}`\n    }\n\n    return str\n  }\n  public collectErrors(\n    prefix = 'select',\n  ): { fieldErrors: FieldError[]; argErrors: ArgError[] } {\n    const fieldErrors: FieldError[] = []\n    const argErrors: ArgError[] = []\n\n    if (this.error) {\n      fieldErrors.push({\n        path: [this.name],\n        error: this.error,\n      })\n    }\n\n    // get all errors from fields\n    if (this.children) {\n      for (const child of this.children) {\n        const errors = child.collectErrors(prefix)\n        // Field -> Field always goes through a 'select'\n        fieldErrors.push(\n          ...errors.fieldErrors.map((e) => ({\n            ...e,\n            path: [this.name, prefix, ...e.path],\n          })),\n        )\n        argErrors.push(\n          ...errors.argErrors.map((e) => ({\n            ...e,\n            path: [this.name, prefix, ...e.path],\n          })),\n        )\n      }\n    }\n\n    // get all errors from args\n    if (this.args) {\n      argErrors.push(\n        ...this.args\n          .collectErrors()\n          .map((e) => ({ ...e, path: [this.name, ...e.path] })),\n      )\n    }\n\n    return {\n      fieldErrors,\n      argErrors,\n    }\n  }\n}\n\nexport class Args {\n  public args: Arg[]\n  public readonly hasInvalidArg: boolean\n  constructor(args: Arg[] = []) {\n    this.args = args\n    this.hasInvalidArg = args\n      ? args.some((arg) => Boolean(arg.hasError))\n      : false\n  }\n  public toString() {\n    if (this.args.length === 0) {\n      return ''\n    }\n    return `${this.args\n      .map((arg) => arg.toString())\n      .filter((a) => a)\n      .join('\\n')}`\n  }\n  public collectErrors(): ArgError[] {\n    if (!this.hasInvalidArg) {\n      return []\n    }\n\n    return flatMap(this.args, (arg) => arg.collectErrors())\n  }\n}\n\n/**\n * Custom stringify which turns undefined into null - needed by GraphQL\n * @param obj to stringify\n * @param _\n * @param tab\n */\nfunction stringify(\n  obj,\n  _?: any,\n  tabbing?: string | number,\n  isEnum?: boolean,\n  isJson?: boolean,\n) {\n  if (Buffer.isBuffer(obj)) {\n    return JSON.stringify(obj.toString('base64'))\n  }\n\n  if (isJson) {\n    if (obj === null) {\n      return 'null'\n    }\n    if (obj && obj.values && obj.__prismaRawParamaters__) {\n      return JSON.stringify(obj.values)\n    }\n    return JSON.stringify(JSON.stringify(obj))\n  }\n\n  if (obj === undefined) {\n    return null\n  }\n\n  if (obj === null) {\n    return 'null'\n  }\n\n  if (Decimal.isDecimal(obj)) {\n    return obj.toString()\n  }\n\n  if (isEnum && typeof obj === 'string') {\n    return obj\n  }\n\n  if (isEnum && Array.isArray(obj)) {\n    return `[${obj.join(', ')}]`\n  }\n\n  return JSON.stringify(obj, _, tabbing)\n}\n\ninterface ArgOptions {\n  key: string\n  value: ArgValue\n  argType?: DMMF.ArgType // just needed to transform the ast\n  isEnum?: boolean\n  error?: InvalidArgError\n  schemaArg?: DMMF.SchemaArg\n}\n\nexport class Arg {\n  public key: string\n  // not readonly, as we later need to transform it\n  public value: ArgValue\n  public error?: InvalidArgError\n  public hasError: boolean\n  public isEnum: boolean\n  public schemaArg?: DMMF.SchemaArg\n  public argType?: DMMF.ArgType\n  public isNullable: boolean\n\n  constructor({\n    key,\n    value,\n    argType,\n    isEnum = false,\n    error,\n    schemaArg,\n  }: ArgOptions) {\n    this.key = key\n    this.value = value\n    this.argType = argType\n    this.isEnum = isEnum\n    this.error = error\n    this.schemaArg = schemaArg\n    this.isNullable =\n      schemaArg?.inputTypes.reduce<boolean>(\n        (isNullable, inputType) => isNullable && schemaArg.isNullable,\n        true,\n      ) || false\n    this.hasError =\n      Boolean(error) ||\n      (value instanceof Args ? value.hasInvalidArg : false) ||\n      (Array.isArray(value) &&\n        value.some((v) => (v instanceof Args ? v.hasInvalidArg : false)))\n  }\n  public _toString(value: ArgValue, key: string): string | undefined {\n    if (typeof value === 'undefined') {\n      return undefined\n    }\n\n    if (value instanceof Args) {\n      if (\n        value.args.length === 1 &&\n        value.args[0].key === 'set' &&\n        value.args[0].schemaArg?.inputTypes[0].type === 'Json'\n      ) {\n        return `${key}: {\n  set: ${stringify(value.args[0].value, null, 2, this.isEnum, true)}\n}`\n      }\n      return `${key}: {\n${indent(value.toString(), 2)}\n}`\n    }\n\n    if (Array.isArray(value)) {\n      if (this.argType === 'Json') {\n        return `${key}: ${stringify(\n          value,\n          null,\n          2,\n          this.isEnum,\n          this.argType === 'Json',\n        )}`\n      }\n\n      const isScalar = !(value as any[]).some((v) => typeof v === 'object')\n      return `${key}: [${isScalar ? '' : '\\n'}${indent(\n        (value as any[])\n          .map((nestedValue) => {\n            if (nestedValue instanceof Args) {\n              return `{\\n${indent(nestedValue.toString(), tab)}\\n}`\n            }\n            return stringify(nestedValue, null, 2, this.isEnum)\n          })\n          .join(`,${isScalar ? ' ' : '\\n'}`),\n        isScalar ? 0 : tab,\n      )}${isScalar ? '' : '\\n'}]`\n    }\n\n    return `${key}: ${stringify(\n      value,\n      null,\n      2,\n      this.isEnum,\n      this.argType === 'Json',\n    )}`\n  }\n  public toString() {\n    return this._toString(this.value, this.key)\n  }\n  public collectErrors(): ArgError[] {\n    if (!this.hasError) {\n      return []\n    }\n\n    const errors: ArgError[] = []\n\n    // add the own arg\n    if (this.error) {\n      errors.push({\n        error: this.error,\n        path: [this.key],\n      })\n    }\n\n    if (Array.isArray(this.value)) {\n      errors.push(\n        ...(flatMap(this.value as any[], (val, index) => {\n          if (!val.collectErrors) {\n            return []\n          }\n\n          return val.collectErrors().map((e) => {\n            return { ...e, path: [this.key, index, ...e.path] }\n          })\n        }) as any[]),\n      )\n    }\n\n    // collect errors of children if there are any\n    if (this.value instanceof Args) {\n      errors.push(\n        ...this.value\n          .collectErrors()\n          .map((e) => ({ ...e, path: [this.key, ...e.path] })),\n      )\n    }\n\n    return errors\n  }\n}\n\nexport type ArgValue =\n  | string\n  | boolean\n  | number\n  | undefined\n  | Args\n  | string[]\n  | boolean[]\n  | number[]\n  | Args[]\n  | null\n\nexport interface DocumentInput {\n  dmmf: DMMFClass\n  rootTypeName: 'query' | 'mutation'\n  rootField: string\n  select?: any\n}\n\nexport function makeDocument({\n  dmmf,\n  rootTypeName,\n  rootField,\n  select,\n}: DocumentInput): Document {\n  if (!select) {\n    select = {}\n  }\n  const rootType = rootTypeName === 'query' ? dmmf.queryType : dmmf.mutationType\n  // Create a fake toplevel field for easier implementation\n  const fakeRootField: DMMF.SchemaField = {\n    args: [],\n    outputType: {\n      isList: false,\n      type: rootType,\n      kind: 'object',\n    },\n    isRequired: true,\n    name: rootTypeName,\n  }\n  const children = selectionToFields(\n    dmmf,\n    { [rootField]: select },\n    fakeRootField,\n    [rootTypeName],\n  )\n  return new Document(rootTypeName, children) as any\n}\n\n// TODO: get rid of this function\nexport function transformDocument(document: Document): Document {\n  return document\n}\n\nfunction isArgsArray(input: any): input is Args[] {\n  if (Array.isArray(input)) {\n    return input.every((arg) => arg instanceof Args)\n  }\n\n  return false\n}\n\nfunction getFilterArgName(arg: string, filter: string) {\n  if (filter === 'equals') {\n    return arg\n  }\n\n  return `${arg}_${convertToSnakeCase(filter)}`\n}\n\nfunction convertToSnakeCase(str: string): string {\n  return str\n    .split(/(?=[A-Z])/)\n    .join('_')\n    .toLowerCase()\n}\n\nexport function selectionToFields(\n  dmmf: DMMFClass,\n  selection: any,\n  schemaField: DMMF.SchemaField,\n  path: string[],\n): Field[] {\n  const outputType = schemaField.outputType.type as DMMF.OutputType\n  return Object.entries(selection).reduce((acc, [name, value]: any) => {\n    const field = outputType.fieldMap\n      ? outputType.fieldMap[name]\n      : outputType.fields.find((f) => f.name === name)\n\n    if (!field) {\n      // if the field name is incorrect, we ignore the args and child fields altogether\n      acc.push(\n        new Field({\n          name,\n          children: [],\n          // @ts-ignore\n          error: {\n            type: 'invalidFieldName',\n            modelName: outputType.name,\n            providedName: name,\n            didYouMean: getSuggestion(\n              name,\n              outputType.fields.map((f) => f.name),\n            ),\n            outputType,\n          },\n        }),\n      )\n\n      return acc\n    }\n\n    if (\n      typeof value !== 'boolean' &&\n      field.outputType.kind === 'scalar' &&\n      field.name !== 'executeRaw' &&\n      field.name !== 'queryRaw' &&\n      outputType.name !== 'Query' &&\n      !name.startsWith('aggregate') &&\n      field.name !== 'count' // TODO: Find a cleaner solution\n    ) {\n      acc.push(\n        new Field({\n          name,\n          children: [],\n          error: {\n            type: 'invalidFieldType',\n            modelName: outputType.name,\n            fieldName: name,\n            providedValue: value,\n          },\n        }),\n      )\n\n      return acc\n    }\n    if (value === false) {\n      return acc\n    }\n\n    const transformedField = {\n      name: field.name,\n      fields: field.args,\n      constraints: {\n        minNumFields: null,\n        maxNumFields: null\n      }\n    }\n    const argsWithoutIncludeAndSelect =\n      typeof value === 'object' ? omit(value, ['include', 'select']) : undefined\n    const args = argsWithoutIncludeAndSelect\n      ? objectToArgs(\n        argsWithoutIncludeAndSelect,\n        transformedField,\n        [],\n        typeof field === 'string'\n          ? undefined\n          : (field.outputType.type as DMMF.OutputType),\n      )\n      : undefined\n    const isRelation = field.outputType.kind === 'object'\n\n    // TODO: use default selection for `include` again\n\n    // check for empty select\n    if (value) {\n      if (value.select && value.include) {\n        acc.push(\n          new Field({\n            name,\n            children: [\n              new Field({\n                name: 'include',\n                args: new Args(),\n                error: {\n                  type: 'includeAndSelect',\n                  field,\n                },\n              }),\n            ],\n          }),\n        )\n      } else if (value.include) {\n        const keys = Object.keys(value.include)\n\n        if (keys.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: 'include',\n                  args: new Args(),\n                  error: {\n                    type: 'emptyInclude',\n                    field,\n                  },\n                }),\n              ],\n            }),\n          )\n\n          return acc\n        }\n\n        // TODO: unify with select validation logic\n        /**\n         * Error handling for `include` statements\n         */\n        if (field.outputType.kind === 'object') {\n          const fieldOutputType = field.outputType.type as DMMF.OutputType\n          const allowedKeys = fieldOutputType.fields\n            .filter((f) => f.outputType.kind === 'object')\n            .map((f) => f.name)\n          const invalidKeys = keys.filter((key) => !allowedKeys.includes(key))\n          if (invalidKeys.length > 0) {\n            acc.push(\n              ...invalidKeys.map(\n                (invalidKey) =>\n                  new Field({\n                    name: invalidKey,\n                    children: [\n                      new Field({\n                        name: invalidKey,\n                        args: new Args(),\n                        error: {\n                          type: 'invalidFieldName',\n                          modelName: fieldOutputType.name,\n                          outputType: fieldOutputType,\n                          providedName: invalidKey,\n                          didYouMean:\n                            getSuggestion(invalidKey, allowedKeys) || undefined,\n                          isInclude: true,\n                          isIncludeScalar: fieldOutputType.fields.some(\n                            (f) => f.name === invalidKey,\n                          ),\n                        },\n                      }),\n                    ],\n                    // @ts-ignore\n                  }),\n              ),\n            )\n            return acc\n          }\n        }\n      } else if (value.select) {\n        const values = Object.values(value.select)\n        if (values.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: 'select',\n                  args: new Args(),\n                  error: {\n                    type: 'emptySelect',\n                    field,\n                  },\n                }),\n              ],\n            }),\n          )\n\n          return acc\n        }\n\n        // check if there is at least one truthy value\n        const truthyValues = values.filter((v) => v)\n        if (truthyValues.length === 0) {\n          acc.push(\n            new Field({\n              name,\n              children: [\n                new Field({\n                  name: 'select',\n                  args: new Args(),\n                  error: {\n                    type: 'noTrueSelect',\n                    field,\n                  },\n                }),\n              ],\n            }),\n          )\n\n          return acc\n        }\n      }\n    }\n    // either use select or default selection, but not both at the same time\n    const defaultSelection = isRelation\n      ? getDefaultSelection(field.outputType.type as DMMF.OutputType)\n      : null\n    let select = defaultSelection\n    if (value) {\n      if (value.select) {\n        select = value.select\n      } else if (value.include) {\n        select = deepExtend(defaultSelection, value.include)\n      }\n    }\n    const children =\n      select !== false && isRelation\n        ? selectionToFields(dmmf, select, field, [...path, name])\n        : undefined\n\n    acc.push(new Field({ name, args, children, schemaField: field }))\n\n    return acc\n  }, [] as Field[])\n}\n\nfunction getDefaultSelection(outputType: DMMF.OutputType) {\n  return outputType.fields.reduce((acc, f) => {\n    if (f.outputType.kind === 'scalar' || f.outputType.kind === 'enum') {\n      acc[f.name] = true\n    } else {\n      // otherwise field is a relation. Only continue if it's an embedded type\n      // as normal types don't end up in the default selection\n      if ((f.outputType.type as DMMF.OutputType).isEmbedded) {\n        acc[f.name] = {\n          select: getDefaultSelection(f.outputType.type as DMMF.OutputType),\n        }\n      }\n    }\n\n    return acc\n  }, {})\n}\n\nfunction getInvalidTypeArg(\n  key: string,\n  value: any,\n  arg: DMMF.SchemaArg,\n  bestFittingType: DMMF.SchemaArgInputType,\n): Arg {\n  const arrg = new Arg({\n    key,\n    value,\n    isEnum: bestFittingType.kind === 'enum',\n    argType: bestFittingType.type,\n    error: {\n      type: 'invalidType',\n      providedValue: value,\n      argName: key,\n      requiredType: {\n        inputType: arg.inputTypes,\n\n        bestFittingType,\n      },\n    },\n  })\n\n  return arrg\n}\n\nfunction hasCorrectScalarType(\n  value: any,\n  arg: DMMF.SchemaArg,\n  inputType: DMMF.SchemaArgInputType,\n): boolean {\n  const { type, isList } = inputType\n  const expectedType = wrapWithList(stringifyGraphQLType(type), isList)\n  const graphQLType = getGraphQLType(value, type)\n\n  if (graphQLType === expectedType) {\n    return true\n  }\n\n  if (isList && graphQLType === 'List<>') {\n    return true\n  }\n\n  if (expectedType === 'Json') {\n    return true\n  }\n\n  if ((graphQLType === 'Int' || graphQLType === 'Float') && expectedType === 'Decimal') {\n    return true\n  }\n\n  // DateTime is a subset of string\n  if (graphQLType === 'DateTime' && expectedType === 'String') {\n    return true\n  }\n  if (graphQLType === 'List<DateTime>' && expectedType === 'List<String>') {\n    return true\n  }\n\n  // UUID is a subset of string\n  if (graphQLType === 'UUID' && expectedType === 'String') {\n    return true\n  }\n  if (graphQLType === 'List<UUID>' && expectedType === 'List<String>') {\n    return true\n  }\n\n  if (graphQLType === 'String' && expectedType === 'ID') {\n    return true\n  }\n  if (graphQLType === 'List<String>' && expectedType === 'List<ID>') {\n    return true\n  }\n  if (\n    expectedType === 'List<String>' &&\n    (graphQLType === 'List<String | UUID>' ||\n      graphQLType === 'List<UUID | String>')\n  ) {\n    return true\n  }\n\n  // Int is a subset of Float\n  if (graphQLType === 'Int' && expectedType === 'Float') {\n    return true\n  }\n  if (graphQLType === 'List<Int>' && expectedType === 'List<Float>') {\n    return true\n  }\n  // Int is a subset of Long\n  if (graphQLType === 'Int' && expectedType === 'Long') {\n    return true\n  }\n  if (graphQLType === 'List<Int>' && expectedType === 'List<Long>') {\n    return true\n  }\n\n  // to match all strings which are valid decimals\n  // from https://github.com/MikeMcl/decimal.js/blob/master/decimal.js#L115\n  if (graphQLType === 'String' && /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i.test(value) && expectedType === 'Decimal') {\n    return true\n  }\n\n  if (!arg.isRequired && value === null) {\n    return true\n  }\n  return false\n}\n\n\nconst cleanObject = (obj) => filterObject(obj, (k, v) => v !== undefined)\n\nfunction valueToArg(key: string, value: any, arg: DMMF.SchemaArg): Arg | null {\n  /**\n   * Go through the possible union input types.\n   * Stop on the first successful one\n   */\n  let maybeArg: Arg | null = null\n  for (const inputType of arg.inputTypes) {\n    maybeArg = tryInferArgs(key, value, arg, inputType)\n    if (maybeArg?.collectErrors().length === 0) {\n      return maybeArg\n    }\n  }\n\n  return maybeArg\n}\n\n/**\n * Running through the possible input types of a union.\n * @param key \n * @param value \n * @param arg \n * @param inputType \n */\nfunction tryInferArgs(key: string, value: any, arg: DMMF.SchemaArg, inputType: DMMF.SchemaArgInputType): Arg | null {\n  if (typeof value === 'undefined') {\n    // the arg is undefined and not required - we're fine\n    if (!arg.isRequired) {\n      return null\n    }\n\n    // the provided value is 'undefined' but shouldn't be\n    return new Arg({\n      key,\n      value,\n      isEnum: inputType.kind === 'enum',\n      error: {\n        type: 'missingArg',\n        missingName: key,\n        missingArg: arg,\n        atLeastOne: false,\n        atMostOne: false,\n      },\n    })\n  }\n\n  const { isNullable, isRequired } = arg\n\n  if (value === null && !isNullable && !isRequired) {\n    // we don't need to execute this ternery if not necessary\n    const isAtLeastOne = isInputArgType(inputType.type)\n      ? (inputType.type.constraints.minNumFields !== null && inputType.type.constraints.minNumFields > 0)\n      : false\n    if (!isAtLeastOne) {\n      return new Arg({\n        key,\n        value,\n        isEnum: inputType.kind === 'enum',\n        error: {\n          type: 'invalidNullArg',\n          name: key,\n          invalidType: arg.inputTypes,\n          atLeastOne: false,\n          atMostOne: false,\n        },\n      })\n    }\n  }\n  // then the first\n  if (!inputType.isList) {\n    if (isInputArgType(inputType.type)) {\n      if (typeof value !== 'object') {\n        return getInvalidTypeArg(key, value, arg, inputType)\n      } else {\n        let val = cleanObject(value)\n        let error: AtMostOneError | AtLeastOneError | undefined\n        const keys = Object.keys(val || {})\n        const numKeys = keys.length\n\n        if (numKeys === 0 && (typeof inputType.type.constraints.minNumFields === 'number' && inputType.type.constraints.minNumFields > 0)) {\n          // continue here\n          error = {\n            type: 'atLeastOne',\n            key,\n            inputType: inputType.type,\n          }\n        } else if (numKeys > 1 && (typeof inputType.type.constraints.maxNumFields === 'number' && inputType.type.constraints.maxNumFields < 2)) {\n          error = {\n            type: 'atMostOne',\n            key,\n            inputType: inputType.type,\n            providedKeys: keys,\n          }\n        }\n\n        return new Arg({\n          key,\n          value:\n            val === null ? null : objectToArgs(val, inputType.type, arg.inputTypes),\n          isEnum: inputType.kind === 'enum',\n          error,\n          argType: inputType.type,\n          schemaArg: arg,\n        })\n      }\n    } else {\n      return scalarToArg(key, value, arg, inputType)\n    }\n  }\n\n  // the provided arg should be a list, but isn't\n  // that's fine for us as we can just turn this into a list with a single item\n  // and GraphQL even allows this. We're going the conservative route though\n  // and actually generate the [] around the value\n\n  if (!Array.isArray(value) && inputType.isList) {\n    // TODO: This \"if condition\" is just a hack until the query engine is fixed\n    if (key !== 'updateMany') {\n      value = [value]\n    }\n  }\n\n  if (inputType.kind === 'enum' || inputType.kind === 'scalar') {\n    // if no value is incorrect\n    return scalarToArg(key, value, arg, inputType)\n  }\n\n  const argInputType = inputType.type as DMMF.InputType\n  const hasAtLeastOneError = (typeof argInputType.constraints.minNumFields === 'number' && argInputType.constraints.minNumFields > 0)\n    ? Array.isArray(value) && value.some((v) => !v || Object.keys(cleanObject(v)).length === 0)\n    : false\n  let err: AtLeastOneError | undefined | AtMostOneError = hasAtLeastOneError\n    ? {\n      inputType: argInputType,\n      key,\n      type: 'atLeastOne',\n    }\n    : undefined\n  if (!err) {\n    const hasOneOfError = (typeof argInputType.constraints.maxNumFields === 'number' && argInputType.constraints.maxNumFields < 2)\n      ? Array.isArray(value) && value.find((v) => !v || Object.keys(cleanObject(v)).length !== 1)\n      : false\n    if (hasOneOfError) {\n      err = {\n        inputType: argInputType,\n        key,\n        type: 'atMostOne',\n        providedKeys: Object.keys(hasOneOfError),\n      }\n    }\n  }\n\n  if (!Array.isArray(value)) {\n    for (const argInputType of arg.inputTypes) {\n      const args = objectToArgs(value, argInputType.type as DMMF.InputType)\n      if (args.collectErrors().length === 0) {\n        return new Arg({ key, value: args, isEnum: false, argType: argInputType.type, schemaArg: arg, })\n      }\n    }\n  }\n\n\n  return new Arg({\n    key,\n    value: value.map((v) => {\n      if ((inputType.isList) && typeof v !== 'object') {\n        return v\n      }\n      if (typeof v !== 'object' || !value) {\n        return getInvalidTypeArg(key, v, arg, inputType)\n      }\n      return objectToArgs(v, argInputType)\n    }),\n    isEnum: false,\n    argType: argInputType,\n    schemaArg: arg,\n    error: err,\n  })\n}\n\nexport function isInputArgType(\n  argType: DMMF.ArgType,\n): argType is DMMF.InputType {\n  if (typeof argType === 'string') {\n    return false\n  }\n  if (argType.hasOwnProperty('values')) {\n    return false\n  }\n\n  return true\n}\n\nfunction scalarToArg(\n  key: string,\n  value: any,\n  arg: DMMF.SchemaArg,\n  inputType: DMMF.SchemaArgInputType,\n): Arg {\n  if (hasCorrectScalarType(value, arg, inputType)) {\n    return new Arg({\n      key,\n      value,\n      isEnum: arg.inputTypes[0].kind === 'enum',\n      argType: inputType.type,\n      schemaArg: arg,\n    })\n  }\n  return getInvalidTypeArg(key, value, arg, inputType)\n}\n\nfunction objectToArgs(\n  initialObj: any,\n  inputType: DMMF.InputType,\n  possibilities?: DMMF.SchemaArgInputType[],\n  outputType?: DMMF.OutputType,\n): Args {\n  // filter out undefined values and treat them if they weren't provided\n  const obj = cleanObject(initialObj)\n  const { fields: args, fieldMap } = inputType\n  const requiredArgs: any = args\n    .map((arg) => [arg.name, undefined])\n  const objEntries = Object.entries(obj || {})\n  const entries = unionBy(objEntries, requiredArgs, (a) => a[0])\n  const argsList = entries.reduce((acc, [argName, value]: any) => {\n    const schemaArg = fieldMap\n      ? fieldMap[argName]\n      : args.find((a) => a.name === argName)\n    if (!schemaArg) {\n      const didYouMeanField =\n        typeof value === 'boolean' &&\n          outputType &&\n          outputType.fields.some((f) => f.name === argName)\n          ? argName\n          : null\n      acc.push(\n        new Arg({\n          key: argName,\n          value,\n          error: {\n            type: 'invalidName',\n            providedName: argName,\n            providedValue: value,\n            didYouMeanField,\n            didYouMeanArg:\n              (!didYouMeanField &&\n                getSuggestion(argName, [\n                  ...args.map((a) => a.name),\n                  'select',\n                ])) ||\n              undefined,\n            originalType: inputType,\n            possibilities,\n            outputType,\n          },\n        }),\n      )\n      return acc\n    }\n\n    const arg = valueToArg(argName, value, schemaArg)\n\n    if (arg) {\n      acc.push(arg)\n    }\n\n    return acc\n  }, [] as Arg[])\n  // Also show optional neighbour args, if there is any arg missing\n  if (\n    (typeof inputType.constraints.minNumFields === 'number' && objEntries.length < inputType.constraints.minNumFields) ||\n    argsList.find((arg) => (arg.error?.type === 'missingArg' || arg.error?.type === 'atLeastOne'))\n  ) {\n    const optionalMissingArgs = inputType.fields.filter(\n      field => !field.isRequired && (obj && (typeof obj[field.name] === 'undefined' || obj[field.name] === null))\n    )\n    argsList.push(\n      ...optionalMissingArgs.map((arg) => {\n        const argInputType = arg.inputTypes[0]\n        return new Arg({\n          key: arg.name,\n          value: undefined,\n          isEnum: argInputType.kind === 'enum',\n          error: {\n            type: 'missingArg',\n            missingName: arg.name,\n            missingArg: arg,\n            atLeastOne: Boolean(inputType.constraints.minNumFields) || false,\n            atMostOne: inputType.constraints.maxNumFields === 1 || false,\n          },\n        })\n      }),\n    )\n  }\n  return new Args(argsList)\n}\n\nexport interface UnpackOptions {\n  document: Document\n  path: string[]\n  data: any\n}\n\n/**\n * Unpacks the result of a data object and maps DateTime fields to instances of `Date` inplace\n * @param options: UnpackOptions\n */\nexport function unpack({ document, path, data }: UnpackOptions): any {\n  const result = deepGet(data, path)\n\n  if (result === 'undefined') {\n    return null\n  }\n\n  if (typeof result !== 'object') {\n    return result\n  }\n\n  const field = getField(document, path)\n\n  return mapScalars({ field, data: result })\n}\n\nexport interface MapScalarsOptions {\n  field: Field\n  data: any\n}\n\nexport function mapScalars({ field, data }: MapScalarsOptions): any {\n  if (\n    !data ||\n    typeof data !== 'object' ||\n    !field.children ||\n    !field.schemaField\n  ) {\n    return data\n  }\n\n  const deserializers = {\n    'DateTime': value => new Date(value),\n    'Json': value => JSON.parse(value),\n    'Bytes': value => Buffer.from(value, 'base64'),\n    'Decimal': value => {\n      return new Decimal(value)\n    }\n  }\n\n  for (const child of field.children) {\n    const outputType = child.schemaField?.outputType.type\n    if (outputType && typeof outputType === 'string') {\n      const deserializer = deserializers[outputType]\n      if (deserializer) {\n        if (Array.isArray(data)) {\n          for (const entry of data) {\n            // in the very unlikely case, that a field is not there in the result, ignore it\n            if (typeof entry[child.name] !== 'undefined' && entry[child.name] !== null) {\n              entry[child.name] = deserializer(entry[child.name])\n            }\n          }\n        } else {\n          // same here, ignore it if it's undefined\n          if (typeof data[child.name] !== 'undefined' && data[child.name] !== null) {\n            data[child.name] = deserializer(data[child.name])\n          }\n        }\n      }\n    }\n\n    if (child.schemaField && child.schemaField.outputType.kind === 'object') {\n      if (Array.isArray(data)) {\n        for (const entry of data) {\n          mapScalars({ field: child, data: entry[child.name] })\n        }\n      } else {\n        mapScalars({ field: child, data: data[child.name] })\n      }\n    }\n  }\n\n  return data\n}\n\nexport function getField(document: Document, path: string[]): Field {\n  const todo = path.slice() // let's create a copy to not fiddle with the input argument\n  const firstElement = todo.shift()\n  // this might be slow because of the find\n  let pointer = document.children.find((c) => c.name === firstElement)\n\n  if (!pointer) {\n    throw new Error(\n      `Could not find field ${firstElement} in document ${document}`,\n    )\n  }\n\n  while (todo.length > 0) {\n    const key = todo.shift()\n    if (!pointer!.children) {\n      throw new Error(\n        `Can't get children for field ${pointer} with child ${key}`,\n      )\n    }\n    const child = pointer!.children.find((c) => c.name === key)\n    if (!child) {\n      throw new Error(`Can't find child ${key} of field ${pointer}`)\n    }\n    pointer = child!\n  }\n\n  return pointer!\n}\n\nfunction removeSelectFromPath(path: string): string {\n  return path\n    .split('.')\n    .filter((p) => p !== 'select')\n    .join('.')\n}\n\nfunction removeSelectFromObject(obj: object): object {\n  const type = Object.prototype.toString.call(obj)\n  if (type === '[object Object]') {\n    const copy = {}\n    for (const key in obj) {\n      if (key === 'select') {\n        for (const subKey in obj['select']) {\n          copy[subKey] = removeSelectFromObject(obj['select'][subKey])\n        }\n      } else {\n        copy[key] = removeSelectFromObject(obj[key])\n      }\n    }\n    return copy\n  }\n\n  return obj\n}\n\nfunction transformAggregatePrintJsonArgs({\n  ast,\n  keyPaths,\n  missingItems,\n  valuePaths,\n}: PrintJsonWithErrorsArgs): PrintJsonWithErrorsArgs {\n  const newKeyPaths = keyPaths.map(removeSelectFromPath)\n  const newValuePaths = valuePaths.map(removeSelectFromPath)\n  const newMissingItems = missingItems.map((item) => ({\n    path: removeSelectFromPath(item.path),\n    isRequired: item.isRequired,\n    type: item.type,\n  }))\n\n  const newAst = removeSelectFromObject(ast)\n  return {\n    ast: newAst,\n    keyPaths: newKeyPaths,\n    missingItems: newMissingItems,\n    valuePaths: newValuePaths,\n  }\n}\n", "import { DMMFClass } from './dmmf'\nimport { DMMF } from './dmmf-types'\nimport path from 'path'\nimport {\n  PrismaClientKnownRequestError,\n  PrismaClientUnknownRequestError,\n  PrismaClientInitializationError,\n  PrismaClientRustPanicError,\n} from '.'\nimport {\n  NodeEngine,\n  EngineConfig,\n  DatasourceOverwrite,\n} from '@prisma/engine-core/dist/NodeEngine'\nimport {\n  Document,\n  makeDocument,\n  unpack,\n  transformDocument,\n  Args,\n} from './query'\nimport Debug from '@prisma/debug'\nconst debug = Debug('prisma-client')\nimport fs from 'fs'\nimport chalk from 'chalk'\nimport * as sqlTemplateTag from 'sql-template-tag'\nimport dotenv from 'dotenv'\nimport { dotenvExpand } from '@prisma/sdk/dist/dotenvExpand'\nimport {\n  GeneratorConfig,\n  DataSource,\n} from '@prisma/generator-helper/dist/types'\nimport { getLogLevel } from './getLogLevel'\nimport { mergeBy } from './mergeBy'\nimport { lowerCase, getOutputTypeName } from './utils/common'\nimport { deepSet } from './utils/deep-set'\nimport { Dataloader } from './Dataloader'\nimport { printStack } from './utils/printStack'\nimport stripAnsi from 'strip-ansi'\nimport { printJsonWithErrors } from './utils/printJsonErrors'\nimport { ConnectorType } from './utils/printDatasources'\nimport { omit } from './utils/omit'\nimport { mapPreviewFeatures } from '@prisma/sdk/dist/utils/mapPreviewFeatures'\nimport { serializeRawParameters } from './utils/serializeRawParameters'\nimport { AsyncResource } from 'async_hooks'\nimport { clientVersion } from './utils/clientVersion'\nimport { mssqlPreparedStatement } from './utils/mssqlPreparedStatement'\n\nexport type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n\nexport type Datasource = {\n  url?: string\n}\nexport type Datasources = Record<string, Datasource>\n\nexport interface PrismaClientOptions {\n  /**\n   * Overwrites the datasource url from your prisma.schema file\n   */\n  datasources?: Datasources\n\n  /**\n   * @default \"colorless\"\n   */\n  errorFormat?: ErrorFormat\n\n  /**\n   * @example\n   * \\`\\`\\`\n   * // Defaults to stdout\n   * log: ['query', 'info', 'warn']\n   *\n   * // Emit as events\n   * log: [\n   *  { emit: 'stdout', level: 'query' },\n   *  { emit: 'stdout', level: 'info' },\n   *  { emit: 'stdout', level: 'warn' }\n   * ]\n   * \\`\\`\\`\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n   */\n  log?: Array<LogLevel | LogDefinition>\n\n  /**\n   * @internal\n   * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\n   */\n  __internal?: {\n    debug?: boolean\n    hooks?: Hooks\n    useUds?: boolean\n    engine?: {\n      cwd?: string\n      binaryPath?: string\n      endpoint?: string\n      enableEngineDebugMode?: boolean\n    }\n  }\n}\n\nexport type HookParams = {\n  query: string\n  path: string[]\n  rootField?: string\n  typeName?: string\n  document: any\n  clientMethod: string\n  args: any\n}\n\n/**\n * These options are being passed in to the middleware as \"params\"\n */\nexport type MiddlewareParams = {\n  model?: string\n  action: Action\n  args: any\n  dataPath: string[]\n  runInTransaction: boolean\n}\n\n/**\n * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation\n */\nexport type Middleware<T = any> = (\n  params: MiddlewareParams,\n  next: (params: MiddlewareParams) => Promise<T>,\n) => Promise<T>\n\nexport interface InternalRequestParams extends MiddlewareParams {\n  /**\n   * The original client method being called.\n   * Even though the rootField / operation can be changed,\n   * this method stays as it is, as it's what the user's\n   * code looks like\n   */\n  clientMethod: string\n  callsite?: string\n  headers?: Record<string, string>\n}\n\nexport type HookPoint = 'all' | 'engine'\n\nexport type EngineMiddlewareParams = {\n  document: Document\n  runInTransaction?: boolean\n}\n\n// only used by the .use() hooks\nexport type AllHookArgs = {\n  params: HookParams\n  fetch: (params: HookParams) => Promise<any>\n}\n/**\n * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation\n */\nexport type EngineMiddleware<T = any> = (\n  params: EngineMiddlewareParams,\n  next: (params: EngineMiddlewareParams) => Promise<T>,\n) => Promise<T>\n\nexport type Hooks = {\n  beforeRequest?: (options: HookParams) => any\n}\n\n/* Types for Logging */\nexport type LogLevel = 'info' | 'query' | 'warn' | 'error'\nexport type LogDefinition = {\n  level: LogLevel\n  emit: 'stdout' | 'event'\n}\n\nexport type GetLogType<\n  T extends LogLevel | LogDefinition\n  > = T extends LogDefinition\n  ? T['emit'] extends 'event'\n  ? T['level']\n  : never\n  : never\nexport type GetEvents<T extends Array<LogLevel | LogDefinition>> =\n  | GetLogType<T[0]>\n  | GetLogType<T[1]>\n  | GetLogType<T[2]>\n\nexport type QueryEvent = {\n  timestamp: Date\n  query: string\n  params: string\n  duration: number\n  target: string\n}\n\nexport type LogEvent = {\n  timestamp: Date\n  message: string\n  target: string\n}\n/* End Types for Logging */\n\nexport interface GetPrismaClientOptions {\n  document: DMMF.Document\n  generator?: GeneratorConfig\n  sqliteDatasourceOverrides?: DatasourceOverwrite[]\n  relativePath: string\n  dirname: string\n  clientVersion?: string\n  engineVersion?: string\n}\n\nexport type Action =\n  | 'findOne'\n  | 'findFirst'\n  | 'findMany'\n  | 'create'\n  | 'update'\n  | 'updateMany'\n  | 'upsert'\n  | 'delete'\n  | 'deleteMany'\n  | 'executeRaw'\n  | 'queryRaw'\n  | 'aggregate'\n\nconst actionOperationMap = {\n  findOne: 'query',\n  findFirst: 'query',\n  findMany: 'query',\n  count: 'query',\n  create: 'mutation',\n  update: 'mutation',\n  updateMany: 'mutation',\n  upsert: 'mutation',\n  delete: 'mutation',\n  deleteMany: 'mutation',\n  executeRaw: 'mutation',\n  queryRaw: 'mutation',\n  aggregate: 'query',\n}\n\nconst aggregateKeys = {\n  avg: true,\n  count: true,\n  sum: true,\n  min: true,\n  max: true,\n}\n\n// TODO: We **may** be able to get real types. However, we have both a bootstrapping\n// problem here, that we want to return a type that's not yet defined\n// and we're typecasting this anyway later\nexport function getPrismaClient(config: GetPrismaClientOptions): any {\n  class NewPrismaClient {\n    _dmmf: DMMFClass\n    _engine: NodeEngine\n    _fetcher: PrismaClientFetcher\n    _connectionPromise?: Promise<any>\n    _disconnectionPromise?: Promise<any>\n    _engineConfig: EngineConfig\n    private _errorFormat: ErrorFormat\n    private _hooks?: Hooks\n    private _getConfigPromise?: Promise<{\n      datasources: DataSource[]\n      generators: GeneratorConfig[]\n    }>\n    private _middlewares: Middleware[] = []\n    private _engineMiddlewares: EngineMiddleware[] = []\n    private _clientVersion: string\n    constructor(optionsArg?: PrismaClientOptions) {\n      this._clientVersion = config.clientVersion ?? clientVersion\n      try {\n        const options: PrismaClientOptions = optionsArg ?? {}\n        const internal = options.__internal ?? {}\n\n        const useDebug = internal.debug === true\n        if (useDebug) {\n          Debug.enable('prisma-client')\n        }\n\n        if (internal.hooks) {\n          this._hooks = internal.hooks\n        }\n\n        let predefinedDatasources = config.sqliteDatasourceOverrides ?? []\n        predefinedDatasources = predefinedDatasources.map((d) => ({\n          name: d.name,\n          url: 'file:' + path.resolve(config.dirname, d.url),\n        }))\n\n        const inputDatasources = Object.entries(options.datasources || {})\n          .filter(([_, source]) => {\n            return source && source.url\n          })\n          .map(([name, { url }]: any) => ({ name, url }))\n\n        const datasources = mergeBy(\n          predefinedDatasources,\n          inputDatasources,\n          (source) => source.name,\n        )\n\n        const engineConfig = internal.engine || {}\n\n        if (options.errorFormat) {\n          this._errorFormat = options.errorFormat\n        } else if (process.env.NODE_ENV === 'production') {\n          this._errorFormat = 'minimal'\n        } else if (process.env.NO_COLOR) {\n          this._errorFormat = 'colorless'\n        } else {\n          this._errorFormat = 'colorless' // default errorFormat\n        }\n\n        const envFile = this.readEnv()\n\n        this._dmmf = new DMMFClass(config.document)\n\n        let cwd = path.resolve(config.dirname, config.relativePath)\n\n        if (!fs.existsSync(cwd)) {\n          cwd = config.dirname\n        }\n\n        const previewFeatures = config.generator?.previewFeatures ?? []\n\n        this._engineConfig = {\n          cwd,\n          enableDebugLogs: useDebug,\n          enableEngineDebugMode: engineConfig.enableEngineDebugMode,\n          datamodelPath: path.join(config.dirname, 'schema.prisma'),\n          prismaPath: engineConfig.binaryPath ?? undefined,\n          engineEndpoint: engineConfig.endpoint,\n          datasources,\n          generator: config.generator,\n          showColors: this._errorFormat === 'pretty',\n          logLevel: options.log && (getLogLevel(options.log) as any), // TODO\n          logQueries:\n            options.log &&\n            Boolean(\n              typeof options.log === 'string'\n                ? options.log === 'query'\n                : options.log.find((o) =>\n                  typeof o === 'string' ? o === 'query' : o.level === 'query',\n                ),\n            ),\n          env: envFile,\n          flags: [],\n          clientVersion: config.clientVersion,\n          enableExperimental: mapPreviewFeatures(previewFeatures),\n          useUds: internal.useUds,\n        }\n\n        const sanitizedEngineConfig = omit(this._engineConfig, [\n          'env',\n          'datasources',\n        ])\n        debug({ engineConfig: sanitizedEngineConfig })\n\n        this._engine = new NodeEngine(this._engineConfig)\n        this._fetcher = new PrismaClientFetcher(this, false, this._hooks)\n\n        if (options.log) {\n          for (const log of options.log) {\n            const level =\n              typeof log === 'string'\n                ? log\n                : log.emit === 'stdout'\n                  ? log.level\n                  : null\n            if (level) {\n              this.$on(level, (event) => {\n                const colorMap = {\n                  query: 'blue',\n                  info: 'cyan',\n                  warn: 'yellow',\n                  error: 'red',\n                }\n                console.error(\n                  chalk[colorMap[level]](`prisma:${level}`.padEnd(13)) +\n                  (event.message || event.query),\n                )\n              })\n            }\n          }\n        }\n\n        this._bootstrapClient()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private readEnv() {\n      const dotEnvPath = path.resolve(\n        config.dirname,\n        config.relativePath,\n        '.env',\n      )\n      if (fs.existsSync(dotEnvPath)) {\n        return dotenvExpand(dotenv.config({ path: dotEnvPath })).parsed\n      }\n\n      return {}\n    }\n    use(...args) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.use() is deprecated, please use prisma.$use() instead`,\n      )\n      return (this.$use as any)(...args)\n    }\n    $use(cb: Middleware)\n    $use(namespace: 'all', cb: Middleware)\n    $use(namespace: 'engine', cb: EngineMiddleware)\n    $use(\n      namespace: HookPoint | Middleware,\n      cb?: Middleware | EngineMiddleware,\n    ) {\n      if (typeof namespace === 'function') {\n        this._middlewares.push(namespace)\n      } else if (typeof namespace === 'string') {\n        if (namespace === 'all') {\n          this._middlewares.push(cb! as Middleware)\n        } else if (namespace === 'engine') {\n          this._engineMiddlewares.push(cb! as EngineMiddleware)\n        } else {\n          throw new Error(`Unknown middleware hook ${namespace}`)\n        }\n      } else {\n        throw new Error(`Invalid middleware ${namespace}`)\n      }\n    }\n    on(eventType: any, callback: (event: any) => void) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.on() is deprecated, please use prisma.$on() instead`,\n      )\n      return this.$on(eventType, callback)\n    }\n    $on(eventType: any, callback: (event: any) => void) {\n      if (eventType === 'beforeExit') {\n        this._engine.on('beforeExit', callback)\n      } else {\n        this._engine.on(eventType, (event) => {\n          const fields = event.fields\n          if (eventType === 'query') {\n            return callback({\n              timestamp: event.timestamp,\n              query: fields.query,\n              params: fields.params,\n              duration: fields.duration_ms,\n              target: event.target,\n            })\n          } else {\n            // warn, info, or error events\n            return callback({\n              timestamp: event.timestamp,\n              message: fields.message,\n              target: event.target,\n            })\n          }\n        })\n      }\n    }\n    connect() {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.connect() is deprecated, please use prisma.$connect() instead`,\n      )\n      return this.$connect()\n    }\n    async $connect() {\n      try {\n        return this._engine.start()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n    /**\n     * @private\n     */\n    async _runDisconnect() {\n      await this._engine.stop()\n      delete this._connectionPromise\n      this._engine = new NodeEngine(this._engineConfig)\n      delete this._disconnectionPromise\n      delete this._getConfigPromise\n    }\n    disconnect() {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.disconnect() is deprecated, please use prisma.$disconnect() instead`,\n      )\n      return this.$disconnect()\n    }\n    /**\n     * Disconnect from the database\n     */\n    async $disconnect() {\n      try {\n        return this._engine.stop()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private async _getActiveProvider(): Promise<ConnectorType> {\n      const configResult = await this._engine.getConfig()\n      return configResult.datasources[0].activeProvider!\n    }\n\n    executeRaw(stringOrTemplateStringsArray, ...values) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.executeRaw() is deprecated, please use prisma.$executeRaw() instead`,\n      )\n      return this.$executeRaw(stringOrTemplateStringsArray, ...values)\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    private async $executeRawInternal(stringOrTemplateStringsArray, ...values) {\n      let query = ''\n      let parameters: any = undefined\n\n      const activeProvider = await this._getActiveProvider()\n\n      if (typeof stringOrTemplateStringsArray === 'string') {\n        // If this was called as prisma.$executeRaw(<SQL>, [...values]), assume it is a pre-prepared SQL statement, and forward it without any changes\n        query = stringOrTemplateStringsArray\n        parameters = {\n          values: serializeRawParameters(values || []),\n          __prismaRawParamaters__: true,\n        }\n      } else if (Array.isArray(stringOrTemplateStringsArray)) {\n        // If this was called as prisma.$executeRaw`<SQL>`, try to generate a SQL prepared statement\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.sql\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'postgresql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.text\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'sqlserver': {\n            query = mssqlPreparedStatement(stringOrTemplateStringsArray)\n            parameters = {\n              values: serializeRawParameters(values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n        }\n      } else {\n        // If this was called as prisma.raw(sql`<SQL>`), use prepared statements from sql-template-tag\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).sql\n            break\n          case 'postgresql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).text\n            break\n          case 'sqlserver':\n            query = mssqlPreparedStatement(\n              (stringOrTemplateStringsArray as sqlTemplateTag.Sql).strings,\n            )\n            break\n        }\n        parameters = {\n          values: serializeRawParameters(\n            (stringOrTemplateStringsArray as sqlTemplateTag.Sql).values,\n          ),\n          __prismaRawParamaters__: true,\n        }\n      }\n\n      if (parameters?.values) {\n        debug(`prisma.$executeRaw(${query}, ${parameters.values})`)\n      } else {\n        debug(`prisma.$executeRaw(${query})`)\n      }\n\n      const args = { query, parameters }\n\n      debug(`Prisma Client call:`)\n      return this._request({\n        args,\n        clientMethod: 'executeRaw',\n        dataPath: [],\n        action: 'executeRaw',\n        callsite: this._getCallsite(),\n        runInTransaction: false,\n      })\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    $executeRaw(stringOrTemplateStringsArray, ...values) {\n      try {\n        const promise = this.$executeRawInternal(stringOrTemplateStringsArray, ...values)\n          ; (promise as any).isExecuteRaw = true\n        return promise\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _getCallsite() {\n      if (this._errorFormat !== 'minimal') {\n        return new Error().stack\n      }\n      return undefined\n    }\n\n    queryRaw(stringOrTemplateStringsArray, ...args) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.queryRaw() is deprecated, please use prisma.$queryRaw() instead`,\n      )\n      return this.$queryRaw(stringOrTemplateStringsArray, ...args)\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    private async $queryRawInternal(\n      stringOrTemplateStringsArray:\n        | string\n        | TemplateStringsArray\n        | sqlTemplateTag.Sql,\n      ...values: any[]\n    ) {\n      let query = ''\n      let parameters: any = undefined\n\n      const activeProvider = await this._getActiveProvider()\n\n      if (typeof stringOrTemplateStringsArray === 'string') {\n        // If this was called as prisma.$queryRaw(<SQL>, [...values]), assume it is a pre-prepared SQL statement, and forward it without any changes\n        query = stringOrTemplateStringsArray\n        parameters = {\n          values: serializeRawParameters(values || []),\n          __prismaRawParamaters__: true,\n        }\n      } else if (Array.isArray(stringOrTemplateStringsArray)) {\n        // If this was called as prisma.$queryRaw`<SQL>`, try to generate a SQL prepared statement\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.sql\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'postgresql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.text\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'sqlserver': {\n            query = mssqlPreparedStatement(stringOrTemplateStringsArray)\n            parameters = {\n              values: serializeRawParameters(values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n        }\n      } else {\n        // If this was called as prisma.raw(sql`<SQL>`), use prepared statements from sql-template-tag\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).sql\n            break\n          case 'postgresql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).text\n            break\n          case 'sqlserver':\n            query = mssqlPreparedStatement(\n              (stringOrTemplateStringsArray as sqlTemplateTag.Sql).strings,\n            )\n            break\n        }\n        parameters = {\n          values: serializeRawParameters(\n            (stringOrTemplateStringsArray as sqlTemplateTag.Sql).values,\n          ),\n          __prismaRawParamaters__: true,\n        }\n      }\n\n      if (parameters?.values) {\n        debug(`prisma.queryRaw(${query}, ${parameters.values})`)\n      } else {\n        debug(`prisma.queryRaw(${query})`)\n      }\n\n      const args = { query, parameters }\n\n      debug(`Prisma Client call:`)\n      return this._request({\n        args,\n        clientMethod: 'queryRaw',\n        dataPath: [],\n        action: 'queryRaw',\n        callsite: this._getCallsite(),\n        runInTransaction: false,\n      })\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    $queryRaw(stringOrTemplateStringsArray, ...values) {\n      try {\n        const promise = this.$queryRawInternal(stringOrTemplateStringsArray, ...values)\n          ; (promise as any).isQueryRaw = true\n        return promise\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    async __internal_triggerPanic(fatal: boolean) {\n      if (!this._engineConfig.enableEngineDebugMode) {\n        throw new Error(`In order to use .__internal_triggerPanic(), please enable the debug mode like so:\nnew PrismaClient({\n  __internal: {\n    engine: {\n      enableEngineDebugMode: true\n    }\n  }\n})`)\n      }\n\n      const query = 'SELECT 1'\n\n      const headers: Record<string, string> = fatal\n        ? { 'X-DEBUG-FATAL': '1' }\n        : { 'X-DEBUG-NON-FATAL': '1' }\n\n      return this._request({\n        action: 'queryRaw',\n        args: {\n          query,\n          parameters: undefined,\n        },\n        clientMethod: 'queryRaw',\n        dataPath: [],\n        runInTransaction: false,\n        headers,\n        callsite: this._getCallsite(),\n      })\n    }\n\n    transaction(promises) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.transaction() is deprecated, please use prisma.$transaction() instead`,\n      )\n      return this.$transaction(promises)\n    }\n\n    private async $transactionInternal(promises: Array<any>): Promise<any> {\n      if (config.generator?.previewFeatures?.includes('transactionApi')) {\n        for (const p of promises) {\n          if (!p) {\n            throw new Error(\n              `All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`,\n            )\n          }\n          if (p?.isQueryRaw) {\n            throw new Error(`$queryRaw is not yet supported within $transaction.\nPlease report in https://github.com/prisma/prisma/issues/3828 if you need this feature.`)\n          }\n          if (p?.isExecuteRaw) {\n            throw new Error(`$executeRaw is not yet supported within $transaction.\nPlease report in https://github.com/prisma/prisma/issues/3828 if you need this feature`)\n          }\n          if (\n            !p.requestTransaction ||\n            typeof p.requestTransaction !== 'function'\n          ) {\n            throw new Error(\n              `All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`,\n            )\n          }\n        }\n        return Promise.all(promises.map((p) => p.requestTransaction()))\n      } else {\n        throw new Error(\n          `In order to use the .transaction() api, please enable 'previewFeatures = \"transactionApi\" in your schema.`,\n        )\n      }\n    }\n\n    async $transaction(promises: Array<any>): Promise<any> {\n      try {\n        return this.$transactionInternal(promises)\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _request(internalParams: InternalRequestParams) {\n      try {\n        const resource = new AsyncResource('prisma-client-request')\n        if (this._middlewares.length > 0) {\n          // https://perf.link/#eyJpZCI6Img4bmd0anp5eGxrIiwidGl0bGUiOiJGaW5kaW5nIG51bWJlcnMgaW4gYW4gYXJyYXkgb2YgMTAwMCIsImJlZm9yZSI6ImNvbnN0IGRhdGEgPSB7XG4gIG9wZXJhdGlvbjogXCJxdWVyeVwiLFxuICByb290RmllbGQ6IFwiZmluZE1hbnlVc2VyXCIsXG4gIGFyZ3M6IHtcbiAgICB3aGVyZTogeyBpZDogeyBndDogNSB9IH1cbiAgfSxcbiAgZGF0YVBhdGg6IFtdLFxuICBjbGllbnRNZXRob2Q6ICd1c2VyLmZpbmRNYW55J1xufSIsInRlc3RzIjpbeyJuYW1lIjoiZm9yIGluIiwiY29kZSI6ImNvbnN0IG5ld0RhdGEgPSB7fVxuZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICBpZiAoa2V5ICE9PSAnY2xpZW50TWV0aG9kJykge1xuICAgIG5ld0RhdGFba2V5XSA9IGRhdGFba2V5XVxuICB9XG59IiwicnVucyI6WzU1MzAwMCw0OTAwMDAsMzQ0MDAwLDYyNDAwMCwxMzkxMDAwLDEyMjQwMDAsMTA2NDAwMCwxMjE3MDAwLDc0MDAwLDM3MzAwMCw5MDUwMDAsNTM3MDAwLDE3MDYwMDAsOTAzMDAwLDE0MjUwMDAsMTMxMjAwMCw3NjkwMDAsMTM0NTAwMCwxOTQ4MDAwLDk5MDAwMCw5MDAwMDAsMTM0ODAwMCwxMDk2MDAwLDM4NjAwMCwxNTE3MDAwLDE5MzYwMDAsMTAwMCwyMTM0MDAwLDEzMjgwMDAsODI5MDAwLDE1ODYwMDAsMTc2MzAwMCw1MDgwMDAsOTg2MDAwLDE5NDkwMDAsMjEwODAwMCwxNjA4MDAwLDIyNDAwMCwxOTAyMDAwLDEyNjgwMDAsMjEzNDAwMCwxNzEwMDAwLDEzNzIwMDAsMjExMDAwMCwxNzgwMDAwLDc3NzAwMCw1NzgwMDAsNDAwMCw4OTAwMDAsMTEwMTAwMCwxNTk0MDAwLDE3ODAwMDAsMzU0MDAwLDU0NDAwMCw4MjQwMDAsNzEwMDAwLDg0OTAwMCwxNjQwMDAwLDE5ODQwMDAsNzAzMDAwLDg4MjAwMCw4NTAwMDAsMTA2MDAwLDMwMzAwMCwxMzMwMDAsNjA4MDAwLDIxMzQwMDAsNTUxMDAwLDc0MjAwMCwyMDcwMDAsMTU3NTAwMCwxMzQwMDAsNDAwMCwxMDAwLDQ5NDAwMCwyNTAwMDAsMTQwMjAwMCw2OTgwMDAsNTgxMDAwLDQ4MDAwMCwyMDMwMDAsMTY4MzAwMCwxNjcxMDAwLDEyNDAwMDAsMTk1NjAwMCwzMDUwMDAsODkwMDAsNjUzMDAwLDE3MDgwMDAsMTYwMTAwMCwxOTg0MDAwLDg4ODAwMCwyMTAwMDAwLDE5NzUwMDAsNTM2MDAwLDU3NTAwMCwyMTM0MDAwLDEwMTcwMDAsMTI5NzAwMCw3NTYwMDBdLCJvcHMiOjEwNDUxNTB9LHsibmFtZSI6IkRlY29uc3RydWN0b3IiLCJjb2RlIjoiY29uc3QgeyBjbGllbnRNZXRob2QsIC4uLnJlc3QgfSA9IGRhdGEiLCJydW5zIjpbMjE0MDAwLDUxMDAwLDg2NDAwMCw3MjcwMDAsNDMxMDAwLDIyMDAwMCwzOTAwMDAsODQxMDAwLDIyOTAwMCw3MjIwMDAsNDEzMDAwLDYwODAwMCwyOTgwMDAsMzY4MDAwLDg2NDAwMCw5MjQwMDAsMTI4MDAwLDU1MzAwMCw4ODAwMDAsNTQ1MDAwLDc3NTAwMCw0MzAwMDAsMjM3MDAwLDc4NjAwMCw1NTUwMDAsNTI2MDAwLDMyNzAwMCw2MzAwMCw5MTIwMDAsMTgxMDAwLDMzMTAwMCw0MzAwMCwyMjUwMDAsNTQ3MDAwLDgyMjAwMCw3OTMwMDAsMTA1NzAwMCw1NjAwMCwyNzUwMDAsMzkzMDAwLDgwNTAwMCw5MzAwMCw3NjYwMDAsODM0MDAwLDUwMzAwMCw4MDAwMCwyMzgwMDAsNDY0MDAwLDU2NDAwMCw3MzAwMDAsOTU1MDAwLDgwOTAwMCwyMDMwMDAsNDEzMDAwLDM0NDAwMCw1MDIwMDAsNjEzMDAwLDEwMDAwMCw0MzIwMDAsNjcwMDAwLDQ1MzAwMCw4OTEwMDAsNTUwMDAsMjMwMDAwLDM5MTAwMCw3NTQwMDAsMTEyMjAwMCw3NjIwMDAsMzU3MDAwLDQ3MDAwLDc5MjAwMCwzNTQwMDAsMTA4MDAwMCwxNjAwMCwxODgwMDAsMTQxMDAwLDIxMDAwMCw2MDcwMDAsOTAyMDAwLDgyNTAwMCwxOTAwMDAsMjMzMDAwLDI4MzAwMCwyMzgwMDAsNjk2MDAwLDc2ODAwMCw3NTgwMDAsMTk0MDAwLDI3OTAwMCwyMjMwMDAsMjM4MDAwLDkzNDAwMCw2MDUwMDAsMTcwMDAsMjEwMDAwLDMyMjAwMCwxMDM0MDAwLDgxMjAwMCw0NDYwMDAsNjMxMDAwXSwib3BzIjo0OTAxMDB9LHsibmFtZSI6ImRlbGV0ZSIsImNvZGUiOiJjb25zdCB7IGNsaWVudE1ldGhvZCB9ID0gZGF0YVxuZGVsZXRlIGRhdGEuY2xpZW50TWV0aG9kIiwicnVucyI6WzI3NjIwMDAsNjIyMDAwLDEwNTcwMDAsMzIzMTAwMCwzNDQ2MDAwLDIwNzMwMDAsMzM4MjAwMCwyNzA0MDAwLDM4ODEwMDAsMTIwMTAwMCwzNzk3MDAwLDI1OTAwMCwxMDI4MDAwLDI1MTgwMDAsMjEwMjAwMCwxOTczMDAwLDM0MTIwMDAsMzU4MDAwLDExNDcwMDAsMTA3NDAwMCwzMTk1MDAwLDM2NzUwMDAsNTQ3MDAwLDIwNzkwMDAsMjc0NTAwMCwyNDE1MDAwLDIxOTAwMCwzNzM3MDAwLDM2OTIwMDAsMTY0MDAwLDI0MzMwMDAsNjQzMDAwLDcxODAwMCw0Mzg2MDAwLDE3MDIwMDAsMTAyNDAwMCw1NjUwMDAsNDIxOTAwMCwxMTk3MDAwLDE4MzkwMDAsMzgyMTAwMCwxMTUyMDAwLDg1MzAwMCwxMzczMDAwLDI5NTAwMCwxNDg5MDAwLDE0MjEwMDAsMjcyNDAwMCw1MDYxMDAwLDI2NTcwMDAsMjYzNzAwMCwyOTkwMDAsMjE1NzAwMCwxNTAxMDAwLDM2OTAwMDAsMzU3OTAwMCw0MjE5MDAwLDI4NTgwMDAsNTI0MzAwMCwxNTA0MDAwLDEyMTMwMDAsMjM4NDAwMCw3NzgwMDAsMjgyNjAwMCwxNzQ5MDAwLDM2MjAwMCwyNzEzMDAwLDMzODYwMDAsMzE2NjAwMCwxNTMwMDAsNzk0MDAwLDMyMTcwMDAsMjA4MjAwMCw0MTUwMDAsMzMyMDAwMCwyMTA1MDAwLDE1NzYwMDAsMjUxMDAwLDIzMjkwMDAsOTI1MDAwLDM3MTUwMDAsNjkyMDAwLDE5MDIwMDAsMjA0NzAwMCwyNTM5MDAwLDIwMjkwMDAsMzE3OTAwMCwyMTA2MDAwLDg5NTAwMCwxNTUwMDAwLDYwNzAwMCw0MTA1MDAwLDM0ODMwMDAsMzcxNTAwMCw0OTQwMDAwLDIyODAwMCw0MDI2MDAwLDE2MTYwMDAsMzMxNDAwMCwyNDIyMDAwXSwib3BzIjoyMTY2MDgwfSx7Im5hbWUiOiJDcmVhdGUgbmV3IG9iamVjdCIsImNvZGUiOiJjb25zdCBuZXdEYXRhID0ge1xuICBvcGVyYXRpb246IGRhdGEub3BlcmF0aW9uLFxuICByb290RmllbGQ6IGRhdGEucm9vdEZpZWxkLFxuICBhcmdzOiBkYXRhLmFyZ3MsXG4gIGRhdGFQYXRoOiBkYXRhLmRhdGFQYXRoXG59IiwicnVucyI6WzcwNTAwMCwxMTAwMDAsMzI3NTAwMCwxOTgwMDAsMjE5OTAwMCw0MzYwMDAsODI4MDAwLDI5MjcwMDAsNzI0MDAwLDI1NDAwMCwyOTgzMDAwLDI2NzIwMDAsMjUzMDAwLDI4MjcwMDAsMzA0ODAwMCwyOTA3MDAwLDM0OTkwMDAsMjY1OTAwMCwzODIyMDAwLDI3NzcwMDAsMzc5NzAwMCw4MDAwMDAsNDM1MDAwLDExOTMwMDAsMTAwMDAsMTQ0MDAwMCw3NTcwMDAsMTMyMDAwMCwzMjIwMDAsMjA3MDAwLDM2ODAwMDAsMzkxMTAwMCwzMjQxMDAwLDExMDcwMDAsNDM4MDAwLDMwNDQwMDAsMTA3NjAwMCwyMTAwMDAsNDIxOTAwMCwzNzQ4MDAwLDQwNjcwMDAsNzc0MDAwLDYzMDAwLDMyMTAwMCwzMDQ4MDAwLDMxMjgwMDAsMTg3MTAwMCwzNTkxMDAwLDI0MzcwMDAsNjcxMDAwLDc5OTAwMCwxMTUzMDAwLDIxMTMwMDAsOTUwMDAsNTg3MDAwLDYyMzAwMCwxMzEzMDAwLDMxNTgwMDAsMzMyNzAwMCwxNTkwMDAsNDg4MDAwLDIxMTAwMCwxMjk0MDAwLDExNTcwMDAsNDA0MDAwLDM2MjMwMDAsMjY4NDAwMCw4NzkwMDAsMjE4NTAwMCwxNTkyMDAwLDM2ODcwMDAsMjI0ODAwMCwyMjE4MDAwLDE3NDMwMDAsNzg4MDAwLDQwODYwMDAsMjExNTAwMCwzOTE0MDAwLDM5MjgwMDAsNDM3MjAwMCwxOTkwMDAsMzc1MzAwMCwzNjQ3MDAwLDE2MjcwMDAsMTQ5OTAwMCwxODQyMDAwLDIxMjkwMDAsNDAwMCwxMjIzMDAwLDI4NjMwMDAsMzgzNDAwMCwzNjk0MDAwLDYzNjAwMCw0MjQ3MDAwLDQwMjIwMDAsMTAwMDAsMTcxNDAwMCwxNzUwMDAwLDI5MDEwMDAsMTM0NjAwMF0sIm9wcyI6MTkzOTEyMH1dLCJ1cGRhdGVkIjoiMjAyMC0wNy0xNVQxMTowMDo1Ny45MzhaIn0%3D\n          const params: MiddlewareParams = {\n            args: internalParams.args,\n            dataPath: internalParams.dataPath,\n            runInTransaction: internalParams.runInTransaction,\n            action: internalParams.action,\n            model: internalParams.model,\n          }\n          return resource.runInAsyncScope(() =>\n            this._requestWithMiddlewares(\n              params,\n              this._middlewares.slice(),\n              internalParams.clientMethod,\n              internalParams.callsite,\n              internalParams.headers,\n            ),\n          )\n        }\n\n        return resource.runInAsyncScope(() =>\n          this._executeRequest(internalParams),\n        )\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _requestWithMiddlewares(\n      params: MiddlewareParams,\n      middlewares: Middleware[],\n      clientMethod: string,\n      callsite?: string,\n      headers?: Record<string, string>,\n    ) {\n      const middleware = middlewares.shift()\n      if (middleware) {\n        return middleware(params, (params2) =>\n          this._requestWithMiddlewares(\n            params2,\n            middlewares,\n            clientMethod,\n            callsite,\n          ),\n        )\n      }\n\n      // No, we won't copy the whole object here just to make it easier to do TypeScript\n      // as it would be much slower\n      ; (params as InternalRequestParams).clientMethod = clientMethod\n        ; (params as InternalRequestParams).callsite = callsite\n        ; (params as InternalRequestParams).headers = headers\n\n      return this._executeRequest(params as InternalRequestParams)\n    }\n\n    private _executeRequest({\n      args,\n      clientMethod,\n      dataPath,\n      callsite,\n      runInTransaction,\n      action,\n      model,\n      headers,\n    }: InternalRequestParams) {\n      if (action !== 'executeRaw' && action !== 'queryRaw' && !model) {\n        throw new Error(`Model missing for action ${action}`)\n      }\n\n      if ((action === 'executeRaw' || action === 'queryRaw') && model) {\n        throw new Error(\n          `executeRaw and queryRaw can't be executed on a model basis. The model ${model} has been provided`,\n        )\n      }\n\n      let rootField: string | undefined\n      const operation = actionOperationMap[action]\n\n      if (action === 'executeRaw' || action === 'queryRaw') {\n        rootField = action\n      }\n\n      // TODO: Replace with lookup map for speedup\n      let mapping\n      if (model) {\n        mapping = this._dmmf.mappingsMap[model]\n        if (!mapping) {\n          throw new Error(`Could not find mapping for model ${model}`)\n        }\n\n        rootField = mapping[action]\n      }\n\n      if (operation !== 'query' && operation !== 'mutation') {\n        throw new Error(`Invalid operation ${operation} for action ${action}`)\n      }\n\n      const field = this._dmmf.rootFieldMap[rootField!]\n\n      if (!field) {\n        throw new Error(\n          `Could not find rootField ${rootField} for action ${action} for model ${model} on rootType ${operation}`,\n        )\n      }\n\n      const { isList } = field.outputType\n      const typeName = getOutputTypeName(field.outputType.type)\n\n      let document = makeDocument({\n        dmmf: this._dmmf,\n        rootField: rootField!,\n        rootTypeName: operation,\n        select: args,\n      })\n\n      document.validate(args, false, clientMethod, this._errorFormat, callsite)\n\n      document = transformDocument(document)\n\n      // as printJsonWithErrors takes a bit of compute\n      // we only want to do it, if debug is enabled for 'prisma-client'\n      if (Debug.enabled('prisma-client')) {\n        const query = String(document)\n        debug(`Prisma Client call:`)\n        debug(\n          `prisma.${clientMethod}(${printJsonWithErrors({\n            ast: args,\n            keyPaths: [],\n            valuePaths: [],\n            missingItems: [],\n          })})`,\n        )\n        debug(`Generated request:`)\n        debug(query + '\\n')\n      }\n\n      return this._fetcher.request({\n        document,\n        clientMethod,\n        typeName,\n        dataPath,\n        isList,\n        rootField: rootField!,\n        callsite,\n        showColors: this._errorFormat === 'pretty',\n        args,\n        engineHook: this._engineMiddlewares[0],\n        runInTransaction,\n        headers,\n      })\n    }\n\n    private _bootstrapClient() {\n      const clients = this._dmmf.mappings.reduce((acc, mapping) => {\n        const lowerCaseModel = lowerCase(mapping.model)\n        const model = this._dmmf.modelMap[mapping.model]\n\n        if (!model) {\n          throw new Error(`Invalid mapping ${mapping.model}, can't find model`)\n        }\n\n        const prismaClient = ({\n          operation,\n          actionName,\n          args,\n          dataPath,\n          modelName,\n        }) => {\n          dataPath = dataPath ?? []\n\n          const clientMethod = `${lowerCaseModel}.${actionName}`\n\n          let requestPromise: Promise<any>\n          const callsite = this._getCallsite()\n\n          const requestModelName = modelName ?? model.name\n\n          const clientImplementation = {\n            then: (onfulfilled, onrejected) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.then(onfulfilled, onrejected)\n            },\n            requestTransaction: () => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: true,\n                })\n              }\n\n              return requestPromise\n            },\n            catch: (onrejected) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.catch(onrejected)\n            },\n            finally: (onfinally) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.finally(onfinally)\n            },\n          }\n\n          // add relation fields\n          for (const field of model.fields.filter((f) => f.kind === 'object')) {\n            clientImplementation[field.name] = (fieldArgs) => {\n              const prefix = dataPath.includes('select')\n                ? 'select'\n                : dataPath.includes('include')\n                  ? 'include'\n                  : 'select'\n              const newDataPath = [...dataPath, prefix, field.name]\n              const newArgs = deepSet(args, newDataPath, fieldArgs || true)\n\n              return clients[field.type]({\n                operation,\n                actionName,\n                args: newArgs,\n                dataPath: newDataPath,\n                isList: field.isList,\n                /*\n                 * necessary for user.posts() calls -> the original model name needs to be preserved\n                 */\n                modelName: modelName || model.name,\n              })\n            }\n          }\n\n          return clientImplementation\n        }\n\n        acc[model.name] = prismaClient\n\n        return acc\n      }, {})\n\n      for (const mapping of this._dmmf.mappings) {\n        const lowerCaseModel = lowerCase(mapping.model)\n\n        const denyList = {\n          model: true,\n          plural: true,\n          aggregate: true,\n        }\n\n        const delegate: any = Object.entries(mapping).reduce(\n          (acc, [actionName, rootField]) => {\n            if (!denyList[actionName]) {\n              const operation = getOperation(actionName as any)\n              acc[actionName] = (args) =>\n                clients[mapping.model]({\n                  operation,\n                  actionName,\n                  args,\n                })\n            }\n\n            return acc\n          },\n          {},\n        )\n\n        delegate.count = (args) => {\n          return clients[mapping.model]({\n            operation: 'query',\n            actionName: `aggregate`,\n            args: args\n              ? {\n                ...args,\n                select: { count: true },\n              }\n              : undefined,\n            dataPath: ['count'],\n          })\n        }\n\n        delegate.aggregate = (args) => {\n          /**\n           * avg, count, sum, min, max need to go into select\n           * For speed reasons we can go with \"for in \"\n           */\n          const select = Object.entries(args).reduce((acc, [key, value]) => {\n            if (aggregateKeys[key]) {\n              if (!acc.select) {\n                acc.select = {}\n              }\n              // `count` doesn't have a sub-selection\n              if (key === 'count') {\n                acc.select[key] = value\n              } else {\n                acc.select[key] = { select: value }\n              }\n            } else {\n              acc[key] = value\n            }\n            return acc\n          }, {} as any)\n\n          return clients[mapping.model]({\n            operation: 'query',\n            actionName: 'aggregate', // actionName is just cosmetics \uD83D\uDC85\uD83C\uDFFD\n            rootField: mapping.aggregate,\n            args: select,\n            dataPath: [],\n          })\n        }\n\n        this[lowerCaseModel] = delegate\n      }\n    }\n  }\n\n  return NewPrismaClient\n}\n\nexport class PrismaClientFetcher {\n  prisma: any\n  debug: boolean\n  hooks: any\n  dataloader: Dataloader<{\n    document: Document\n    runInTransaction?: boolean\n    headers?: Record<string, string>\n  }>\n\n  constructor(prisma, enableDebug = false, hooks?: any) {\n    this.prisma = prisma\n    this.debug = enableDebug\n    this.hooks = hooks\n    this.dataloader = new Dataloader({\n      batchLoader: async (requests) => {\n        const queries = requests.map((r) => String(r.document))\n        const runTransaction = requests[0].runInTransaction\n        return this.prisma._engine.requestBatch(queries, runTransaction)\n      },\n      singleLoader: async (request) => {\n        const query = String(request.document)\n        return this.prisma._engine.request(query, request.headers)\n      },\n      batchBy: (request) => {\n        if (request.runInTransaction) {\n          return 'transaction-batch'\n        }\n\n        if (!request.document.children[0].name.startsWith('findOne')) {\n          return null\n        }\n\n        const selectionSet = request.document.children[0].children!.join(',')\n\n        const args = request.document.children[0].args?.args\n          .map((a) => {\n            if (a.value instanceof Args) {\n              return a.key + '-' + a.value.args.map((a) => a.key).join(',')\n            }\n            return a.key\n          })\n          .join(',')\n\n        return `${request.document.children[0].name}|${args}|${selectionSet}`\n      },\n    })\n  }\n\n  async request({\n    document,\n    dataPath = [],\n    rootField,\n    typeName,\n    isList,\n    callsite,\n    clientMethod,\n    runInTransaction,\n    showColors,\n    engineHook,\n    args,\n    headers,\n  }: {\n    document: Document\n    dataPath: string[]\n    rootField: string\n    typeName: string\n    isList: boolean\n    clientMethod: string\n    callsite?: string\n    runInTransaction?: boolean\n    showColors?: boolean\n    engineHook?: EngineMiddleware\n    args: any\n    headers?: Record<string, string>\n  }) {\n    if (this.hooks && this.hooks.beforeRequest) {\n      const query = String(document)\n      this.hooks.beforeRequest({\n        query,\n        path: dataPath,\n        rootField,\n        typeName,\n        document,\n        isList,\n        clientMethod,\n        args,\n      })\n    }\n    try {\n      /**\n       * If there's an engine hook, use it here\n       */\n      let data, elapsed\n      if (engineHook) {\n        const result = await engineHook(\n          {\n            document,\n            runInTransaction,\n          },\n          (params) => this.dataloader.request(params),\n        )\n        data = result.data\n        elapsed = result.elapsed\n      } else {\n        const result = await this.dataloader.request({\n          document,\n          runInTransaction,\n          headers,\n        })\n        data = result.data\n        elapsed = result.elapsed\n      }\n\n      /**\n       * Unpack\n       */\n      const unpackResult = this.unpack(document, data, dataPath, rootField)\n      if (process.env.PRISMA_CLIENT_GET_TIME) {\n        return { data: unpackResult, elapsed }\n      }\n      return unpackResult\n    } catch (e) {\n      debug(e)\n      let message = e.message\n      if (callsite) {\n        const { stack } = printStack({\n          callsite,\n          originalMethod: clientMethod,\n          onUs: e.isPanic,\n          showColors,\n        })\n        message = stack + '\\n  ' + e.message\n      }\n\n      message = this.sanitizeMessage(message)\n      // TODO: Do request with callsite instead, so we don't need to rethrow\n      if (e.code) {\n        throw new PrismaClientKnownRequestError(\n          message,\n          e.code,\n          this.prisma._clientVersion,\n          e.meta,\n        )\n      } else if (e.isPanic) {\n        throw new PrismaClientRustPanicError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientUnknownRequestError) {\n        throw new PrismaClientUnknownRequestError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientInitializationError) {\n        throw new PrismaClientInitializationError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientRustPanicError) {\n        throw new PrismaClientRustPanicError(\n          message,\n          this.prisma._clientVersion,\n        )\n      }\n\n      e.clientVersion = this.prisma._clientVersion\n\n      throw e\n    }\n  }\n\n  sanitizeMessage(message) {\n    if (this.prisma._errorFormat && this.prisma._errorFormat !== 'pretty') {\n      return stripAnsi(message)\n    }\n    return message\n  }\n  unpack(document, data, path, rootField) {\n    if (data.data) {\n      data = data.data\n    }\n    const getPath: any[] = []\n    if (rootField) {\n      getPath.push(rootField)\n    }\n    getPath.push(...path.filter((p) => p !== 'select' && p !== 'include'))\n    return unpack({ document, data, path: getPath })\n  }\n}\n\nexport function getOperation(action: DMMF.ModelAction): 'query' | 'mutation' {\n  if (\n    action === DMMF.ModelAction.findMany ||\n    action === DMMF.ModelAction.findOne ||\n    action === DMMF.ModelAction.findFirst\n  ) {\n    return 'query'\n  }\n  return 'mutation'\n}\n", "import { DMMFClass } from './dmmf'\nimport { DMMF } from './dmmf-types'\nimport path from 'path'\nimport {\n  PrismaClientKnownRequestError,\n  PrismaClientUnknownRequestError,\n  PrismaClientInitializationError,\n  PrismaClientRustPanicError,\n} from '.'\nimport {\n  NodeEngine,\n  EngineConfig,\n  DatasourceOverwrite,\n} from '@prisma/engine-core/dist/NodeEngine'\nimport {\n  Document,\n  makeDocument,\n  unpack,\n  transformDocument,\n  Args,\n} from './query'\nimport Debug from '@prisma/debug'\nconst debug = Debug('prisma-client')\nimport fs from 'fs'\nimport chalk from 'chalk'\nimport * as sqlTemplateTag from 'sql-template-tag'\nimport dotenv from 'dotenv'\nimport { dotenvExpand } from '@prisma/sdk/dist/dotenvExpand'\nimport {\n  GeneratorConfig,\n  DataSource,\n} from '@prisma/generator-helper/dist/types'\nimport { getLogLevel } from './getLogLevel'\nimport { mergeBy } from './mergeBy'\nimport { lowerCase, getOutputTypeName } from './utils/common'\nimport { deepSet } from './utils/deep-set'\nimport { Dataloader } from './Dataloader'\nimport { printStack } from './utils/printStack'\nimport stripAnsi from 'strip-ansi'\nimport { printJsonWithErrors } from './utils/printJsonErrors'\nimport { ConnectorType } from './utils/printDatasources'\nimport { omit } from './utils/omit'\nimport { mapPreviewFeatures } from '@prisma/sdk/dist/utils/mapPreviewFeatures'\nimport { serializeRawParameters } from './utils/serializeRawParameters'\nimport { AsyncResource } from 'async_hooks'\nimport { clientVersion } from './utils/clientVersion'\nimport { mssqlPreparedStatement } from './utils/mssqlPreparedStatement'\n\nexport type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n\nexport type Datasource = {\n  url?: string\n}\nexport type Datasources = Record<string, Datasource>\n\nexport interface PrismaClientOptions {\n  /**\n   * Overwrites the datasource url from your prisma.schema file\n   */\n  datasources?: Datasources\n\n  /**\n   * @default \"colorless\"\n   */\n  errorFormat?: ErrorFormat\n\n  /**\n   * @example\n   * \\`\\`\\`\n   * // Defaults to stdout\n   * log: ['query', 'info', 'warn']\n   *\n   * // Emit as events\n   * log: [\n   *  { emit: 'stdout', level: 'query' },\n   *  { emit: 'stdout', level: 'info' },\n   *  { emit: 'stdout', level: 'warn' }\n   * ]\n   * \\`\\`\\`\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n   */\n  log?: Array<LogLevel | LogDefinition>\n\n  /**\n   * @internal\n   * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\n   */\n  __internal?: {\n    debug?: boolean\n    hooks?: Hooks\n    useUds?: boolean\n    engine?: {\n      cwd?: string\n      binaryPath?: string\n      endpoint?: string\n      enableEngineDebugMode?: boolean\n    }\n  }\n}\n\nexport type HookParams = {\n  query: string\n  path: string[]\n  rootField?: string\n  typeName?: string\n  document: any\n  clientMethod: string\n  args: any\n}\n\n/**\n * These options are being passed in to the middleware as \"params\"\n */\nexport type MiddlewareParams = {\n  model?: string\n  action: Action\n  args: any\n  dataPath: string[]\n  runInTransaction: boolean\n}\n\n/**\n * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation\n */\nexport type Middleware<T = any> = (\n  params: MiddlewareParams,\n  next: (params: MiddlewareParams) => Promise<T>,\n) => Promise<T>\n\nexport interface InternalRequestParams extends MiddlewareParams {\n  /**\n   * The original client method being called.\n   * Even though the rootField / operation can be changed,\n   * this method stays as it is, as it's what the user's\n   * code looks like\n   */\n  clientMethod: string\n  callsite?: string\n  headers?: Record<string, string>\n}\n\nexport type HookPoint = 'all' | 'engine'\n\nexport type EngineMiddlewareParams = {\n  document: Document\n  runInTransaction?: boolean\n}\n\n// only used by the .use() hooks\nexport type AllHookArgs = {\n  params: HookParams\n  fetch: (params: HookParams) => Promise<any>\n}\n/**\n * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation\n */\nexport type EngineMiddleware<T = any> = (\n  params: EngineMiddlewareParams,\n  next: (params: EngineMiddlewareParams) => Promise<T>,\n) => Promise<T>\n\nexport type Hooks = {\n  beforeRequest?: (options: HookParams) => any\n}\n\n/* Types for Logging */\nexport type LogLevel = 'info' | 'query' | 'warn' | 'error'\nexport type LogDefinition = {\n  level: LogLevel\n  emit: 'stdout' | 'event'\n}\n\nexport type GetLogType<\n  T extends LogLevel | LogDefinition\n  > = T extends LogDefinition\n  ? T['emit'] extends 'event'\n  ? T['level']\n  : never\n  : never\nexport type GetEvents<T extends Array<LogLevel | LogDefinition>> =\n  | GetLogType<T[0]>\n  | GetLogType<T[1]>\n  | GetLogType<T[2]>\n\nexport type QueryEvent = {\n  timestamp: Date\n  query: string\n  params: string\n  duration: number\n  target: string\n}\n\nexport type LogEvent = {\n  timestamp: Date\n  message: string\n  target: string\n}\n/* End Types for Logging */\n\nexport interface GetPrismaClientOptions {\n  document: DMMF.Document\n  generator?: GeneratorConfig\n  sqliteDatasourceOverrides?: DatasourceOverwrite[]\n  relativePath: string\n  dirname: string\n  clientVersion?: string\n  engineVersion?: string\n}\n\nexport type Action =\n  | 'findOne'\n  | 'findFirst'\n  | 'findMany'\n  | 'create'\n  | 'update'\n  | 'updateMany'\n  | 'upsert'\n  | 'delete'\n  | 'deleteMany'\n  | 'executeRaw'\n  | 'queryRaw'\n  | 'aggregate'\n\nconst actionOperationMap = {\n  findOne: 'query',\n  findFirst: 'query',\n  findMany: 'query',\n  count: 'query',\n  create: 'mutation',\n  update: 'mutation',\n  updateMany: 'mutation',\n  upsert: 'mutation',\n  delete: 'mutation',\n  deleteMany: 'mutation',\n  executeRaw: 'mutation',\n  queryRaw: 'mutation',\n  aggregate: 'query',\n}\n\nconst aggregateKeys = {\n  avg: true,\n  count: true,\n  sum: true,\n  min: true,\n  max: true,\n}\n\n// TODO: We **may** be able to get real types. However, we have both a bootstrapping\n// problem here, that we want to return a type that's not yet defined\n// and we're typecasting this anyway later\nexport function getPrismaClient(config: GetPrismaClientOptions): any {\n  class NewPrismaClient {\n    _dmmf: DMMFClass\n    _engine: NodeEngine\n    _fetcher: PrismaClientFetcher\n    _connectionPromise?: Promise<any>\n    _disconnectionPromise?: Promise<any>\n    _engineConfig: EngineConfig\n    private _errorFormat: ErrorFormat\n    private _hooks?: Hooks\n    private _getConfigPromise?: Promise<{\n      datasources: DataSource[]\n      generators: GeneratorConfig[]\n    }>\n    private _middlewares: Middleware[] = []\n    private _engineMiddlewares: EngineMiddleware[] = []\n    private _clientVersion: string\n    constructor(optionsArg?: PrismaClientOptions) {\n      this._clientVersion = config.clientVersion ?? clientVersion\n      try {\n        const options: PrismaClientOptions = optionsArg ?? {}\n        const internal = options.__internal ?? {}\n\n        const useDebug = internal.debug === true\n        if (useDebug) {\n          Debug.enable('prisma-client')\n        }\n\n        if (internal.hooks) {\n          this._hooks = internal.hooks\n        }\n\n        let predefinedDatasources = config.sqliteDatasourceOverrides ?? []\n        predefinedDatasources = predefinedDatasources.map((d) => ({\n          name: d.name,\n          url: 'file:' + path.resolve(config.dirname, d.url),\n        }))\n\n        const inputDatasources = Object.entries(options.datasources || {})\n          .filter(([_, source]) => {\n            return source && source.url\n          })\n          .map(([name, { url }]: any) => ({ name, url }))\n\n        const datasources = mergeBy(\n          predefinedDatasources,\n          inputDatasources,\n          (source) => source.name,\n        )\n\n        const engineConfig = internal.engine || {}\n\n        if (options.errorFormat) {\n          this._errorFormat = options.errorFormat\n        } else if (process.env.NODE_ENV === 'production') {\n          this._errorFormat = 'minimal'\n        } else if (process.env.NO_COLOR) {\n          this._errorFormat = 'colorless'\n        } else {\n          this._errorFormat = 'colorless' // default errorFormat\n        }\n\n        const envFile = this.readEnv()\n\n        this._dmmf = new DMMFClass(config.document)\n\n        let cwd = path.resolve(config.dirname, config.relativePath)\n\n        if (!fs.existsSync(cwd)) {\n          cwd = config.dirname\n        }\n\n        const previewFeatures = config.generator?.previewFeatures ?? []\n\n        this._engineConfig = {\n          cwd,\n          enableDebugLogs: useDebug,\n          enableEngineDebugMode: engineConfig.enableEngineDebugMode,\n          datamodelPath: path.join(config.dirname, 'schema.prisma'),\n          prismaPath: engineConfig.binaryPath ?? undefined,\n          engineEndpoint: engineConfig.endpoint,\n          datasources,\n          generator: config.generator,\n          showColors: this._errorFormat === 'pretty',\n          logLevel: options.log && (getLogLevel(options.log) as any), // TODO\n          logQueries:\n            options.log &&\n            Boolean(\n              typeof options.log === 'string'\n                ? options.log === 'query'\n                : options.log.find((o) =>\n                  typeof o === 'string' ? o === 'query' : o.level === 'query',\n                ),\n            ),\n          env: envFile,\n          flags: [],\n          clientVersion: config.clientVersion,\n          enableExperimental: mapPreviewFeatures(previewFeatures),\n          useUds: internal.useUds,\n        }\n\n        const sanitizedEngineConfig = omit(this._engineConfig, [\n          'env',\n          'datasources',\n        ])\n        debug({ engineConfig: sanitizedEngineConfig })\n\n        this._engine = new NodeEngine(this._engineConfig)\n        this._fetcher = new PrismaClientFetcher(this, false, this._hooks)\n\n        if (options.log) {\n          for (const log of options.log) {\n            const level =\n              typeof log === 'string'\n                ? log\n                : log.emit === 'stdout'\n                  ? log.level\n                  : null\n            if (level) {\n              this.$on(level, (event) => {\n                const colorMap = {\n                  query: 'blue',\n                  info: 'cyan',\n                  warn: 'yellow',\n                  error: 'red',\n                }\n                console.error(\n                  chalk[colorMap[level]](`prisma:${level}`.padEnd(13)) +\n                  (event.message || event.query),\n                )\n              })\n            }\n          }\n        }\n\n        this._bootstrapClient()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private readEnv() {\n      const dotEnvPath = path.resolve(\n        config.dirname,\n        config.relativePath,\n        '.env',\n      )\n      if (fs.existsSync(dotEnvPath)) {\n        return dotenvExpand(dotenv.config({ path: dotEnvPath })).parsed\n      }\n\n      return {}\n    }\n    use(...args) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.use() is deprecated, please use prisma.$use() instead`,\n      )\n      return (this.$use as any)(...args)\n    }\n    $use(cb: Middleware)\n    $use(namespace: 'all', cb: Middleware)\n    $use(namespace: 'engine', cb: EngineMiddleware)\n    $use(\n      namespace: HookPoint | Middleware,\n      cb?: Middleware | EngineMiddleware,\n    ) {\n      if (typeof namespace === 'function') {\n        this._middlewares.push(namespace)\n      } else if (typeof namespace === 'string') {\n        if (namespace === 'all') {\n          this._middlewares.push(cb! as Middleware)\n        } else if (namespace === 'engine') {\n          this._engineMiddlewares.push(cb! as EngineMiddleware)\n        } else {\n          throw new Error(`Unknown middleware hook ${namespace}`)\n        }\n      } else {\n        throw new Error(`Invalid middleware ${namespace}`)\n      }\n    }\n    on(eventType: any, callback: (event: any) => void) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.on() is deprecated, please use prisma.$on() instead`,\n      )\n      return this.$on(eventType, callback)\n    }\n    $on(eventType: any, callback: (event: any) => void) {\n      if (eventType === 'beforeExit') {\n        this._engine.on('beforeExit', callback)\n      } else {\n        this._engine.on(eventType, (event) => {\n          const fields = event.fields\n          if (eventType === 'query') {\n            return callback({\n              timestamp: event.timestamp,\n              query: fields.query,\n              params: fields.params,\n              duration: fields.duration_ms,\n              target: event.target,\n            })\n          } else {\n            // warn, info, or error events\n            return callback({\n              timestamp: event.timestamp,\n              message: fields.message,\n              target: event.target,\n            })\n          }\n        })\n      }\n    }\n    connect() {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.connect() is deprecated, please use prisma.$connect() instead`,\n      )\n      return this.$connect()\n    }\n    async $connect() {\n      try {\n        return this._engine.start()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n    /**\n     * @private\n     */\n    async _runDisconnect() {\n      await this._engine.stop()\n      delete this._connectionPromise\n      this._engine = new NodeEngine(this._engineConfig)\n      delete this._disconnectionPromise\n      delete this._getConfigPromise\n    }\n    disconnect() {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.disconnect() is deprecated, please use prisma.$disconnect() instead`,\n      )\n      return this.$disconnect()\n    }\n    /**\n     * Disconnect from the database\n     */\n    async $disconnect() {\n      try {\n        return this._engine.stop()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private async _getActiveProvider(): Promise<ConnectorType> {\n      const configResult = await this._engine.getConfig()\n      return configResult.datasources[0].activeProvider!\n    }\n\n    executeRaw(stringOrTemplateStringsArray, ...values) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.executeRaw() is deprecated, please use prisma.$executeRaw() instead`,\n      )\n      return this.$executeRaw(stringOrTemplateStringsArray, ...values)\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    private async $executeRawInternal(stringOrTemplateStringsArray, ...values) {\n      let query = ''\n      let parameters: any = undefined\n\n      const activeProvider = await this._getActiveProvider()\n\n      if (typeof stringOrTemplateStringsArray === 'string') {\n        // If this was called as prisma.$executeRaw(<SQL>, [...values]), assume it is a pre-prepared SQL statement, and forward it without any changes\n        query = stringOrTemplateStringsArray\n        parameters = {\n          values: serializeRawParameters(values || []),\n          __prismaRawParamaters__: true,\n        }\n      } else if (Array.isArray(stringOrTemplateStringsArray)) {\n        // If this was called as prisma.$executeRaw`<SQL>`, try to generate a SQL prepared statement\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.sql\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'postgresql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.text\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'sqlserver': {\n            query = mssqlPreparedStatement(stringOrTemplateStringsArray)\n            parameters = {\n              values: serializeRawParameters(values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n        }\n      } else {\n        // If this was called as prisma.raw(sql`<SQL>`), use prepared statements from sql-template-tag\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).sql\n            break\n          case 'postgresql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).text\n            break\n          case 'sqlserver':\n            query = mssqlPreparedStatement(\n              (stringOrTemplateStringsArray as sqlTemplateTag.Sql).strings,\n            )\n            break\n        }\n        parameters = {\n          values: serializeRawParameters(\n            (stringOrTemplateStringsArray as sqlTemplateTag.Sql).values,\n          ),\n          __prismaRawParamaters__: true,\n        }\n      }\n\n      if (parameters?.values) {\n        debug(`prisma.$executeRaw(${query}, ${parameters.values})`)\n      } else {\n        debug(`prisma.$executeRaw(${query})`)\n      }\n\n      const args = { query, parameters }\n\n      debug(`Prisma Client call:`)\n      return this._request({\n        args,\n        clientMethod: 'executeRaw',\n        dataPath: [],\n        action: 'executeRaw',\n        callsite: this._getCallsite(),\n        runInTransaction: false,\n      })\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    $executeRaw(stringOrTemplateStringsArray, ...values) {\n      try {\n        const promise = this.$executeRawInternal(stringOrTemplateStringsArray, ...values)\n          ; (promise as any).isExecuteRaw = true\n        return promise\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _getCallsite() {\n      if (this._errorFormat !== 'minimal') {\n        return new Error().stack\n      }\n      return undefined\n    }\n\n    queryRaw(stringOrTemplateStringsArray, ...args) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.queryRaw() is deprecated, please use prisma.$queryRaw() instead`,\n      )\n      return this.$queryRaw(stringOrTemplateStringsArray, ...args)\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    private async $queryRawInternal(\n      stringOrTemplateStringsArray:\n        | string\n        | TemplateStringsArray\n        | sqlTemplateTag.Sql,\n      ...values: any[]\n    ) {\n      let query = ''\n      let parameters: any = undefined\n\n      const activeProvider = await this._getActiveProvider()\n\n      if (typeof stringOrTemplateStringsArray === 'string') {\n        // If this was called as prisma.$queryRaw(<SQL>, [...values]), assume it is a pre-prepared SQL statement, and forward it without any changes\n        query = stringOrTemplateStringsArray\n        parameters = {\n          values: serializeRawParameters(values || []),\n          __prismaRawParamaters__: true,\n        }\n      } else if (Array.isArray(stringOrTemplateStringsArray)) {\n        // If this was called as prisma.$queryRaw`<SQL>`, try to generate a SQL prepared statement\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.sql\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'postgresql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.text\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'sqlserver': {\n            query = mssqlPreparedStatement(stringOrTemplateStringsArray)\n            parameters = {\n              values: serializeRawParameters(values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n        }\n      } else {\n        // If this was called as prisma.raw(sql`<SQL>`), use prepared statements from sql-template-tag\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).sql\n            break\n          case 'postgresql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).text\n            break\n          case 'sqlserver':\n            query = mssqlPreparedStatement(\n              (stringOrTemplateStringsArray as sqlTemplateTag.Sql).strings,\n            )\n            break\n        }\n        parameters = {\n          values: serializeRawParameters(\n            (stringOrTemplateStringsArray as sqlTemplateTag.Sql).values,\n          ),\n          __prismaRawParamaters__: true,\n        }\n      }\n\n      if (parameters?.values) {\n        debug(`prisma.queryRaw(${query}, ${parameters.values})`)\n      } else {\n        debug(`prisma.queryRaw(${query})`)\n      }\n\n      const args = { query, parameters }\n\n      debug(`Prisma Client call:`)\n      return this._request({\n        args,\n        clientMethod: 'queryRaw',\n        dataPath: [],\n        action: 'queryRaw',\n        callsite: this._getCallsite(),\n        runInTransaction: false,\n      })\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    $queryRaw(stringOrTemplateStringsArray, ...values) {\n      try {\n        const promise = this.$queryRawInternal(stringOrTemplateStringsArray, ...values)\n          ; (promise as any).isQueryRaw = true\n        return promise\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    async __internal_triggerPanic(fatal: boolean) {\n      if (!this._engineConfig.enableEngineDebugMode) {\n        throw new Error(`In order to use .__internal_triggerPanic(), please enable the debug mode like so:\nnew PrismaClient({\n  __internal: {\n    engine: {\n      enableEngineDebugMode: true\n    }\n  }\n})`)\n      }\n\n      const query = 'SELECT 1'\n\n      const headers: Record<string, string> = fatal\n        ? { 'X-DEBUG-FATAL': '1' }\n        : { 'X-DEBUG-NON-FATAL': '1' }\n\n      return this._request({\n        action: 'queryRaw',\n        args: {\n          query,\n          parameters: undefined,\n        },\n        clientMethod: 'queryRaw',\n        dataPath: [],\n        runInTransaction: false,\n        headers,\n        callsite: this._getCallsite(),\n      })\n    }\n\n    transaction(promises) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.transaction() is deprecated, please use prisma.$transaction() instead`,\n      )\n      return this.$transaction(promises)\n    }\n\n    private async $transactionInternal(promises: Array<any>): Promise<any> {\n      if (config.generator?.previewFeatures?.includes('transactionApi')) {\n        for (const p of promises) {\n          if (!p) {\n            throw new Error(\n              `All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`,\n            )\n          }\n          if (p?.isQueryRaw) {\n            throw new Error(`$queryRaw is not yet supported within $transaction.\nPlease report in https://github.com/prisma/prisma/issues/3828 if you need this feature.`)\n          }\n          if (p?.isExecuteRaw) {\n            throw new Error(`$executeRaw is not yet supported within $transaction.\nPlease report in https://github.com/prisma/prisma/issues/3828 if you need this feature`)\n          }\n          if (\n            !p.requestTransaction ||\n            typeof p.requestTransaction !== 'function'\n          ) {\n            throw new Error(\n              `All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`,\n            )\n          }\n        }\n        return Promise.all(promises.map((p) => p.requestTransaction()))\n      } else {\n        throw new Error(\n          `In order to use the .transaction() api, please enable 'previewFeatures = \"transactionApi\" in your schema.`,\n        )\n      }\n    }\n\n    async $transaction(promises: Array<any>): Promise<any> {\n      try {\n        return this.$transactionInternal(promises)\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _request(internalParams: InternalRequestParams) {\n      try {\n        const resource = new AsyncResource('prisma-client-request')\n        if (this._middlewares.length > 0) {\n          // https://perf.link/#eyJpZCI6Img4bmd0anp5eGxrIiwidGl0bGUiOiJGaW5kaW5nIG51bWJlcnMgaW4gYW4gYXJyYXkgb2YgMTAwMCIsImJlZm9yZSI6ImNvbnN0IGRhdGEgPSB7XG4gIG9wZXJhdGlvbjogXCJxdWVyeVwiLFxuICByb290RmllbGQ6IFwiZmluZE1hbnlVc2VyXCIsXG4gIGFyZ3M6IHtcbiAgICB3aGVyZTogeyBpZDogeyBndDogNSB9IH1cbiAgfSxcbiAgZGF0YVBhdGg6IFtdLFxuICBjbGllbnRNZXRob2Q6ICd1c2VyLmZpbmRNYW55J1xufSIsInRlc3RzIjpbeyJuYW1lIjoiZm9yIGluIiwiY29kZSI6ImNvbnN0IG5ld0RhdGEgPSB7fVxuZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICBpZiAoa2V5ICE9PSAnY2xpZW50TWV0aG9kJykge1xuICAgIG5ld0RhdGFba2V5XSA9IGRhdGFba2V5XVxuICB9XG59IiwicnVucyI6WzU1MzAwMCw0OTAwMDAsMzQ0MDAwLDYyNDAwMCwxMzkxMDAwLDEyMjQwMDAsMTA2NDAwMCwxMjE3MDAwLDc0MDAwLDM3MzAwMCw5MDUwMDAsNTM3MDAwLDE3MDYwMDAsOTAzMDAwLDE0MjUwMDAsMTMxMjAwMCw3NjkwMDAsMTM0NTAwMCwxOTQ4MDAwLDk5MDAwMCw5MDAwMDAsMTM0ODAwMCwxMDk2MDAwLDM4NjAwMCwxNTE3MDAwLDE5MzYwMDAsMTAwMCwyMTM0MDAwLDEzMjgwMDAsODI5MDAwLDE1ODYwMDAsMTc2MzAwMCw1MDgwMDAsOTg2MDAwLDE5NDkwMDAsMjEwODAwMCwxNjA4MDAwLDIyNDAwMCwxOTAyMDAwLDEyNjgwMDAsMjEzNDAwMCwxNzEwMDAwLDEzNzIwMDAsMjExMDAwMCwxNzgwMDAwLDc3NzAwMCw1NzgwMDAsNDAwMCw4OTAwMDAsMTEwMTAwMCwxNTk0MDAwLDE3ODAwMDAsMzU0MDAwLDU0NDAwMCw4MjQwMDAsNzEwMDAwLDg0OTAwMCwxNjQwMDAwLDE5ODQwMDAsNzAzMDAwLDg4MjAwMCw4NTAwMDAsMTA2MDAwLDMwMzAwMCwxMzMwMDAsNjA4MDAwLDIxMzQwMDAsNTUxMDAwLDc0MjAwMCwyMDcwMDAsMTU3NTAwMCwxMzQwMDAsNDAwMCwxMDAwLDQ5NDAwMCwyNTAwMDAsMTQwMjAwMCw2OTgwMDAsNTgxMDAwLDQ4MDAwMCwyMDMwMDAsMTY4MzAwMCwxNjcxMDAwLDEyNDAwMDAsMTk1NjAwMCwzMDUwMDAsODkwMDAsNjUzMDAwLDE3MDgwMDAsMTYwMTAwMCwxOTg0MDAwLDg4ODAwMCwyMTAwMDAwLDE5NzUwMDAsNTM2MDAwLDU3NTAwMCwyMTM0MDAwLDEwMTcwMDAsMTI5NzAwMCw3NTYwMDBdLCJvcHMiOjEwNDUxNTB9LHsibmFtZSI6IkRlY29uc3RydWN0b3IiLCJjb2RlIjoiY29uc3QgeyBjbGllbnRNZXRob2QsIC4uLnJlc3QgfSA9IGRhdGEiLCJydW5zIjpbMjE0MDAwLDUxMDAwLDg2NDAwMCw3MjcwMDAsNDMxMDAwLDIyMDAwMCwzOTAwMDAsODQxMDAwLDIyOTAwMCw3MjIwMDAsNDEzMDAwLDYwODAwMCwyOTgwMDAsMzY4MDAwLDg2NDAwMCw5MjQwMDAsMTI4MDAwLDU1MzAwMCw4ODAwMDAsNTQ1MDAwLDc3NTAwMCw0MzAwMDAsMjM3MDAwLDc4NjAwMCw1NTUwMDAsNTI2MDAwLDMyNzAwMCw2MzAwMCw5MTIwMDAsMTgxMDAwLDMzMTAwMCw0MzAwMCwyMjUwMDAsNTQ3MDAwLDgyMjAwMCw3OTMwMDAsMTA1NzAwMCw1NjAwMCwyNzUwMDAsMzkzMDAwLDgwNTAwMCw5MzAwMCw3NjYwMDAsODM0MDAwLDUwMzAwMCw4MDAwMCwyMzgwMDAsNDY0MDAwLDU2NDAwMCw3MzAwMDAsOTU1MDAwLDgwOTAwMCwyMDMwMDAsNDEzMDAwLDM0NDAwMCw1MDIwMDAsNjEzMDAwLDEwMDAwMCw0MzIwMDAsNjcwMDAwLDQ1MzAwMCw4OTEwMDAsNTUwMDAsMjMwMDAwLDM5MTAwMCw3NTQwMDAsMTEyMjAwMCw3NjIwMDAsMzU3MDAwLDQ3MDAwLDc5MjAwMCwzNTQwMDAsMTA4MDAwMCwxNjAwMCwxODgwMDAsMTQxMDAwLDIxMDAwMCw2MDcwMDAsOTAyMDAwLDgyNTAwMCwxOTAwMDAsMjMzMDAwLDI4MzAwMCwyMzgwMDAsNjk2MDAwLDc2ODAwMCw3NTgwMDAsMTk0MDAwLDI3OTAwMCwyMjMwMDAsMjM4MDAwLDkzNDAwMCw2MDUwMDAsMTcwMDAsMjEwMDAwLDMyMjAwMCwxMDM0MDAwLDgxMjAwMCw0NDYwMDAsNjMxMDAwXSwib3BzIjo0OTAxMDB9LHsibmFtZSI6ImRlbGV0ZSIsImNvZGUiOiJjb25zdCB7IGNsaWVudE1ldGhvZCB9ID0gZGF0YVxuZGVsZXRlIGRhdGEuY2xpZW50TWV0aG9kIiwicnVucyI6WzI3NjIwMDAsNjIyMDAwLDEwNTcwMDAsMzIzMTAwMCwzNDQ2MDAwLDIwNzMwMDAsMzM4MjAwMCwyNzA0MDAwLDM4ODEwMDAsMTIwMTAwMCwzNzk3MDAwLDI1OTAwMCwxMDI4MDAwLDI1MTgwMDAsMjEwMjAwMCwxOTczMDAwLDM0MTIwMDAsMzU4MDAwLDExNDcwMDAsMTA3NDAwMCwzMTk1MDAwLDM2NzUwMDAsNTQ3MDAwLDIwNzkwMDAsMjc0NTAwMCwyNDE1MDAwLDIxOTAwMCwzNzM3MDAwLDM2OTIwMDAsMTY0MDAwLDI0MzMwMDAsNjQzMDAwLDcxODAwMCw0Mzg2MDAwLDE3MDIwMDAsMTAyNDAwMCw1NjUwMDAsNDIxOTAwMCwxMTk3MDAwLDE4MzkwMDAsMzgyMTAwMCwxMTUyMDAwLDg1MzAwMCwxMzczMDAwLDI5NTAwMCwxNDg5MDAwLDE0MjEwMDAsMjcyNDAwMCw1MDYxMDAwLDI2NTcwMDAsMjYzNzAwMCwyOTkwMDAsMjE1NzAwMCwxNTAxMDAwLDM2OTAwMDAsMzU3OTAwMCw0MjE5MDAwLDI4NTgwMDAsNTI0MzAwMCwxNTA0MDAwLDEyMTMwMDAsMjM4NDAwMCw3NzgwMDAsMjgyNjAwMCwxNzQ5MDAwLDM2MjAwMCwyNzEzMDAwLDMzODYwMDAsMzE2NjAwMCwxNTMwMDAsNzk0MDAwLDMyMTcwMDAsMjA4MjAwMCw0MTUwMDAsMzMyMDAwMCwyMTA1MDAwLDE1NzYwMDAsMjUxMDAwLDIzMjkwMDAsOTI1MDAwLDM3MTUwMDAsNjkyMDAwLDE5MDIwMDAsMjA0NzAwMCwyNTM5MDAwLDIwMjkwMDAsMzE3OTAwMCwyMTA2MDAwLDg5NTAwMCwxNTUwMDAwLDYwNzAwMCw0MTA1MDAwLDM0ODMwMDAsMzcxNTAwMCw0OTQwMDAwLDIyODAwMCw0MDI2MDAwLDE2MTYwMDAsMzMxNDAwMCwyNDIyMDAwXSwib3BzIjoyMTY2MDgwfSx7Im5hbWUiOiJDcmVhdGUgbmV3IG9iamVjdCIsImNvZGUiOiJjb25zdCBuZXdEYXRhID0ge1xuICBvcGVyYXRpb246IGRhdGEub3BlcmF0aW9uLFxuICByb290RmllbGQ6IGRhdGEucm9vdEZpZWxkLFxuICBhcmdzOiBkYXRhLmFyZ3MsXG4gIGRhdGFQYXRoOiBkYXRhLmRhdGFQYXRoXG59IiwicnVucyI6WzcwNTAwMCwxMTAwMDAsMzI3NTAwMCwxOTgwMDAsMjE5OTAwMCw0MzYwMDAsODI4MDAwLDI5MjcwMDAsNzI0MDAwLDI1NDAwMCwyOTgzMDAwLDI2NzIwMDAsMjUzMDAwLDI4MjcwMDAsMzA0ODAwMCwyOTA3MDAwLDM0OTkwMDAsMjY1OTAwMCwzODIyMDAwLDI3NzcwMDAsMzc5NzAwMCw4MDAwMDAsNDM1MDAwLDExOTMwMDAsMTAwMDAsMTQ0MDAwMCw3NTcwMDAsMTMyMDAwMCwzMjIwMDAsMjA3MDAwLDM2ODAwMDAsMzkxMTAwMCwzMjQxMDAwLDExMDcwMDAsNDM4MDAwLDMwNDQwMDAsMTA3NjAwMCwyMTAwMDAsNDIxOTAwMCwzNzQ4MDAwLDQwNjcwMDAsNzc0MDAwLDYzMDAwLDMyMTAwMCwzMDQ4MDAwLDMxMjgwMDAsMTg3MTAwMCwzNTkxMDAwLDI0MzcwMDAsNjcxMDAwLDc5OTAwMCwxMTUzMDAwLDIxMTMwMDAsOTUwMDAsNTg3MDAwLDYyMzAwMCwxMzEzMDAwLDMxNTgwMDAsMzMyNzAwMCwxNTkwMDAsNDg4MDAwLDIxMTAwMCwxMjk0MDAwLDExNTcwMDAsNDA0MDAwLDM2MjMwMDAsMjY4NDAwMCw4NzkwMDAsMjE4NTAwMCwxNTkyMDAwLDM2ODcwMDAsMjI0ODAwMCwyMjE4MDAwLDE3NDMwMDAsNzg4MDAwLDQwODYwMDAsMjExNTAwMCwzOTE0MDAwLDM5MjgwMDAsNDM3MjAwMCwxOTkwMDAsMzc1MzAwMCwzNjQ3MDAwLDE2MjcwMDAsMTQ5OTAwMCwxODQyMDAwLDIxMjkwMDAsNDAwMCwxMjIzMDAwLDI4NjMwMDAsMzgzNDAwMCwzNjk0MDAwLDYzNjAwMCw0MjQ3MDAwLDQwMjIwMDAsMTAwMDAsMTcxNDAwMCwxNzUwMDAwLDI5MDEwMDAsMTM0NjAwMF0sIm9wcyI6MTkzOTEyMH1dLCJ1cGRhdGVkIjoiMjAyMC0wNy0xNVQxMTowMDo1Ny45MzhaIn0%3D\n          const params: MiddlewareParams = {\n            args: internalParams.args,\n            dataPath: internalParams.dataPath,\n            runInTransaction: internalParams.runInTransaction,\n            action: internalParams.action,\n            model: internalParams.model,\n          }\n          return resource.runInAsyncScope(() =>\n            this._requestWithMiddlewares(\n              params,\n              this._middlewares.slice(),\n              internalParams.clientMethod,\n              internalParams.callsite,\n              internalParams.headers,\n            ),\n          )\n        }\n\n        return resource.runInAsyncScope(() =>\n          this._executeRequest(internalParams),\n        )\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _requestWithMiddlewares(\n      params: MiddlewareParams,\n      middlewares: Middleware[],\n      clientMethod: string,\n      callsite?: string,\n      headers?: Record<string, string>,\n    ) {\n      const middleware = middlewares.shift()\n      if (middleware) {\n        return middleware(params, (params2) =>\n          this._requestWithMiddlewares(\n            params2,\n            middlewares,\n            clientMethod,\n            callsite,\n          ),\n        )\n      }\n\n      // No, we won't copy the whole object here just to make it easier to do TypeScript\n      // as it would be much slower\n      ; (params as InternalRequestParams).clientMethod = clientMethod\n        ; (params as InternalRequestParams).callsite = callsite\n        ; (params as InternalRequestParams).headers = headers\n\n      return this._executeRequest(params as InternalRequestParams)\n    }\n\n    private _executeRequest({\n      args,\n      clientMethod,\n      dataPath,\n      callsite,\n      runInTransaction,\n      action,\n      model,\n      headers,\n    }: InternalRequestParams) {\n      if (action !== 'executeRaw' && action !== 'queryRaw' && !model) {\n        throw new Error(`Model missing for action ${action}`)\n      }\n\n      if ((action === 'executeRaw' || action === 'queryRaw') && model) {\n        throw new Error(\n          `executeRaw and queryRaw can't be executed on a model basis. The model ${model} has been provided`,\n        )\n      }\n\n      let rootField: string | undefined\n      const operation = actionOperationMap[action]\n\n      if (action === 'executeRaw' || action === 'queryRaw') {\n        rootField = action\n      }\n\n      // TODO: Replace with lookup map for speedup\n      let mapping\n      if (model) {\n        mapping = this._dmmf.mappingsMap[model]\n        if (!mapping) {\n          throw new Error(`Could not find mapping for model ${model}`)\n        }\n\n        rootField = mapping[action]\n      }\n\n      if (operation !== 'query' && operation !== 'mutation') {\n        throw new Error(`Invalid operation ${operation} for action ${action}`)\n      }\n\n      const field = this._dmmf.rootFieldMap[rootField!]\n\n      if (!field) {\n        throw new Error(\n          `Could not find rootField ${rootField} for action ${action} for model ${model} on rootType ${operation}`,\n        )\n      }\n\n      const { isList } = field.outputType\n      const typeName = getOutputTypeName(field.outputType.type)\n\n      let document = makeDocument({\n        dmmf: this._dmmf,\n        rootField: rootField!,\n        rootTypeName: operation,\n        select: args,\n      })\n\n      document.validate(args, false, clientMethod, this._errorFormat, callsite)\n\n      document = transformDocument(document)\n\n      // as printJsonWithErrors takes a bit of compute\n      // we only want to do it, if debug is enabled for 'prisma-client'\n      if (Debug.enabled('prisma-client')) {\n        const query = String(document)\n        debug(`Prisma Client call:`)\n        debug(\n          `prisma.${clientMethod}(${printJsonWithErrors({\n            ast: args,\n            keyPaths: [],\n            valuePaths: [],\n            missingItems: [],\n          })})`,\n        )\n        debug(`Generated request:`)\n        debug(query + '\\n')\n      }\n\n      return this._fetcher.request({\n        document,\n        clientMethod,\n        typeName,\n        dataPath,\n        isList,\n        rootField: rootField!,\n        callsite,\n        showColors: this._errorFormat === 'pretty',\n        args,\n        engineHook: this._engineMiddlewares[0],\n        runInTransaction,\n        headers,\n      })\n    }\n\n    private _bootstrapClient() {\n      const clients = this._dmmf.mappings.reduce((acc, mapping) => {\n        const lowerCaseModel = lowerCase(mapping.model)\n        const model = this._dmmf.modelMap[mapping.model]\n\n        if (!model) {\n          throw new Error(`Invalid mapping ${mapping.model}, can't find model`)\n        }\n\n        const prismaClient = ({\n          operation,\n          actionName,\n          args,\n          dataPath,\n          modelName,\n        }) => {\n          dataPath = dataPath ?? []\n\n          const clientMethod = `${lowerCaseModel}.${actionName}`\n\n          let requestPromise: Promise<any>\n          const callsite = this._getCallsite()\n\n          const requestModelName = modelName ?? model.name\n\n          const clientImplementation = {\n            then: (onfulfilled, onrejected) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.then(onfulfilled, onrejected)\n            },\n            requestTransaction: () => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: true,\n                })\n              }\n\n              return requestPromise\n            },\n            catch: (onrejected) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.catch(onrejected)\n            },\n            finally: (onfinally) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.finally(onfinally)\n            },\n          }\n\n          // add relation fields\n          for (const field of model.fields.filter((f) => f.kind === 'object')) {\n            clientImplementation[field.name] = (fieldArgs) => {\n              const prefix = dataPath.includes('select')\n                ? 'select'\n                : dataPath.includes('include')\n                  ? 'include'\n                  : 'select'\n              const newDataPath = [...dataPath, prefix, field.name]\n              const newArgs = deepSet(args, newDataPath, fieldArgs || true)\n\n              return clients[field.type]({\n                operation,\n                actionName,\n                args: newArgs,\n                dataPath: newDataPath,\n                isList: field.isList,\n                /*\n                 * necessary for user.posts() calls -> the original model name needs to be preserved\n                 */\n                modelName: modelName || model.name,\n              })\n            }\n          }\n\n          return clientImplementation\n        }\n\n        acc[model.name] = prismaClient\n\n        return acc\n      }, {})\n\n      for (const mapping of this._dmmf.mappings) {\n        const lowerCaseModel = lowerCase(mapping.model)\n\n        const denyList = {\n          model: true,\n          plural: true,\n          aggregate: true,\n        }\n\n        const delegate: any = Object.entries(mapping).reduce(\n          (acc, [actionName, rootField]) => {\n            if (!denyList[actionName]) {\n              const operation = getOperation(actionName as any)\n              acc[actionName] = (args) =>\n                clients[mapping.model]({\n                  operation,\n                  actionName,\n                  args,\n                })\n            }\n\n            return acc\n          },\n          {},\n        )\n\n        delegate.count = (args) => {\n          return clients[mapping.model]({\n            operation: 'query',\n            actionName: `aggregate`,\n            args: args\n              ? {\n                ...args,\n                select: { count: true },\n              }\n              : undefined,\n            dataPath: ['count'],\n          })\n        }\n\n        delegate.aggregate = (args) => {\n          /**\n           * avg, count, sum, min, max need to go into select\n           * For speed reasons we can go with \"for in \"\n           */\n          const select = Object.entries(args).reduce((acc, [key, value]) => {\n            if (aggregateKeys[key]) {\n              if (!acc.select) {\n                acc.select = {}\n              }\n              // `count` doesn't have a sub-selection\n              if (key === 'count') {\n                acc.select[key] = value\n              } else {\n                acc.select[key] = { select: value }\n              }\n            } else {\n              acc[key] = value\n            }\n            return acc\n          }, {} as any)\n\n          return clients[mapping.model]({\n            operation: 'query',\n            actionName: 'aggregate', // actionName is just cosmetics \uD83D\uDC85\uD83C\uDFFD\n            rootField: mapping.aggregate,\n            args: select,\n            dataPath: [],\n          })\n        }\n\n        this[lowerCaseModel] = delegate\n      }\n    }\n  }\n\n  return NewPrismaClient\n}\n\nexport class PrismaClientFetcher {\n  prisma: any\n  debug: boolean\n  hooks: any\n  dataloader: Dataloader<{\n    document: Document\n    runInTransaction?: boolean\n    headers?: Record<string, string>\n  }>\n\n  constructor(prisma, enableDebug = false, hooks?: any) {\n    this.prisma = prisma\n    this.debug = enableDebug\n    this.hooks = hooks\n    this.dataloader = new Dataloader({\n      batchLoader: async (requests) => {\n        const queries = requests.map((r) => String(r.document))\n        const runTransaction = requests[0].runInTransaction\n        return this.prisma._engine.requestBatch(queries, runTransaction)\n      },\n      singleLoader: async (request) => {\n        const query = String(request.document)\n        return this.prisma._engine.request(query, request.headers)\n      },\n      batchBy: (request) => {\n        if (request.runInTransaction) {\n          return 'transaction-batch'\n        }\n\n        if (!request.document.children[0].name.startsWith('findOne')) {\n          return null\n        }\n\n        const selectionSet = request.document.children[0].children!.join(',')\n\n        const args = request.document.children[0].args?.args\n          .map((a) => {\n            if (a.value instanceof Args) {\n              return a.key + '-' + a.value.args.map((a) => a.key).join(',')\n            }\n            return a.key\n          })\n          .join(',')\n\n        return `${request.document.children[0].name}|${args}|${selectionSet}`\n      },\n    })\n  }\n\n  async request({\n    document,\n    dataPath = [],\n    rootField,\n    typeName,\n    isList,\n    callsite,\n    clientMethod,\n    runInTransaction,\n    showColors,\n    engineHook,\n    args,\n    headers,\n  }: {\n    document: Document\n    dataPath: string[]\n    rootField: string\n    typeName: string\n    isList: boolean\n    clientMethod: string\n    callsite?: string\n    runInTransaction?: boolean\n    showColors?: boolean\n    engineHook?: EngineMiddleware\n    args: any\n    headers?: Record<string, string>\n  }) {\n    if (this.hooks && this.hooks.beforeRequest) {\n      const query = String(document)\n      this.hooks.beforeRequest({\n        query,\n        path: dataPath,\n        rootField,\n        typeName,\n        document,\n        isList,\n        clientMethod,\n        args,\n      })\n    }\n    try {\n      /**\n       * If there's an engine hook, use it here\n       */\n      let data, elapsed\n      if (engineHook) {\n        const result = await engineHook(\n          {\n            document,\n            runInTransaction,\n          },\n          (params) => this.dataloader.request(params),\n        )\n        data = result.data\n        elapsed = result.elapsed\n      } else {\n        const result = await this.dataloader.request({\n          document,\n          runInTransaction,\n          headers,\n        })\n        data = result.data\n        elapsed = result.elapsed\n      }\n\n      /**\n       * Unpack\n       */\n      const unpackResult = this.unpack(document, data, dataPath, rootField)\n      if (process.env.PRISMA_CLIENT_GET_TIME) {\n        return { data: unpackResult, elapsed }\n      }\n      return unpackResult\n    } catch (e) {\n      debug(e)\n      let message = e.message\n      if (callsite) {\n        const { stack } = printStack({\n          callsite,\n          originalMethod: clientMethod,\n          onUs: e.isPanic,\n          showColors,\n        })\n        message = stack + '\\n  ' + e.message\n      }\n\n      message = this.sanitizeMessage(message)\n      // TODO: Do request with callsite instead, so we don't need to rethrow\n      if (e.code) {\n        throw new PrismaClientKnownRequestError(\n          message,\n          e.code,\n          this.prisma._clientVersion,\n          e.meta,\n        )\n      } else if (e.isPanic) {\n        throw new PrismaClientRustPanicError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientUnknownRequestError) {\n        throw new PrismaClientUnknownRequestError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientInitializationError) {\n        throw new PrismaClientInitializationError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientRustPanicError) {\n        throw new PrismaClientRustPanicError(\n          message,\n          this.prisma._clientVersion,\n        )\n      }\n\n      e.clientVersion = this.prisma._clientVersion\n\n      throw e\n    }\n  }\n\n  sanitizeMessage(message) {\n    if (this.prisma._errorFormat && this.prisma._errorFormat !== 'pretty') {\n      return stripAnsi(message)\n    }\n    return message\n  }\n  unpack(document, data, path, rootField) {\n    if (data.data) {\n      data = data.data\n    }\n    const getPath: any[] = []\n    if (rootField) {\n      getPath.push(rootField)\n    }\n    getPath.push(...path.filter((p) => p !== 'select' && p !== 'include'))\n    return unpack({ document, data, path: getPath })\n  }\n}\n\nexport function getOperation(action: DMMF.ModelAction): 'query' | 'mutation' {\n  if (\n    action === DMMF.ModelAction.findMany ||\n    action === DMMF.ModelAction.findOne ||\n    action === DMMF.ModelAction.findFirst\n  ) {\n    return 'query'\n  }\n  return 'mutation'\n}\n", "type LogLevel = 'info' | 'query' | 'warn' | 'error'\ntype LogDefinition = {\n  level: LogLevel\n  emit: 'stdout' | 'event'\n}\n\nexport function getLogLevel(\n  log: LogLevel | Array<LogLevel | LogDefinition>,\n): LogLevel | undefined {\n  if (typeof log === 'string') {\n    return log\n  }\n  return log.reduce<LogLevel | undefined>((acc, curr) => {\n    const currentLevel = typeof curr === 'string' ? curr : curr.level\n    if (currentLevel === 'query') {\n      return acc\n    }\n    if (!acc) {\n      return currentLevel\n    }\n    if (curr === 'info' || acc === 'info') {\n      // info has precedence\n      return 'info'\n    }\n    return currentLevel\n  }, undefined)\n}\n", "/**\n * Merge two arrays, their elements uniqueness decided by the callback.\n * In case of a duplicate, elements of `arr2` are taken.\n * If there is a duplicate within an array, the last element is being taken.\n * @param arr1 Base array\n * @param arr2 Array to overwrite the first one if there is a match\n * @param cb The function to calculate uniqueness\n */\nexport function mergeBy<T>(\n  arr1: T[],\n  arr2: T[],\n  cb: (element: T) => string,\n): T[] {\n  const groupedArr1 = groupBy(arr1, cb)\n  const groupedArr2 = groupBy(arr2, cb)\n  const result: T[] = Object.values(groupedArr2).map(\n    (value) => value[value.length - 1],\n  )\n\n  const arr2Keys = Object.keys(groupedArr2)\n  Object.entries(groupedArr1).forEach(([key, value]) => {\n    if (!arr2Keys.includes(key)) {\n      result.push(value[value.length - 1])\n    }\n  })\n\n  return result\n}\n\nconst groupBy = <T>(\n  arr: T[],\n  cb: (element: T) => string,\n): { [key: string]: T[] } => {\n  return arr.reduce<{ [key: string]: T[] }>((acc, curr) => {\n    const key = cb(curr)\n    if (!acc[key]) {\n      acc[key] = []\n    }\n    acc[key].push(curr)\n    return acc\n  }, {})\n}\n", "interface Job {\n  resolve: (data: any) => void\n  reject: (data: any) => void\n  request: any\n}\n\nexport type DataloaderOptions<T> = {\n  singleLoader: (request: T) => Promise<any>\n  batchLoader: (request: T[]) => Promise<any[]>\n  batchBy: (request: T) => string | null\n}\n\nexport class Dataloader<T = any> {\n  batches: { [key: string]: Job[] }\n  private tickActive: boolean = false\n  constructor(private options: DataloaderOptions<T>) {\n    this.batches = {}\n  }\n  request(request: T): Promise<any> {\n    const hash = this.options.batchBy(request)\n    if (!hash) {\n      return this.options.singleLoader(request)\n    }\n    if (!this.batches[hash]) {\n      this.batches[hash] = []\n\n      // make sure, that we only tick once at a time\n      if (!this.tickActive) {\n        this.tickActive = true\n        process.nextTick(() => {\n          this.dispatchBatches()\n          this.tickActive = false\n        })\n      }\n    }\n\n    return new Promise((resolve, reject) => {\n      this.batches[hash].push({\n        request,\n        resolve,\n        reject,\n      })\n    })\n  }\n\n  private dispatchBatches() {\n    for (const key in this.batches) {\n      const batch = this.batches[key]\n      delete this.batches[key]\n\n      // only batch if necessary\n      // this might occur, if there's e.g. only 1 findOne in the batch\n      if (batch.length === 1) {\n        this.options\n          .singleLoader(batch[0].request)\n          .then((result) => {\n            if (result instanceof Error) {\n              batch[0].reject(result)\n            } else {\n              batch[0].resolve(result)\n            }\n          })\n          .catch((e) => {\n            batch[0].reject(e)\n          })\n      } else {\n        this.options\n          .batchLoader(batch.map((j) => j.request))\n          .then((results) => {\n            if (results instanceof Error) {\n              for (let i = 0; i < batch!.length; i++) {\n                batch![i].reject(results)\n              }\n            } else {\n              for (let i = 0; i < batch!.length; i++) {\n                const value = results[i]\n                if (value instanceof Error) {\n                  batch![i].reject(value)\n                } else {\n                  batch![i].resolve(value)\n                }\n              }\n            }\n          })\n          .catch((e) => {\n            for (let i = 0; i < batch!.length; i++) {\n              batch![i].reject(e)\n            }\n          })\n      }\n    }\n  }\n}\n", "import { DMMFClass } from './dmmf'\nimport { DMMF } from './dmmf-types'\nimport path from 'path'\nimport {\n  PrismaClientKnownRequestError,\n  PrismaClientUnknownRequestError,\n  PrismaClientInitializationError,\n  PrismaClientRustPanicError,\n} from '.'\nimport {\n  NodeEngine,\n  EngineConfig,\n  DatasourceOverwrite,\n} from '@prisma/engine-core/dist/NodeEngine'\nimport {\n  Document,\n  makeDocument,\n  unpack,\n  transformDocument,\n  Args,\n} from './query'\nimport Debug from '@prisma/debug'\nconst debug = Debug('prisma-client')\nimport fs from 'fs'\nimport chalk from 'chalk'\nimport * as sqlTemplateTag from 'sql-template-tag'\nimport dotenv from 'dotenv'\nimport { dotenvExpand } from '@prisma/sdk/dist/dotenvExpand'\nimport {\n  GeneratorConfig,\n  DataSource,\n} from '@prisma/generator-helper/dist/types'\nimport { getLogLevel } from './getLogLevel'\nimport { mergeBy } from './mergeBy'\nimport { lowerCase, getOutputTypeName } from './utils/common'\nimport { deepSet } from './utils/deep-set'\nimport { Dataloader } from './Dataloader'\nimport { printStack } from './utils/printStack'\nimport stripAnsi from 'strip-ansi'\nimport { printJsonWithErrors } from './utils/printJsonErrors'\nimport { ConnectorType } from './utils/printDatasources'\nimport { omit } from './utils/omit'\nimport { mapPreviewFeatures } from '@prisma/sdk/dist/utils/mapPreviewFeatures'\nimport { serializeRawParameters } from './utils/serializeRawParameters'\nimport { AsyncResource } from 'async_hooks'\nimport { clientVersion } from './utils/clientVersion'\nimport { mssqlPreparedStatement } from './utils/mssqlPreparedStatement'\n\nexport type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n\nexport type Datasource = {\n  url?: string\n}\nexport type Datasources = Record<string, Datasource>\n\nexport interface PrismaClientOptions {\n  /**\n   * Overwrites the datasource url from your prisma.schema file\n   */\n  datasources?: Datasources\n\n  /**\n   * @default \"colorless\"\n   */\n  errorFormat?: ErrorFormat\n\n  /**\n   * @example\n   * \\`\\`\\`\n   * // Defaults to stdout\n   * log: ['query', 'info', 'warn']\n   *\n   * // Emit as events\n   * log: [\n   *  { emit: 'stdout', level: 'query' },\n   *  { emit: 'stdout', level: 'info' },\n   *  { emit: 'stdout', level: 'warn' }\n   * ]\n   * \\`\\`\\`\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n   */\n  log?: Array<LogLevel | LogDefinition>\n\n  /**\n   * @internal\n   * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\n   */\n  __internal?: {\n    debug?: boolean\n    hooks?: Hooks\n    useUds?: boolean\n    engine?: {\n      cwd?: string\n      binaryPath?: string\n      endpoint?: string\n      enableEngineDebugMode?: boolean\n    }\n  }\n}\n\nexport type HookParams = {\n  query: string\n  path: string[]\n  rootField?: string\n  typeName?: string\n  document: any\n  clientMethod: string\n  args: any\n}\n\n/**\n * These options are being passed in to the middleware as \"params\"\n */\nexport type MiddlewareParams = {\n  model?: string\n  action: Action\n  args: any\n  dataPath: string[]\n  runInTransaction: boolean\n}\n\n/**\n * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation\n */\nexport type Middleware<T = any> = (\n  params: MiddlewareParams,\n  next: (params: MiddlewareParams) => Promise<T>,\n) => Promise<T>\n\nexport interface InternalRequestParams extends MiddlewareParams {\n  /**\n   * The original client method being called.\n   * Even though the rootField / operation can be changed,\n   * this method stays as it is, as it's what the user's\n   * code looks like\n   */\n  clientMethod: string\n  callsite?: string\n  headers?: Record<string, string>\n}\n\nexport type HookPoint = 'all' | 'engine'\n\nexport type EngineMiddlewareParams = {\n  document: Document\n  runInTransaction?: boolean\n}\n\n// only used by the .use() hooks\nexport type AllHookArgs = {\n  params: HookParams\n  fetch: (params: HookParams) => Promise<any>\n}\n/**\n * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation\n */\nexport type EngineMiddleware<T = any> = (\n  params: EngineMiddlewareParams,\n  next: (params: EngineMiddlewareParams) => Promise<T>,\n) => Promise<T>\n\nexport type Hooks = {\n  beforeRequest?: (options: HookParams) => any\n}\n\n/* Types for Logging */\nexport type LogLevel = 'info' | 'query' | 'warn' | 'error'\nexport type LogDefinition = {\n  level: LogLevel\n  emit: 'stdout' | 'event'\n}\n\nexport type GetLogType<\n  T extends LogLevel | LogDefinition\n  > = T extends LogDefinition\n  ? T['emit'] extends 'event'\n  ? T['level']\n  : never\n  : never\nexport type GetEvents<T extends Array<LogLevel | LogDefinition>> =\n  | GetLogType<T[0]>\n  | GetLogType<T[1]>\n  | GetLogType<T[2]>\n\nexport type QueryEvent = {\n  timestamp: Date\n  query: string\n  params: string\n  duration: number\n  target: string\n}\n\nexport type LogEvent = {\n  timestamp: Date\n  message: string\n  target: string\n}\n/* End Types for Logging */\n\nexport interface GetPrismaClientOptions {\n  document: DMMF.Document\n  generator?: GeneratorConfig\n  sqliteDatasourceOverrides?: DatasourceOverwrite[]\n  relativePath: string\n  dirname: string\n  clientVersion?: string\n  engineVersion?: string\n}\n\nexport type Action =\n  | 'findOne'\n  | 'findFirst'\n  | 'findMany'\n  | 'create'\n  | 'update'\n  | 'updateMany'\n  | 'upsert'\n  | 'delete'\n  | 'deleteMany'\n  | 'executeRaw'\n  | 'queryRaw'\n  | 'aggregate'\n\nconst actionOperationMap = {\n  findOne: 'query',\n  findFirst: 'query',\n  findMany: 'query',\n  count: 'query',\n  create: 'mutation',\n  update: 'mutation',\n  updateMany: 'mutation',\n  upsert: 'mutation',\n  delete: 'mutation',\n  deleteMany: 'mutation',\n  executeRaw: 'mutation',\n  queryRaw: 'mutation',\n  aggregate: 'query',\n}\n\nconst aggregateKeys = {\n  avg: true,\n  count: true,\n  sum: true,\n  min: true,\n  max: true,\n}\n\n// TODO: We **may** be able to get real types. However, we have both a bootstrapping\n// problem here, that we want to return a type that's not yet defined\n// and we're typecasting this anyway later\nexport function getPrismaClient(config: GetPrismaClientOptions): any {\n  class NewPrismaClient {\n    _dmmf: DMMFClass\n    _engine: NodeEngine\n    _fetcher: PrismaClientFetcher\n    _connectionPromise?: Promise<any>\n    _disconnectionPromise?: Promise<any>\n    _engineConfig: EngineConfig\n    private _errorFormat: ErrorFormat\n    private _hooks?: Hooks\n    private _getConfigPromise?: Promise<{\n      datasources: DataSource[]\n      generators: GeneratorConfig[]\n    }>\n    private _middlewares: Middleware[] = []\n    private _engineMiddlewares: EngineMiddleware[] = []\n    private _clientVersion: string\n    constructor(optionsArg?: PrismaClientOptions) {\n      this._clientVersion = config.clientVersion ?? clientVersion\n      try {\n        const options: PrismaClientOptions = optionsArg ?? {}\n        const internal = options.__internal ?? {}\n\n        const useDebug = internal.debug === true\n        if (useDebug) {\n          Debug.enable('prisma-client')\n        }\n\n        if (internal.hooks) {\n          this._hooks = internal.hooks\n        }\n\n        let predefinedDatasources = config.sqliteDatasourceOverrides ?? []\n        predefinedDatasources = predefinedDatasources.map((d) => ({\n          name: d.name,\n          url: 'file:' + path.resolve(config.dirname, d.url),\n        }))\n\n        const inputDatasources = Object.entries(options.datasources || {})\n          .filter(([_, source]) => {\n            return source && source.url\n          })\n          .map(([name, { url }]: any) => ({ name, url }))\n\n        const datasources = mergeBy(\n          predefinedDatasources,\n          inputDatasources,\n          (source) => source.name,\n        )\n\n        const engineConfig = internal.engine || {}\n\n        if (options.errorFormat) {\n          this._errorFormat = options.errorFormat\n        } else if (process.env.NODE_ENV === 'production') {\n          this._errorFormat = 'minimal'\n        } else if (process.env.NO_COLOR) {\n          this._errorFormat = 'colorless'\n        } else {\n          this._errorFormat = 'colorless' // default errorFormat\n        }\n\n        const envFile = this.readEnv()\n\n        this._dmmf = new DMMFClass(config.document)\n\n        let cwd = path.resolve(config.dirname, config.relativePath)\n\n        if (!fs.existsSync(cwd)) {\n          cwd = config.dirname\n        }\n\n        const previewFeatures = config.generator?.previewFeatures ?? []\n\n        this._engineConfig = {\n          cwd,\n          enableDebugLogs: useDebug,\n          enableEngineDebugMode: engineConfig.enableEngineDebugMode,\n          datamodelPath: path.join(config.dirname, 'schema.prisma'),\n          prismaPath: engineConfig.binaryPath ?? undefined,\n          engineEndpoint: engineConfig.endpoint,\n          datasources,\n          generator: config.generator,\n          showColors: this._errorFormat === 'pretty',\n          logLevel: options.log && (getLogLevel(options.log) as any), // TODO\n          logQueries:\n            options.log &&\n            Boolean(\n              typeof options.log === 'string'\n                ? options.log === 'query'\n                : options.log.find((o) =>\n                  typeof o === 'string' ? o === 'query' : o.level === 'query',\n                ),\n            ),\n          env: envFile,\n          flags: [],\n          clientVersion: config.clientVersion,\n          enableExperimental: mapPreviewFeatures(previewFeatures),\n          useUds: internal.useUds,\n        }\n\n        const sanitizedEngineConfig = omit(this._engineConfig, [\n          'env',\n          'datasources',\n        ])\n        debug({ engineConfig: sanitizedEngineConfig })\n\n        this._engine = new NodeEngine(this._engineConfig)\n        this._fetcher = new PrismaClientFetcher(this, false, this._hooks)\n\n        if (options.log) {\n          for (const log of options.log) {\n            const level =\n              typeof log === 'string'\n                ? log\n                : log.emit === 'stdout'\n                  ? log.level\n                  : null\n            if (level) {\n              this.$on(level, (event) => {\n                const colorMap = {\n                  query: 'blue',\n                  info: 'cyan',\n                  warn: 'yellow',\n                  error: 'red',\n                }\n                console.error(\n                  chalk[colorMap[level]](`prisma:${level}`.padEnd(13)) +\n                  (event.message || event.query),\n                )\n              })\n            }\n          }\n        }\n\n        this._bootstrapClient()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private readEnv() {\n      const dotEnvPath = path.resolve(\n        config.dirname,\n        config.relativePath,\n        '.env',\n      )\n      if (fs.existsSync(dotEnvPath)) {\n        return dotenvExpand(dotenv.config({ path: dotEnvPath })).parsed\n      }\n\n      return {}\n    }\n    use(...args) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.use() is deprecated, please use prisma.$use() instead`,\n      )\n      return (this.$use as any)(...args)\n    }\n    $use(cb: Middleware)\n    $use(namespace: 'all', cb: Middleware)\n    $use(namespace: 'engine', cb: EngineMiddleware)\n    $use(\n      namespace: HookPoint | Middleware,\n      cb?: Middleware | EngineMiddleware,\n    ) {\n      if (typeof namespace === 'function') {\n        this._middlewares.push(namespace)\n      } else if (typeof namespace === 'string') {\n        if (namespace === 'all') {\n          this._middlewares.push(cb! as Middleware)\n        } else if (namespace === 'engine') {\n          this._engineMiddlewares.push(cb! as EngineMiddleware)\n        } else {\n          throw new Error(`Unknown middleware hook ${namespace}`)\n        }\n      } else {\n        throw new Error(`Invalid middleware ${namespace}`)\n      }\n    }\n    on(eventType: any, callback: (event: any) => void) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.on() is deprecated, please use prisma.$on() instead`,\n      )\n      return this.$on(eventType, callback)\n    }\n    $on(eventType: any, callback: (event: any) => void) {\n      if (eventType === 'beforeExit') {\n        this._engine.on('beforeExit', callback)\n      } else {\n        this._engine.on(eventType, (event) => {\n          const fields = event.fields\n          if (eventType === 'query') {\n            return callback({\n              timestamp: event.timestamp,\n              query: fields.query,\n              params: fields.params,\n              duration: fields.duration_ms,\n              target: event.target,\n            })\n          } else {\n            // warn, info, or error events\n            return callback({\n              timestamp: event.timestamp,\n              message: fields.message,\n              target: event.target,\n            })\n          }\n        })\n      }\n    }\n    connect() {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.connect() is deprecated, please use prisma.$connect() instead`,\n      )\n      return this.$connect()\n    }\n    async $connect() {\n      try {\n        return this._engine.start()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n    /**\n     * @private\n     */\n    async _runDisconnect() {\n      await this._engine.stop()\n      delete this._connectionPromise\n      this._engine = new NodeEngine(this._engineConfig)\n      delete this._disconnectionPromise\n      delete this._getConfigPromise\n    }\n    disconnect() {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.disconnect() is deprecated, please use prisma.$disconnect() instead`,\n      )\n      return this.$disconnect()\n    }\n    /**\n     * Disconnect from the database\n     */\n    async $disconnect() {\n      try {\n        return this._engine.stop()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private async _getActiveProvider(): Promise<ConnectorType> {\n      const configResult = await this._engine.getConfig()\n      return configResult.datasources[0].activeProvider!\n    }\n\n    executeRaw(stringOrTemplateStringsArray, ...values) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.executeRaw() is deprecated, please use prisma.$executeRaw() instead`,\n      )\n      return this.$executeRaw(stringOrTemplateStringsArray, ...values)\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    private async $executeRawInternal(stringOrTemplateStringsArray, ...values) {\n      let query = ''\n      let parameters: any = undefined\n\n      const activeProvider = await this._getActiveProvider()\n\n      if (typeof stringOrTemplateStringsArray === 'string') {\n        // If this was called as prisma.$executeRaw(<SQL>, [...values]), assume it is a pre-prepared SQL statement, and forward it without any changes\n        query = stringOrTemplateStringsArray\n        parameters = {\n          values: serializeRawParameters(values || []),\n          __prismaRawParamaters__: true,\n        }\n      } else if (Array.isArray(stringOrTemplateStringsArray)) {\n        // If this was called as prisma.$executeRaw`<SQL>`, try to generate a SQL prepared statement\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.sql\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'postgresql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.text\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'sqlserver': {\n            query = mssqlPreparedStatement(stringOrTemplateStringsArray)\n            parameters = {\n              values: serializeRawParameters(values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n        }\n      } else {\n        // If this was called as prisma.raw(sql`<SQL>`), use prepared statements from sql-template-tag\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).sql\n            break\n          case 'postgresql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).text\n            break\n          case 'sqlserver':\n            query = mssqlPreparedStatement(\n              (stringOrTemplateStringsArray as sqlTemplateTag.Sql).strings,\n            )\n            break\n        }\n        parameters = {\n          values: serializeRawParameters(\n            (stringOrTemplateStringsArray as sqlTemplateTag.Sql).values,\n          ),\n          __prismaRawParamaters__: true,\n        }\n      }\n\n      if (parameters?.values) {\n        debug(`prisma.$executeRaw(${query}, ${parameters.values})`)\n      } else {\n        debug(`prisma.$executeRaw(${query})`)\n      }\n\n      const args = { query, parameters }\n\n      debug(`Prisma Client call:`)\n      return this._request({\n        args,\n        clientMethod: 'executeRaw',\n        dataPath: [],\n        action: 'executeRaw',\n        callsite: this._getCallsite(),\n        runInTransaction: false,\n      })\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    $executeRaw(stringOrTemplateStringsArray, ...values) {\n      try {\n        const promise = this.$executeRawInternal(stringOrTemplateStringsArray, ...values)\n          ; (promise as any).isExecuteRaw = true\n        return promise\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _getCallsite() {\n      if (this._errorFormat !== 'minimal') {\n        return new Error().stack\n      }\n      return undefined\n    }\n\n    queryRaw(stringOrTemplateStringsArray, ...args) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.queryRaw() is deprecated, please use prisma.$queryRaw() instead`,\n      )\n      return this.$queryRaw(stringOrTemplateStringsArray, ...args)\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    private async $queryRawInternal(\n      stringOrTemplateStringsArray:\n        | string\n        | TemplateStringsArray\n        | sqlTemplateTag.Sql,\n      ...values: any[]\n    ) {\n      let query = ''\n      let parameters: any = undefined\n\n      const activeProvider = await this._getActiveProvider()\n\n      if (typeof stringOrTemplateStringsArray === 'string') {\n        // If this was called as prisma.$queryRaw(<SQL>, [...values]), assume it is a pre-prepared SQL statement, and forward it without any changes\n        query = stringOrTemplateStringsArray\n        parameters = {\n          values: serializeRawParameters(values || []),\n          __prismaRawParamaters__: true,\n        }\n      } else if (Array.isArray(stringOrTemplateStringsArray)) {\n        // If this was called as prisma.$queryRaw`<SQL>`, try to generate a SQL prepared statement\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.sql\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'postgresql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.text\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'sqlserver': {\n            query = mssqlPreparedStatement(stringOrTemplateStringsArray)\n            parameters = {\n              values: serializeRawParameters(values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n        }\n      } else {\n        // If this was called as prisma.raw(sql`<SQL>`), use prepared statements from sql-template-tag\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).sql\n            break\n          case 'postgresql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).text\n            break\n          case 'sqlserver':\n            query = mssqlPreparedStatement(\n              (stringOrTemplateStringsArray as sqlTemplateTag.Sql).strings,\n            )\n            break\n        }\n        parameters = {\n          values: serializeRawParameters(\n            (stringOrTemplateStringsArray as sqlTemplateTag.Sql).values,\n          ),\n          __prismaRawParamaters__: true,\n        }\n      }\n\n      if (parameters?.values) {\n        debug(`prisma.queryRaw(${query}, ${parameters.values})`)\n      } else {\n        debug(`prisma.queryRaw(${query})`)\n      }\n\n      const args = { query, parameters }\n\n      debug(`Prisma Client call:`)\n      return this._request({\n        args,\n        clientMethod: 'queryRaw',\n        dataPath: [],\n        action: 'queryRaw',\n        callsite: this._getCallsite(),\n        runInTransaction: false,\n      })\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    $queryRaw(stringOrTemplateStringsArray, ...values) {\n      try {\n        const promise = this.$queryRawInternal(stringOrTemplateStringsArray, ...values)\n          ; (promise as any).isQueryRaw = true\n        return promise\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    async __internal_triggerPanic(fatal: boolean) {\n      if (!this._engineConfig.enableEngineDebugMode) {\n        throw new Error(`In order to use .__internal_triggerPanic(), please enable the debug mode like so:\nnew PrismaClient({\n  __internal: {\n    engine: {\n      enableEngineDebugMode: true\n    }\n  }\n})`)\n      }\n\n      const query = 'SELECT 1'\n\n      const headers: Record<string, string> = fatal\n        ? { 'X-DEBUG-FATAL': '1' }\n        : { 'X-DEBUG-NON-FATAL': '1' }\n\n      return this._request({\n        action: 'queryRaw',\n        args: {\n          query,\n          parameters: undefined,\n        },\n        clientMethod: 'queryRaw',\n        dataPath: [],\n        runInTransaction: false,\n        headers,\n        callsite: this._getCallsite(),\n      })\n    }\n\n    transaction(promises) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.transaction() is deprecated, please use prisma.$transaction() instead`,\n      )\n      return this.$transaction(promises)\n    }\n\n    private async $transactionInternal(promises: Array<any>): Promise<any> {\n      if (config.generator?.previewFeatures?.includes('transactionApi')) {\n        for (const p of promises) {\n          if (!p) {\n            throw new Error(\n              `All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`,\n            )\n          }\n          if (p?.isQueryRaw) {\n            throw new Error(`$queryRaw is not yet supported within $transaction.\nPlease report in https://github.com/prisma/prisma/issues/3828 if you need this feature.`)\n          }\n          if (p?.isExecuteRaw) {\n            throw new Error(`$executeRaw is not yet supported within $transaction.\nPlease report in https://github.com/prisma/prisma/issues/3828 if you need this feature`)\n          }\n          if (\n            !p.requestTransaction ||\n            typeof p.requestTransaction !== 'function'\n          ) {\n            throw new Error(\n              `All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`,\n            )\n          }\n        }\n        return Promise.all(promises.map((p) => p.requestTransaction()))\n      } else {\n        throw new Error(\n          `In order to use the .transaction() api, please enable 'previewFeatures = \"transactionApi\" in your schema.`,\n        )\n      }\n    }\n\n    async $transaction(promises: Array<any>): Promise<any> {\n      try {\n        return this.$transactionInternal(promises)\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _request(internalParams: InternalRequestParams) {\n      try {\n        const resource = new AsyncResource('prisma-client-request')\n        if (this._middlewares.length > 0) {\n          // https://perf.link/#eyJpZCI6Img4bmd0anp5eGxrIiwidGl0bGUiOiJGaW5kaW5nIG51bWJlcnMgaW4gYW4gYXJyYXkgb2YgMTAwMCIsImJlZm9yZSI6ImNvbnN0IGRhdGEgPSB7XG4gIG9wZXJhdGlvbjogXCJxdWVyeVwiLFxuICByb290RmllbGQ6IFwiZmluZE1hbnlVc2VyXCIsXG4gIGFyZ3M6IHtcbiAgICB3aGVyZTogeyBpZDogeyBndDogNSB9IH1cbiAgfSxcbiAgZGF0YVBhdGg6IFtdLFxuICBjbGllbnRNZXRob2Q6ICd1c2VyLmZpbmRNYW55J1xufSIsInRlc3RzIjpbeyJuYW1lIjoiZm9yIGluIiwiY29kZSI6ImNvbnN0IG5ld0RhdGEgPSB7fVxuZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICBpZiAoa2V5ICE9PSAnY2xpZW50TWV0aG9kJykge1xuICAgIG5ld0RhdGFba2V5XSA9IGRhdGFba2V5XVxuICB9XG59IiwicnVucyI6WzU1MzAwMCw0OTAwMDAsMzQ0MDAwLDYyNDAwMCwxMzkxMDAwLDEyMjQwMDAsMTA2NDAwMCwxMjE3MDAwLDc0MDAwLDM3MzAwMCw5MDUwMDAsNTM3MDAwLDE3MDYwMDAsOTAzMDAwLDE0MjUwMDAsMTMxMjAwMCw3NjkwMDAsMTM0NTAwMCwxOTQ4MDAwLDk5MDAwMCw5MDAwMDAsMTM0ODAwMCwxMDk2MDAwLDM4NjAwMCwxNTE3MDAwLDE5MzYwMDAsMTAwMCwyMTM0MDAwLDEzMjgwMDAsODI5MDAwLDE1ODYwMDAsMTc2MzAwMCw1MDgwMDAsOTg2MDAwLDE5NDkwMDAsMjEwODAwMCwxNjA4MDAwLDIyNDAwMCwxOTAyMDAwLDEyNjgwMDAsMjEzNDAwMCwxNzEwMDAwLDEzNzIwMDAsMjExMDAwMCwxNzgwMDAwLDc3NzAwMCw1NzgwMDAsNDAwMCw4OTAwMDAsMTEwMTAwMCwxNTk0MDAwLDE3ODAwMDAsMzU0MDAwLDU0NDAwMCw4MjQwMDAsNzEwMDAwLDg0OTAwMCwxNjQwMDAwLDE5ODQwMDAsNzAzMDAwLDg4MjAwMCw4NTAwMDAsMTA2MDAwLDMwMzAwMCwxMzMwMDAsNjA4MDAwLDIxMzQwMDAsNTUxMDAwLDc0MjAwMCwyMDcwMDAsMTU3NTAwMCwxMzQwMDAsNDAwMCwxMDAwLDQ5NDAwMCwyNTAwMDAsMTQwMjAwMCw2OTgwMDAsNTgxMDAwLDQ4MDAwMCwyMDMwMDAsMTY4MzAwMCwxNjcxMDAwLDEyNDAwMDAsMTk1NjAwMCwzMDUwMDAsODkwMDAsNjUzMDAwLDE3MDgwMDAsMTYwMTAwMCwxOTg0MDAwLDg4ODAwMCwyMTAwMDAwLDE5NzUwMDAsNTM2MDAwLDU3NTAwMCwyMTM0MDAwLDEwMTcwMDAsMTI5NzAwMCw3NTYwMDBdLCJvcHMiOjEwNDUxNTB9LHsibmFtZSI6IkRlY29uc3RydWN0b3IiLCJjb2RlIjoiY29uc3QgeyBjbGllbnRNZXRob2QsIC4uLnJlc3QgfSA9IGRhdGEiLCJydW5zIjpbMjE0MDAwLDUxMDAwLDg2NDAwMCw3MjcwMDAsNDMxMDAwLDIyMDAwMCwzOTAwMDAsODQxMDAwLDIyOTAwMCw3MjIwMDAsNDEzMDAwLDYwODAwMCwyOTgwMDAsMzY4MDAwLDg2NDAwMCw5MjQwMDAsMTI4MDAwLDU1MzAwMCw4ODAwMDAsNTQ1MDAwLDc3NTAwMCw0MzAwMDAsMjM3MDAwLDc4NjAwMCw1NTUwMDAsNTI2MDAwLDMyNzAwMCw2MzAwMCw5MTIwMDAsMTgxMDAwLDMzMTAwMCw0MzAwMCwyMjUwMDAsNTQ3MDAwLDgyMjAwMCw3OTMwMDAsMTA1NzAwMCw1NjAwMCwyNzUwMDAsMzkzMDAwLDgwNTAwMCw5MzAwMCw3NjYwMDAsODM0MDAwLDUwMzAwMCw4MDAwMCwyMzgwMDAsNDY0MDAwLDU2NDAwMCw3MzAwMDAsOTU1MDAwLDgwOTAwMCwyMDMwMDAsNDEzMDAwLDM0NDAwMCw1MDIwMDAsNjEzMDAwLDEwMDAwMCw0MzIwMDAsNjcwMDAwLDQ1MzAwMCw4OTEwMDAsNTUwMDAsMjMwMDAwLDM5MTAwMCw3NTQwMDAsMTEyMjAwMCw3NjIwMDAsMzU3MDAwLDQ3MDAwLDc5MjAwMCwzNTQwMDAsMTA4MDAwMCwxNjAwMCwxODgwMDAsMTQxMDAwLDIxMDAwMCw2MDcwMDAsOTAyMDAwLDgyNTAwMCwxOTAwMDAsMjMzMDAwLDI4MzAwMCwyMzgwMDAsNjk2MDAwLDc2ODAwMCw3NTgwMDAsMTk0MDAwLDI3OTAwMCwyMjMwMDAsMjM4MDAwLDkzNDAwMCw2MDUwMDAsMTcwMDAsMjEwMDAwLDMyMjAwMCwxMDM0MDAwLDgxMjAwMCw0NDYwMDAsNjMxMDAwXSwib3BzIjo0OTAxMDB9LHsibmFtZSI6ImRlbGV0ZSIsImNvZGUiOiJjb25zdCB7IGNsaWVudE1ldGhvZCB9ID0gZGF0YVxuZGVsZXRlIGRhdGEuY2xpZW50TWV0aG9kIiwicnVucyI6WzI3NjIwMDAsNjIyMDAwLDEwNTcwMDAsMzIzMTAwMCwzNDQ2MDAwLDIwNzMwMDAsMzM4MjAwMCwyNzA0MDAwLDM4ODEwMDAsMTIwMTAwMCwzNzk3MDAwLDI1OTAwMCwxMDI4MDAwLDI1MTgwMDAsMjEwMjAwMCwxOTczMDAwLDM0MTIwMDAsMzU4MDAwLDExNDcwMDAsMTA3NDAwMCwzMTk1MDAwLDM2NzUwMDAsNTQ3MDAwLDIwNzkwMDAsMjc0NTAwMCwyNDE1MDAwLDIxOTAwMCwzNzM3MDAwLDM2OTIwMDAsMTY0MDAwLDI0MzMwMDAsNjQzMDAwLDcxODAwMCw0Mzg2MDAwLDE3MDIwMDAsMTAyNDAwMCw1NjUwMDAsNDIxOTAwMCwxMTk3MDAwLDE4MzkwMDAsMzgyMTAwMCwxMTUyMDAwLDg1MzAwMCwxMzczMDAwLDI5NTAwMCwxNDg5MDAwLDE0MjEwMDAsMjcyNDAwMCw1MDYxMDAwLDI2NTcwMDAsMjYzNzAwMCwyOTkwMDAsMjE1NzAwMCwxNTAxMDAwLDM2OTAwMDAsMzU3OTAwMCw0MjE5MDAwLDI4NTgwMDAsNTI0MzAwMCwxNTA0MDAwLDEyMTMwMDAsMjM4NDAwMCw3NzgwMDAsMjgyNjAwMCwxNzQ5MDAwLDM2MjAwMCwyNzEzMDAwLDMzODYwMDAsMzE2NjAwMCwxNTMwMDAsNzk0MDAwLDMyMTcwMDAsMjA4MjAwMCw0MTUwMDAsMzMyMDAwMCwyMTA1MDAwLDE1NzYwMDAsMjUxMDAwLDIzMjkwMDAsOTI1MDAwLDM3MTUwMDAsNjkyMDAwLDE5MDIwMDAsMjA0NzAwMCwyNTM5MDAwLDIwMjkwMDAsMzE3OTAwMCwyMTA2MDAwLDg5NTAwMCwxNTUwMDAwLDYwNzAwMCw0MTA1MDAwLDM0ODMwMDAsMzcxNTAwMCw0OTQwMDAwLDIyODAwMCw0MDI2MDAwLDE2MTYwMDAsMzMxNDAwMCwyNDIyMDAwXSwib3BzIjoyMTY2MDgwfSx7Im5hbWUiOiJDcmVhdGUgbmV3IG9iamVjdCIsImNvZGUiOiJjb25zdCBuZXdEYXRhID0ge1xuICBvcGVyYXRpb246IGRhdGEub3BlcmF0aW9uLFxuICByb290RmllbGQ6IGRhdGEucm9vdEZpZWxkLFxuICBhcmdzOiBkYXRhLmFyZ3MsXG4gIGRhdGFQYXRoOiBkYXRhLmRhdGFQYXRoXG59IiwicnVucyI6WzcwNTAwMCwxMTAwMDAsMzI3NTAwMCwxOTgwMDAsMjE5OTAwMCw0MzYwMDAsODI4MDAwLDI5MjcwMDAsNzI0MDAwLDI1NDAwMCwyOTgzMDAwLDI2NzIwMDAsMjUzMDAwLDI4MjcwMDAsMzA0ODAwMCwyOTA3MDAwLDM0OTkwMDAsMjY1OTAwMCwzODIyMDAwLDI3NzcwMDAsMzc5NzAwMCw4MDAwMDAsNDM1MDAwLDExOTMwMDAsMTAwMDAsMTQ0MDAwMCw3NTcwMDAsMTMyMDAwMCwzMjIwMDAsMjA3MDAwLDM2ODAwMDAsMzkxMTAwMCwzMjQxMDAwLDExMDcwMDAsNDM4MDAwLDMwNDQwMDAsMTA3NjAwMCwyMTAwMDAsNDIxOTAwMCwzNzQ4MDAwLDQwNjcwMDAsNzc0MDAwLDYzMDAwLDMyMTAwMCwzMDQ4MDAwLDMxMjgwMDAsMTg3MTAwMCwzNTkxMDAwLDI0MzcwMDAsNjcxMDAwLDc5OTAwMCwxMTUzMDAwLDIxMTMwMDAsOTUwMDAsNTg3MDAwLDYyMzAwMCwxMzEzMDAwLDMxNTgwMDAsMzMyNzAwMCwxNTkwMDAsNDg4MDAwLDIxMTAwMCwxMjk0MDAwLDExNTcwMDAsNDA0MDAwLDM2MjMwMDAsMjY4NDAwMCw4NzkwMDAsMjE4NTAwMCwxNTkyMDAwLDM2ODcwMDAsMjI0ODAwMCwyMjE4MDAwLDE3NDMwMDAsNzg4MDAwLDQwODYwMDAsMjExNTAwMCwzOTE0MDAwLDM5MjgwMDAsNDM3MjAwMCwxOTkwMDAsMzc1MzAwMCwzNjQ3MDAwLDE2MjcwMDAsMTQ5OTAwMCwxODQyMDAwLDIxMjkwMDAsNDAwMCwxMjIzMDAwLDI4NjMwMDAsMzgzNDAwMCwzNjk0MDAwLDYzNjAwMCw0MjQ3MDAwLDQwMjIwMDAsMTAwMDAsMTcxNDAwMCwxNzUwMDAwLDI5MDEwMDAsMTM0NjAwMF0sIm9wcyI6MTkzOTEyMH1dLCJ1cGRhdGVkIjoiMjAyMC0wNy0xNVQxMTowMDo1Ny45MzhaIn0%3D\n          const params: MiddlewareParams = {\n            args: internalParams.args,\n            dataPath: internalParams.dataPath,\n            runInTransaction: internalParams.runInTransaction,\n            action: internalParams.action,\n            model: internalParams.model,\n          }\n          return resource.runInAsyncScope(() =>\n            this._requestWithMiddlewares(\n              params,\n              this._middlewares.slice(),\n              internalParams.clientMethod,\n              internalParams.callsite,\n              internalParams.headers,\n            ),\n          )\n        }\n\n        return resource.runInAsyncScope(() =>\n          this._executeRequest(internalParams),\n        )\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _requestWithMiddlewares(\n      params: MiddlewareParams,\n      middlewares: Middleware[],\n      clientMethod: string,\n      callsite?: string,\n      headers?: Record<string, string>,\n    ) {\n      const middleware = middlewares.shift()\n      if (middleware) {\n        return middleware(params, (params2) =>\n          this._requestWithMiddlewares(\n            params2,\n            middlewares,\n            clientMethod,\n            callsite,\n          ),\n        )\n      }\n\n      // No, we won't copy the whole object here just to make it easier to do TypeScript\n      // as it would be much slower\n      ; (params as InternalRequestParams).clientMethod = clientMethod\n        ; (params as InternalRequestParams).callsite = callsite\n        ; (params as InternalRequestParams).headers = headers\n\n      return this._executeRequest(params as InternalRequestParams)\n    }\n\n    private _executeRequest({\n      args,\n      clientMethod,\n      dataPath,\n      callsite,\n      runInTransaction,\n      action,\n      model,\n      headers,\n    }: InternalRequestParams) {\n      if (action !== 'executeRaw' && action !== 'queryRaw' && !model) {\n        throw new Error(`Model missing for action ${action}`)\n      }\n\n      if ((action === 'executeRaw' || action === 'queryRaw') && model) {\n        throw new Error(\n          `executeRaw and queryRaw can't be executed on a model basis. The model ${model} has been provided`,\n        )\n      }\n\n      let rootField: string | undefined\n      const operation = actionOperationMap[action]\n\n      if (action === 'executeRaw' || action === 'queryRaw') {\n        rootField = action\n      }\n\n      // TODO: Replace with lookup map for speedup\n      let mapping\n      if (model) {\n        mapping = this._dmmf.mappingsMap[model]\n        if (!mapping) {\n          throw new Error(`Could not find mapping for model ${model}`)\n        }\n\n        rootField = mapping[action]\n      }\n\n      if (operation !== 'query' && operation !== 'mutation') {\n        throw new Error(`Invalid operation ${operation} for action ${action}`)\n      }\n\n      const field = this._dmmf.rootFieldMap[rootField!]\n\n      if (!field) {\n        throw new Error(\n          `Could not find rootField ${rootField} for action ${action} for model ${model} on rootType ${operation}`,\n        )\n      }\n\n      const { isList } = field.outputType\n      const typeName = getOutputTypeName(field.outputType.type)\n\n      let document = makeDocument({\n        dmmf: this._dmmf,\n        rootField: rootField!,\n        rootTypeName: operation,\n        select: args,\n      })\n\n      document.validate(args, false, clientMethod, this._errorFormat, callsite)\n\n      document = transformDocument(document)\n\n      // as printJsonWithErrors takes a bit of compute\n      // we only want to do it, if debug is enabled for 'prisma-client'\n      if (Debug.enabled('prisma-client')) {\n        const query = String(document)\n        debug(`Prisma Client call:`)\n        debug(\n          `prisma.${clientMethod}(${printJsonWithErrors({\n            ast: args,\n            keyPaths: [],\n            valuePaths: [],\n            missingItems: [],\n          })})`,\n        )\n        debug(`Generated request:`)\n        debug(query + '\\n')\n      }\n\n      return this._fetcher.request({\n        document,\n        clientMethod,\n        typeName,\n        dataPath,\n        isList,\n        rootField: rootField!,\n        callsite,\n        showColors: this._errorFormat === 'pretty',\n        args,\n        engineHook: this._engineMiddlewares[0],\n        runInTransaction,\n        headers,\n      })\n    }\n\n    private _bootstrapClient() {\n      const clients = this._dmmf.mappings.reduce((acc, mapping) => {\n        const lowerCaseModel = lowerCase(mapping.model)\n        const model = this._dmmf.modelMap[mapping.model]\n\n        if (!model) {\n          throw new Error(`Invalid mapping ${mapping.model}, can't find model`)\n        }\n\n        const prismaClient = ({\n          operation,\n          actionName,\n          args,\n          dataPath,\n          modelName,\n        }) => {\n          dataPath = dataPath ?? []\n\n          const clientMethod = `${lowerCaseModel}.${actionName}`\n\n          let requestPromise: Promise<any>\n          const callsite = this._getCallsite()\n\n          const requestModelName = modelName ?? model.name\n\n          const clientImplementation = {\n            then: (onfulfilled, onrejected) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.then(onfulfilled, onrejected)\n            },\n            requestTransaction: () => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: true,\n                })\n              }\n\n              return requestPromise\n            },\n            catch: (onrejected) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.catch(onrejected)\n            },\n            finally: (onfinally) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.finally(onfinally)\n            },\n          }\n\n          // add relation fields\n          for (const field of model.fields.filter((f) => f.kind === 'object')) {\n            clientImplementation[field.name] = (fieldArgs) => {\n              const prefix = dataPath.includes('select')\n                ? 'select'\n                : dataPath.includes('include')\n                  ? 'include'\n                  : 'select'\n              const newDataPath = [...dataPath, prefix, field.name]\n              const newArgs = deepSet(args, newDataPath, fieldArgs || true)\n\n              return clients[field.type]({\n                operation,\n                actionName,\n                args: newArgs,\n                dataPath: newDataPath,\n                isList: field.isList,\n                /*\n                 * necessary for user.posts() calls -> the original model name needs to be preserved\n                 */\n                modelName: modelName || model.name,\n              })\n            }\n          }\n\n          return clientImplementation\n        }\n\n        acc[model.name] = prismaClient\n\n        return acc\n      }, {})\n\n      for (const mapping of this._dmmf.mappings) {\n        const lowerCaseModel = lowerCase(mapping.model)\n\n        const denyList = {\n          model: true,\n          plural: true,\n          aggregate: true,\n        }\n\n        const delegate: any = Object.entries(mapping).reduce(\n          (acc, [actionName, rootField]) => {\n            if (!denyList[actionName]) {\n              const operation = getOperation(actionName as any)\n              acc[actionName] = (args) =>\n                clients[mapping.model]({\n                  operation,\n                  actionName,\n                  args,\n                })\n            }\n\n            return acc\n          },\n          {},\n        )\n\n        delegate.count = (args) => {\n          return clients[mapping.model]({\n            operation: 'query',\n            actionName: `aggregate`,\n            args: args\n              ? {\n                ...args,\n                select: { count: true },\n              }\n              : undefined,\n            dataPath: ['count'],\n          })\n        }\n\n        delegate.aggregate = (args) => {\n          /**\n           * avg, count, sum, min, max need to go into select\n           * For speed reasons we can go with \"for in \"\n           */\n          const select = Object.entries(args).reduce((acc, [key, value]) => {\n            if (aggregateKeys[key]) {\n              if (!acc.select) {\n                acc.select = {}\n              }\n              // `count` doesn't have a sub-selection\n              if (key === 'count') {\n                acc.select[key] = value\n              } else {\n                acc.select[key] = { select: value }\n              }\n            } else {\n              acc[key] = value\n            }\n            return acc\n          }, {} as any)\n\n          return clients[mapping.model]({\n            operation: 'query',\n            actionName: 'aggregate', // actionName is just cosmetics \uD83D\uDC85\uD83C\uDFFD\n            rootField: mapping.aggregate,\n            args: select,\n            dataPath: [],\n          })\n        }\n\n        this[lowerCaseModel] = delegate\n      }\n    }\n  }\n\n  return NewPrismaClient\n}\n\nexport class PrismaClientFetcher {\n  prisma: any\n  debug: boolean\n  hooks: any\n  dataloader: Dataloader<{\n    document: Document\n    runInTransaction?: boolean\n    headers?: Record<string, string>\n  }>\n\n  constructor(prisma, enableDebug = false, hooks?: any) {\n    this.prisma = prisma\n    this.debug = enableDebug\n    this.hooks = hooks\n    this.dataloader = new Dataloader({\n      batchLoader: async (requests) => {\n        const queries = requests.map((r) => String(r.document))\n        const runTransaction = requests[0].runInTransaction\n        return this.prisma._engine.requestBatch(queries, runTransaction)\n      },\n      singleLoader: async (request) => {\n        const query = String(request.document)\n        return this.prisma._engine.request(query, request.headers)\n      },\n      batchBy: (request) => {\n        if (request.runInTransaction) {\n          return 'transaction-batch'\n        }\n\n        if (!request.document.children[0].name.startsWith('findOne')) {\n          return null\n        }\n\n        const selectionSet = request.document.children[0].children!.join(',')\n\n        const args = request.document.children[0].args?.args\n          .map((a) => {\n            if (a.value instanceof Args) {\n              return a.key + '-' + a.value.args.map((a) => a.key).join(',')\n            }\n            return a.key\n          })\n          .join(',')\n\n        return `${request.document.children[0].name}|${args}|${selectionSet}`\n      },\n    })\n  }\n\n  async request({\n    document,\n    dataPath = [],\n    rootField,\n    typeName,\n    isList,\n    callsite,\n    clientMethod,\n    runInTransaction,\n    showColors,\n    engineHook,\n    args,\n    headers,\n  }: {\n    document: Document\n    dataPath: string[]\n    rootField: string\n    typeName: string\n    isList: boolean\n    clientMethod: string\n    callsite?: string\n    runInTransaction?: boolean\n    showColors?: boolean\n    engineHook?: EngineMiddleware\n    args: any\n    headers?: Record<string, string>\n  }) {\n    if (this.hooks && this.hooks.beforeRequest) {\n      const query = String(document)\n      this.hooks.beforeRequest({\n        query,\n        path: dataPath,\n        rootField,\n        typeName,\n        document,\n        isList,\n        clientMethod,\n        args,\n      })\n    }\n    try {\n      /**\n       * If there's an engine hook, use it here\n       */\n      let data, elapsed\n      if (engineHook) {\n        const result = await engineHook(\n          {\n            document,\n            runInTransaction,\n          },\n          (params) => this.dataloader.request(params),\n        )\n        data = result.data\n        elapsed = result.elapsed\n      } else {\n        const result = await this.dataloader.request({\n          document,\n          runInTransaction,\n          headers,\n        })\n        data = result.data\n        elapsed = result.elapsed\n      }\n\n      /**\n       * Unpack\n       */\n      const unpackResult = this.unpack(document, data, dataPath, rootField)\n      if (process.env.PRISMA_CLIENT_GET_TIME) {\n        return { data: unpackResult, elapsed }\n      }\n      return unpackResult\n    } catch (e) {\n      debug(e)\n      let message = e.message\n      if (callsite) {\n        const { stack } = printStack({\n          callsite,\n          originalMethod: clientMethod,\n          onUs: e.isPanic,\n          showColors,\n        })\n        message = stack + '\\n  ' + e.message\n      }\n\n      message = this.sanitizeMessage(message)\n      // TODO: Do request with callsite instead, so we don't need to rethrow\n      if (e.code) {\n        throw new PrismaClientKnownRequestError(\n          message,\n          e.code,\n          this.prisma._clientVersion,\n          e.meta,\n        )\n      } else if (e.isPanic) {\n        throw new PrismaClientRustPanicError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientUnknownRequestError) {\n        throw new PrismaClientUnknownRequestError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientInitializationError) {\n        throw new PrismaClientInitializationError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientRustPanicError) {\n        throw new PrismaClientRustPanicError(\n          message,\n          this.prisma._clientVersion,\n        )\n      }\n\n      e.clientVersion = this.prisma._clientVersion\n\n      throw e\n    }\n  }\n\n  sanitizeMessage(message) {\n    if (this.prisma._errorFormat && this.prisma._errorFormat !== 'pretty') {\n      return stripAnsi(message)\n    }\n    return message\n  }\n  unpack(document, data, path, rootField) {\n    if (data.data) {\n      data = data.data\n    }\n    const getPath: any[] = []\n    if (rootField) {\n      getPath.push(rootField)\n    }\n    getPath.push(...path.filter((p) => p !== 'select' && p !== 'include'))\n    return unpack({ document, data, path: getPath })\n  }\n}\n\nexport function getOperation(action: DMMF.ModelAction): 'query' | 'mutation' {\n  if (\n    action === DMMF.ModelAction.findMany ||\n    action === DMMF.ModelAction.findOne ||\n    action === DMMF.ModelAction.findFirst\n  ) {\n    return 'query'\n  }\n  return 'mutation'\n}\n", "import { DMMFClass } from './dmmf'\nimport { DMMF } from './dmmf-types'\nimport path from 'path'\nimport {\n  PrismaClientKnownRequestError,\n  PrismaClientUnknownRequestError,\n  PrismaClientInitializationError,\n  PrismaClientRustPanicError,\n} from '.'\nimport {\n  NodeEngine,\n  EngineConfig,\n  DatasourceOverwrite,\n} from '@prisma/engine-core/dist/NodeEngine'\nimport {\n  Document,\n  makeDocument,\n  unpack,\n  transformDocument,\n  Args,\n} from './query'\nimport Debug from '@prisma/debug'\nconst debug = Debug('prisma-client')\nimport fs from 'fs'\nimport chalk from 'chalk'\nimport * as sqlTemplateTag from 'sql-template-tag'\nimport dotenv from 'dotenv'\nimport { dotenvExpand } from '@prisma/sdk/dist/dotenvExpand'\nimport {\n  GeneratorConfig,\n  DataSource,\n} from '@prisma/generator-helper/dist/types'\nimport { getLogLevel } from './getLogLevel'\nimport { mergeBy } from './mergeBy'\nimport { lowerCase, getOutputTypeName } from './utils/common'\nimport { deepSet } from './utils/deep-set'\nimport { Dataloader } from './Dataloader'\nimport { printStack } from './utils/printStack'\nimport stripAnsi from 'strip-ansi'\nimport { printJsonWithErrors } from './utils/printJsonErrors'\nimport { ConnectorType } from './utils/printDatasources'\nimport { omit } from './utils/omit'\nimport { mapPreviewFeatures } from '@prisma/sdk/dist/utils/mapPreviewFeatures'\nimport { serializeRawParameters } from './utils/serializeRawParameters'\nimport { AsyncResource } from 'async_hooks'\nimport { clientVersion } from './utils/clientVersion'\nimport { mssqlPreparedStatement } from './utils/mssqlPreparedStatement'\n\nexport type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n\nexport type Datasource = {\n  url?: string\n}\nexport type Datasources = Record<string, Datasource>\n\nexport interface PrismaClientOptions {\n  /**\n   * Overwrites the datasource url from your prisma.schema file\n   */\n  datasources?: Datasources\n\n  /**\n   * @default \"colorless\"\n   */\n  errorFormat?: ErrorFormat\n\n  /**\n   * @example\n   * \\`\\`\\`\n   * // Defaults to stdout\n   * log: ['query', 'info', 'warn']\n   *\n   * // Emit as events\n   * log: [\n   *  { emit: 'stdout', level: 'query' },\n   *  { emit: 'stdout', level: 'info' },\n   *  { emit: 'stdout', level: 'warn' }\n   * ]\n   * \\`\\`\\`\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n   */\n  log?: Array<LogLevel | LogDefinition>\n\n  /**\n   * @internal\n   * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\n   */\n  __internal?: {\n    debug?: boolean\n    hooks?: Hooks\n    useUds?: boolean\n    engine?: {\n      cwd?: string\n      binaryPath?: string\n      endpoint?: string\n      enableEngineDebugMode?: boolean\n    }\n  }\n}\n\nexport type HookParams = {\n  query: string\n  path: string[]\n  rootField?: string\n  typeName?: string\n  document: any\n  clientMethod: string\n  args: any\n}\n\n/**\n * These options are being passed in to the middleware as \"params\"\n */\nexport type MiddlewareParams = {\n  model?: string\n  action: Action\n  args: any\n  dataPath: string[]\n  runInTransaction: boolean\n}\n\n/**\n * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation\n */\nexport type Middleware<T = any> = (\n  params: MiddlewareParams,\n  next: (params: MiddlewareParams) => Promise<T>,\n) => Promise<T>\n\nexport interface InternalRequestParams extends MiddlewareParams {\n  /**\n   * The original client method being called.\n   * Even though the rootField / operation can be changed,\n   * this method stays as it is, as it's what the user's\n   * code looks like\n   */\n  clientMethod: string\n  callsite?: string\n  headers?: Record<string, string>\n}\n\nexport type HookPoint = 'all' | 'engine'\n\nexport type EngineMiddlewareParams = {\n  document: Document\n  runInTransaction?: boolean\n}\n\n// only used by the .use() hooks\nexport type AllHookArgs = {\n  params: HookParams\n  fetch: (params: HookParams) => Promise<any>\n}\n/**\n * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation\n */\nexport type EngineMiddleware<T = any> = (\n  params: EngineMiddlewareParams,\n  next: (params: EngineMiddlewareParams) => Promise<T>,\n) => Promise<T>\n\nexport type Hooks = {\n  beforeRequest?: (options: HookParams) => any\n}\n\n/* Types for Logging */\nexport type LogLevel = 'info' | 'query' | 'warn' | 'error'\nexport type LogDefinition = {\n  level: LogLevel\n  emit: 'stdout' | 'event'\n}\n\nexport type GetLogType<\n  T extends LogLevel | LogDefinition\n  > = T extends LogDefinition\n  ? T['emit'] extends 'event'\n  ? T['level']\n  : never\n  : never\nexport type GetEvents<T extends Array<LogLevel | LogDefinition>> =\n  | GetLogType<T[0]>\n  | GetLogType<T[1]>\n  | GetLogType<T[2]>\n\nexport type QueryEvent = {\n  timestamp: Date\n  query: string\n  params: string\n  duration: number\n  target: string\n}\n\nexport type LogEvent = {\n  timestamp: Date\n  message: string\n  target: string\n}\n/* End Types for Logging */\n\nexport interface GetPrismaClientOptions {\n  document: DMMF.Document\n  generator?: GeneratorConfig\n  sqliteDatasourceOverrides?: DatasourceOverwrite[]\n  relativePath: string\n  dirname: string\n  clientVersion?: string\n  engineVersion?: string\n}\n\nexport type Action =\n  | 'findOne'\n  | 'findFirst'\n  | 'findMany'\n  | 'create'\n  | 'update'\n  | 'updateMany'\n  | 'upsert'\n  | 'delete'\n  | 'deleteMany'\n  | 'executeRaw'\n  | 'queryRaw'\n  | 'aggregate'\n\nconst actionOperationMap = {\n  findOne: 'query',\n  findFirst: 'query',\n  findMany: 'query',\n  count: 'query',\n  create: 'mutation',\n  update: 'mutation',\n  updateMany: 'mutation',\n  upsert: 'mutation',\n  delete: 'mutation',\n  deleteMany: 'mutation',\n  executeRaw: 'mutation',\n  queryRaw: 'mutation',\n  aggregate: 'query',\n}\n\nconst aggregateKeys = {\n  avg: true,\n  count: true,\n  sum: true,\n  min: true,\n  max: true,\n}\n\n// TODO: We **may** be able to get real types. However, we have both a bootstrapping\n// problem here, that we want to return a type that's not yet defined\n// and we're typecasting this anyway later\nexport function getPrismaClient(config: GetPrismaClientOptions): any {\n  class NewPrismaClient {\n    _dmmf: DMMFClass\n    _engine: NodeEngine\n    _fetcher: PrismaClientFetcher\n    _connectionPromise?: Promise<any>\n    _disconnectionPromise?: Promise<any>\n    _engineConfig: EngineConfig\n    private _errorFormat: ErrorFormat\n    private _hooks?: Hooks\n    private _getConfigPromise?: Promise<{\n      datasources: DataSource[]\n      generators: GeneratorConfig[]\n    }>\n    private _middlewares: Middleware[] = []\n    private _engineMiddlewares: EngineMiddleware[] = []\n    private _clientVersion: string\n    constructor(optionsArg?: PrismaClientOptions) {\n      this._clientVersion = config.clientVersion ?? clientVersion\n      try {\n        const options: PrismaClientOptions = optionsArg ?? {}\n        const internal = options.__internal ?? {}\n\n        const useDebug = internal.debug === true\n        if (useDebug) {\n          Debug.enable('prisma-client')\n        }\n\n        if (internal.hooks) {\n          this._hooks = internal.hooks\n        }\n\n        let predefinedDatasources = config.sqliteDatasourceOverrides ?? []\n        predefinedDatasources = predefinedDatasources.map((d) => ({\n          name: d.name,\n          url: 'file:' + path.resolve(config.dirname, d.url),\n        }))\n\n        const inputDatasources = Object.entries(options.datasources || {})\n          .filter(([_, source]) => {\n            return source && source.url\n          })\n          .map(([name, { url }]: any) => ({ name, url }))\n\n        const datasources = mergeBy(\n          predefinedDatasources,\n          inputDatasources,\n          (source) => source.name,\n        )\n\n        const engineConfig = internal.engine || {}\n\n        if (options.errorFormat) {\n          this._errorFormat = options.errorFormat\n        } else if (process.env.NODE_ENV === 'production') {\n          this._errorFormat = 'minimal'\n        } else if (process.env.NO_COLOR) {\n          this._errorFormat = 'colorless'\n        } else {\n          this._errorFormat = 'colorless' // default errorFormat\n        }\n\n        const envFile = this.readEnv()\n\n        this._dmmf = new DMMFClass(config.document)\n\n        let cwd = path.resolve(config.dirname, config.relativePath)\n\n        if (!fs.existsSync(cwd)) {\n          cwd = config.dirname\n        }\n\n        const previewFeatures = config.generator?.previewFeatures ?? []\n\n        this._engineConfig = {\n          cwd,\n          enableDebugLogs: useDebug,\n          enableEngineDebugMode: engineConfig.enableEngineDebugMode,\n          datamodelPath: path.join(config.dirname, 'schema.prisma'),\n          prismaPath: engineConfig.binaryPath ?? undefined,\n          engineEndpoint: engineConfig.endpoint,\n          datasources,\n          generator: config.generator,\n          showColors: this._errorFormat === 'pretty',\n          logLevel: options.log && (getLogLevel(options.log) as any), // TODO\n          logQueries:\n            options.log &&\n            Boolean(\n              typeof options.log === 'string'\n                ? options.log === 'query'\n                : options.log.find((o) =>\n                  typeof o === 'string' ? o === 'query' : o.level === 'query',\n                ),\n            ),\n          env: envFile,\n          flags: [],\n          clientVersion: config.clientVersion,\n          enableExperimental: mapPreviewFeatures(previewFeatures),\n          useUds: internal.useUds,\n        }\n\n        const sanitizedEngineConfig = omit(this._engineConfig, [\n          'env',\n          'datasources',\n        ])\n        debug({ engineConfig: sanitizedEngineConfig })\n\n        this._engine = new NodeEngine(this._engineConfig)\n        this._fetcher = new PrismaClientFetcher(this, false, this._hooks)\n\n        if (options.log) {\n          for (const log of options.log) {\n            const level =\n              typeof log === 'string'\n                ? log\n                : log.emit === 'stdout'\n                  ? log.level\n                  : null\n            if (level) {\n              this.$on(level, (event) => {\n                const colorMap = {\n                  query: 'blue',\n                  info: 'cyan',\n                  warn: 'yellow',\n                  error: 'red',\n                }\n                console.error(\n                  chalk[colorMap[level]](`prisma:${level}`.padEnd(13)) +\n                  (event.message || event.query),\n                )\n              })\n            }\n          }\n        }\n\n        this._bootstrapClient()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private readEnv() {\n      const dotEnvPath = path.resolve(\n        config.dirname,\n        config.relativePath,\n        '.env',\n      )\n      if (fs.existsSync(dotEnvPath)) {\n        return dotenvExpand(dotenv.config({ path: dotEnvPath })).parsed\n      }\n\n      return {}\n    }\n    use(...args) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.use() is deprecated, please use prisma.$use() instead`,\n      )\n      return (this.$use as any)(...args)\n    }\n    $use(cb: Middleware)\n    $use(namespace: 'all', cb: Middleware)\n    $use(namespace: 'engine', cb: EngineMiddleware)\n    $use(\n      namespace: HookPoint | Middleware,\n      cb?: Middleware | EngineMiddleware,\n    ) {\n      if (typeof namespace === 'function') {\n        this._middlewares.push(namespace)\n      } else if (typeof namespace === 'string') {\n        if (namespace === 'all') {\n          this._middlewares.push(cb! as Middleware)\n        } else if (namespace === 'engine') {\n          this._engineMiddlewares.push(cb! as EngineMiddleware)\n        } else {\n          throw new Error(`Unknown middleware hook ${namespace}`)\n        }\n      } else {\n        throw new Error(`Invalid middleware ${namespace}`)\n      }\n    }\n    on(eventType: any, callback: (event: any) => void) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.on() is deprecated, please use prisma.$on() instead`,\n      )\n      return this.$on(eventType, callback)\n    }\n    $on(eventType: any, callback: (event: any) => void) {\n      if (eventType === 'beforeExit') {\n        this._engine.on('beforeExit', callback)\n      } else {\n        this._engine.on(eventType, (event) => {\n          const fields = event.fields\n          if (eventType === 'query') {\n            return callback({\n              timestamp: event.timestamp,\n              query: fields.query,\n              params: fields.params,\n              duration: fields.duration_ms,\n              target: event.target,\n            })\n          } else {\n            // warn, info, or error events\n            return callback({\n              timestamp: event.timestamp,\n              message: fields.message,\n              target: event.target,\n            })\n          }\n        })\n      }\n    }\n    connect() {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.connect() is deprecated, please use prisma.$connect() instead`,\n      )\n      return this.$connect()\n    }\n    async $connect() {\n      try {\n        return this._engine.start()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n    /**\n     * @private\n     */\n    async _runDisconnect() {\n      await this._engine.stop()\n      delete this._connectionPromise\n      this._engine = new NodeEngine(this._engineConfig)\n      delete this._disconnectionPromise\n      delete this._getConfigPromise\n    }\n    disconnect() {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.disconnect() is deprecated, please use prisma.$disconnect() instead`,\n      )\n      return this.$disconnect()\n    }\n    /**\n     * Disconnect from the database\n     */\n    async $disconnect() {\n      try {\n        return this._engine.stop()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private async _getActiveProvider(): Promise<ConnectorType> {\n      const configResult = await this._engine.getConfig()\n      return configResult.datasources[0].activeProvider!\n    }\n\n    executeRaw(stringOrTemplateStringsArray, ...values) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.executeRaw() is deprecated, please use prisma.$executeRaw() instead`,\n      )\n      return this.$executeRaw(stringOrTemplateStringsArray, ...values)\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    private async $executeRawInternal(stringOrTemplateStringsArray, ...values) {\n      let query = ''\n      let parameters: any = undefined\n\n      const activeProvider = await this._getActiveProvider()\n\n      if (typeof stringOrTemplateStringsArray === 'string') {\n        // If this was called as prisma.$executeRaw(<SQL>, [...values]), assume it is a pre-prepared SQL statement, and forward it without any changes\n        query = stringOrTemplateStringsArray\n        parameters = {\n          values: serializeRawParameters(values || []),\n          __prismaRawParamaters__: true,\n        }\n      } else if (Array.isArray(stringOrTemplateStringsArray)) {\n        // If this was called as prisma.$executeRaw`<SQL>`, try to generate a SQL prepared statement\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.sql\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'postgresql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.text\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'sqlserver': {\n            query = mssqlPreparedStatement(stringOrTemplateStringsArray)\n            parameters = {\n              values: serializeRawParameters(values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n        }\n      } else {\n        // If this was called as prisma.raw(sql`<SQL>`), use prepared statements from sql-template-tag\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).sql\n            break\n          case 'postgresql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).text\n            break\n          case 'sqlserver':\n            query = mssqlPreparedStatement(\n              (stringOrTemplateStringsArray as sqlTemplateTag.Sql).strings,\n            )\n            break\n        }\n        parameters = {\n          values: serializeRawParameters(\n            (stringOrTemplateStringsArray as sqlTemplateTag.Sql).values,\n          ),\n          __prismaRawParamaters__: true,\n        }\n      }\n\n      if (parameters?.values) {\n        debug(`prisma.$executeRaw(${query}, ${parameters.values})`)\n      } else {\n        debug(`prisma.$executeRaw(${query})`)\n      }\n\n      const args = { query, parameters }\n\n      debug(`Prisma Client call:`)\n      return this._request({\n        args,\n        clientMethod: 'executeRaw',\n        dataPath: [],\n        action: 'executeRaw',\n        callsite: this._getCallsite(),\n        runInTransaction: false,\n      })\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    $executeRaw(stringOrTemplateStringsArray, ...values) {\n      try {\n        const promise = this.$executeRawInternal(stringOrTemplateStringsArray, ...values)\n          ; (promise as any).isExecuteRaw = true\n        return promise\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _getCallsite() {\n      if (this._errorFormat !== 'minimal') {\n        return new Error().stack\n      }\n      return undefined\n    }\n\n    queryRaw(stringOrTemplateStringsArray, ...args) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.queryRaw() is deprecated, please use prisma.$queryRaw() instead`,\n      )\n      return this.$queryRaw(stringOrTemplateStringsArray, ...args)\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    private async $queryRawInternal(\n      stringOrTemplateStringsArray:\n        | string\n        | TemplateStringsArray\n        | sqlTemplateTag.Sql,\n      ...values: any[]\n    ) {\n      let query = ''\n      let parameters: any = undefined\n\n      const activeProvider = await this._getActiveProvider()\n\n      if (typeof stringOrTemplateStringsArray === 'string') {\n        // If this was called as prisma.$queryRaw(<SQL>, [...values]), assume it is a pre-prepared SQL statement, and forward it without any changes\n        query = stringOrTemplateStringsArray\n        parameters = {\n          values: serializeRawParameters(values || []),\n          __prismaRawParamaters__: true,\n        }\n      } else if (Array.isArray(stringOrTemplateStringsArray)) {\n        // If this was called as prisma.$queryRaw`<SQL>`, try to generate a SQL prepared statement\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.sql\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'postgresql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.text\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'sqlserver': {\n            query = mssqlPreparedStatement(stringOrTemplateStringsArray)\n            parameters = {\n              values: serializeRawParameters(values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n        }\n      } else {\n        // If this was called as prisma.raw(sql`<SQL>`), use prepared statements from sql-template-tag\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).sql\n            break\n          case 'postgresql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).text\n            break\n          case 'sqlserver':\n            query = mssqlPreparedStatement(\n              (stringOrTemplateStringsArray as sqlTemplateTag.Sql).strings,\n            )\n            break\n        }\n        parameters = {\n          values: serializeRawParameters(\n            (stringOrTemplateStringsArray as sqlTemplateTag.Sql).values,\n          ),\n          __prismaRawParamaters__: true,\n        }\n      }\n\n      if (parameters?.values) {\n        debug(`prisma.queryRaw(${query}, ${parameters.values})`)\n      } else {\n        debug(`prisma.queryRaw(${query})`)\n      }\n\n      const args = { query, parameters }\n\n      debug(`Prisma Client call:`)\n      return this._request({\n        args,\n        clientMethod: 'queryRaw',\n        dataPath: [],\n        action: 'queryRaw',\n        callsite: this._getCallsite(),\n        runInTransaction: false,\n      })\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    $queryRaw(stringOrTemplateStringsArray, ...values) {\n      try {\n        const promise = this.$queryRawInternal(stringOrTemplateStringsArray, ...values)\n          ; (promise as any).isQueryRaw = true\n        return promise\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    async __internal_triggerPanic(fatal: boolean) {\n      if (!this._engineConfig.enableEngineDebugMode) {\n        throw new Error(`In order to use .__internal_triggerPanic(), please enable the debug mode like so:\nnew PrismaClient({\n  __internal: {\n    engine: {\n      enableEngineDebugMode: true\n    }\n  }\n})`)\n      }\n\n      const query = 'SELECT 1'\n\n      const headers: Record<string, string> = fatal\n        ? { 'X-DEBUG-FATAL': '1' }\n        : { 'X-DEBUG-NON-FATAL': '1' }\n\n      return this._request({\n        action: 'queryRaw',\n        args: {\n          query,\n          parameters: undefined,\n        },\n        clientMethod: 'queryRaw',\n        dataPath: [],\n        runInTransaction: false,\n        headers,\n        callsite: this._getCallsite(),\n      })\n    }\n\n    transaction(promises) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.transaction() is deprecated, please use prisma.$transaction() instead`,\n      )\n      return this.$transaction(promises)\n    }\n\n    private async $transactionInternal(promises: Array<any>): Promise<any> {\n      if (config.generator?.previewFeatures?.includes('transactionApi')) {\n        for (const p of promises) {\n          if (!p) {\n            throw new Error(\n              `All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`,\n            )\n          }\n          if (p?.isQueryRaw) {\n            throw new Error(`$queryRaw is not yet supported within $transaction.\nPlease report in https://github.com/prisma/prisma/issues/3828 if you need this feature.`)\n          }\n          if (p?.isExecuteRaw) {\n            throw new Error(`$executeRaw is not yet supported within $transaction.\nPlease report in https://github.com/prisma/prisma/issues/3828 if you need this feature`)\n          }\n          if (\n            !p.requestTransaction ||\n            typeof p.requestTransaction !== 'function'\n          ) {\n            throw new Error(\n              `All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`,\n            )\n          }\n        }\n        return Promise.all(promises.map((p) => p.requestTransaction()))\n      } else {\n        throw new Error(\n          `In order to use the .transaction() api, please enable 'previewFeatures = \"transactionApi\" in your schema.`,\n        )\n      }\n    }\n\n    async $transaction(promises: Array<any>): Promise<any> {\n      try {\n        return this.$transactionInternal(promises)\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _request(internalParams: InternalRequestParams) {\n      try {\n        const resource = new AsyncResource('prisma-client-request')\n        if (this._middlewares.length > 0) {\n          // https://perf.link/#eyJpZCI6Img4bmd0anp5eGxrIiwidGl0bGUiOiJGaW5kaW5nIG51bWJlcnMgaW4gYW4gYXJyYXkgb2YgMTAwMCIsImJlZm9yZSI6ImNvbnN0IGRhdGEgPSB7XG4gIG9wZXJhdGlvbjogXCJxdWVyeVwiLFxuICByb290RmllbGQ6IFwiZmluZE1hbnlVc2VyXCIsXG4gIGFyZ3M6IHtcbiAgICB3aGVyZTogeyBpZDogeyBndDogNSB9IH1cbiAgfSxcbiAgZGF0YVBhdGg6IFtdLFxuICBjbGllbnRNZXRob2Q6ICd1c2VyLmZpbmRNYW55J1xufSIsInRlc3RzIjpbeyJuYW1lIjoiZm9yIGluIiwiY29kZSI6ImNvbnN0IG5ld0RhdGEgPSB7fVxuZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICBpZiAoa2V5ICE9PSAnY2xpZW50TWV0aG9kJykge1xuICAgIG5ld0RhdGFba2V5XSA9IGRhdGFba2V5XVxuICB9XG59IiwicnVucyI6WzU1MzAwMCw0OTAwMDAsMzQ0MDAwLDYyNDAwMCwxMzkxMDAwLDEyMjQwMDAsMTA2NDAwMCwxMjE3MDAwLDc0MDAwLDM3MzAwMCw5MDUwMDAsNTM3MDAwLDE3MDYwMDAsOTAzMDAwLDE0MjUwMDAsMTMxMjAwMCw3NjkwMDAsMTM0NTAwMCwxOTQ4MDAwLDk5MDAwMCw5MDAwMDAsMTM0ODAwMCwxMDk2MDAwLDM4NjAwMCwxNTE3MDAwLDE5MzYwMDAsMTAwMCwyMTM0MDAwLDEzMjgwMDAsODI5MDAwLDE1ODYwMDAsMTc2MzAwMCw1MDgwMDAsOTg2MDAwLDE5NDkwMDAsMjEwODAwMCwxNjA4MDAwLDIyNDAwMCwxOTAyMDAwLDEyNjgwMDAsMjEzNDAwMCwxNzEwMDAwLDEzNzIwMDAsMjExMDAwMCwxNzgwMDAwLDc3NzAwMCw1NzgwMDAsNDAwMCw4OTAwMDAsMTEwMTAwMCwxNTk0MDAwLDE3ODAwMDAsMzU0MDAwLDU0NDAwMCw4MjQwMDAsNzEwMDAwLDg0OTAwMCwxNjQwMDAwLDE5ODQwMDAsNzAzMDAwLDg4MjAwMCw4NTAwMDAsMTA2MDAwLDMwMzAwMCwxMzMwMDAsNjA4MDAwLDIxMzQwMDAsNTUxMDAwLDc0MjAwMCwyMDcwMDAsMTU3NTAwMCwxMzQwMDAsNDAwMCwxMDAwLDQ5NDAwMCwyNTAwMDAsMTQwMjAwMCw2OTgwMDAsNTgxMDAwLDQ4MDAwMCwyMDMwMDAsMTY4MzAwMCwxNjcxMDAwLDEyNDAwMDAsMTk1NjAwMCwzMDUwMDAsODkwMDAsNjUzMDAwLDE3MDgwMDAsMTYwMTAwMCwxOTg0MDAwLDg4ODAwMCwyMTAwMDAwLDE5NzUwMDAsNTM2MDAwLDU3NTAwMCwyMTM0MDAwLDEwMTcwMDAsMTI5NzAwMCw3NTYwMDBdLCJvcHMiOjEwNDUxNTB9LHsibmFtZSI6IkRlY29uc3RydWN0b3IiLCJjb2RlIjoiY29uc3QgeyBjbGllbnRNZXRob2QsIC4uLnJlc3QgfSA9IGRhdGEiLCJydW5zIjpbMjE0MDAwLDUxMDAwLDg2NDAwMCw3MjcwMDAsNDMxMDAwLDIyMDAwMCwzOTAwMDAsODQxMDAwLDIyOTAwMCw3MjIwMDAsNDEzMDAwLDYwODAwMCwyOTgwMDAsMzY4MDAwLDg2NDAwMCw5MjQwMDAsMTI4MDAwLDU1MzAwMCw4ODAwMDAsNTQ1MDAwLDc3NTAwMCw0MzAwMDAsMjM3MDAwLDc4NjAwMCw1NTUwMDAsNTI2MDAwLDMyNzAwMCw2MzAwMCw5MTIwMDAsMTgxMDAwLDMzMTAwMCw0MzAwMCwyMjUwMDAsNTQ3MDAwLDgyMjAwMCw3OTMwMDAsMTA1NzAwMCw1NjAwMCwyNzUwMDAsMzkzMDAwLDgwNTAwMCw5MzAwMCw3NjYwMDAsODM0MDAwLDUwMzAwMCw4MDAwMCwyMzgwMDAsNDY0MDAwLDU2NDAwMCw3MzAwMDAsOTU1MDAwLDgwOTAwMCwyMDMwMDAsNDEzMDAwLDM0NDAwMCw1MDIwMDAsNjEzMDAwLDEwMDAwMCw0MzIwMDAsNjcwMDAwLDQ1MzAwMCw4OTEwMDAsNTUwMDAsMjMwMDAwLDM5MTAwMCw3NTQwMDAsMTEyMjAwMCw3NjIwMDAsMzU3MDAwLDQ3MDAwLDc5MjAwMCwzNTQwMDAsMTA4MDAwMCwxNjAwMCwxODgwMDAsMTQxMDAwLDIxMDAwMCw2MDcwMDAsOTAyMDAwLDgyNTAwMCwxOTAwMDAsMjMzMDAwLDI4MzAwMCwyMzgwMDAsNjk2MDAwLDc2ODAwMCw3NTgwMDAsMTk0MDAwLDI3OTAwMCwyMjMwMDAsMjM4MDAwLDkzNDAwMCw2MDUwMDAsMTcwMDAsMjEwMDAwLDMyMjAwMCwxMDM0MDAwLDgxMjAwMCw0NDYwMDAsNjMxMDAwXSwib3BzIjo0OTAxMDB9LHsibmFtZSI6ImRlbGV0ZSIsImNvZGUiOiJjb25zdCB7IGNsaWVudE1ldGhvZCB9ID0gZGF0YVxuZGVsZXRlIGRhdGEuY2xpZW50TWV0aG9kIiwicnVucyI6WzI3NjIwMDAsNjIyMDAwLDEwNTcwMDAsMzIzMTAwMCwzNDQ2MDAwLDIwNzMwMDAsMzM4MjAwMCwyNzA0MDAwLDM4ODEwMDAsMTIwMTAwMCwzNzk3MDAwLDI1OTAwMCwxMDI4MDAwLDI1MTgwMDAsMjEwMjAwMCwxOTczMDAwLDM0MTIwMDAsMzU4MDAwLDExNDcwMDAsMTA3NDAwMCwzMTk1MDAwLDM2NzUwMDAsNTQ3MDAwLDIwNzkwMDAsMjc0NTAwMCwyNDE1MDAwLDIxOTAwMCwzNzM3MDAwLDM2OTIwMDAsMTY0MDAwLDI0MzMwMDAsNjQzMDAwLDcxODAwMCw0Mzg2MDAwLDE3MDIwMDAsMTAyNDAwMCw1NjUwMDAsNDIxOTAwMCwxMTk3MDAwLDE4MzkwMDAsMzgyMTAwMCwxMTUyMDAwLDg1MzAwMCwxMzczMDAwLDI5NTAwMCwxNDg5MDAwLDE0MjEwMDAsMjcyNDAwMCw1MDYxMDAwLDI2NTcwMDAsMjYzNzAwMCwyOTkwMDAsMjE1NzAwMCwxNTAxMDAwLDM2OTAwMDAsMzU3OTAwMCw0MjE5MDAwLDI4NTgwMDAsNTI0MzAwMCwxNTA0MDAwLDEyMTMwMDAsMjM4NDAwMCw3NzgwMDAsMjgyNjAwMCwxNzQ5MDAwLDM2MjAwMCwyNzEzMDAwLDMzODYwMDAsMzE2NjAwMCwxNTMwMDAsNzk0MDAwLDMyMTcwMDAsMjA4MjAwMCw0MTUwMDAsMzMyMDAwMCwyMTA1MDAwLDE1NzYwMDAsMjUxMDAwLDIzMjkwMDAsOTI1MDAwLDM3MTUwMDAsNjkyMDAwLDE5MDIwMDAsMjA0NzAwMCwyNTM5MDAwLDIwMjkwMDAsMzE3OTAwMCwyMTA2MDAwLDg5NTAwMCwxNTUwMDAwLDYwNzAwMCw0MTA1MDAwLDM0ODMwMDAsMzcxNTAwMCw0OTQwMDAwLDIyODAwMCw0MDI2MDAwLDE2MTYwMDAsMzMxNDAwMCwyNDIyMDAwXSwib3BzIjoyMTY2MDgwfSx7Im5hbWUiOiJDcmVhdGUgbmV3IG9iamVjdCIsImNvZGUiOiJjb25zdCBuZXdEYXRhID0ge1xuICBvcGVyYXRpb246IGRhdGEub3BlcmF0aW9uLFxuICByb290RmllbGQ6IGRhdGEucm9vdEZpZWxkLFxuICBhcmdzOiBkYXRhLmFyZ3MsXG4gIGRhdGFQYXRoOiBkYXRhLmRhdGFQYXRoXG59IiwicnVucyI6WzcwNTAwMCwxMTAwMDAsMzI3NTAwMCwxOTgwMDAsMjE5OTAwMCw0MzYwMDAsODI4MDAwLDI5MjcwMDAsNzI0MDAwLDI1NDAwMCwyOTgzMDAwLDI2NzIwMDAsMjUzMDAwLDI4MjcwMDAsMzA0ODAwMCwyOTA3MDAwLDM0OTkwMDAsMjY1OTAwMCwzODIyMDAwLDI3NzcwMDAsMzc5NzAwMCw4MDAwMDAsNDM1MDAwLDExOTMwMDAsMTAwMDAsMTQ0MDAwMCw3NTcwMDAsMTMyMDAwMCwzMjIwMDAsMjA3MDAwLDM2ODAwMDAsMzkxMTAwMCwzMjQxMDAwLDExMDcwMDAsNDM4MDAwLDMwNDQwMDAsMTA3NjAwMCwyMTAwMDAsNDIxOTAwMCwzNzQ4MDAwLDQwNjcwMDAsNzc0MDAwLDYzMDAwLDMyMTAwMCwzMDQ4MDAwLDMxMjgwMDAsMTg3MTAwMCwzNTkxMDAwLDI0MzcwMDAsNjcxMDAwLDc5OTAwMCwxMTUzMDAwLDIxMTMwMDAsOTUwMDAsNTg3MDAwLDYyMzAwMCwxMzEzMDAwLDMxNTgwMDAsMzMyNzAwMCwxNTkwMDAsNDg4MDAwLDIxMTAwMCwxMjk0MDAwLDExNTcwMDAsNDA0MDAwLDM2MjMwMDAsMjY4NDAwMCw4NzkwMDAsMjE4NTAwMCwxNTkyMDAwLDM2ODcwMDAsMjI0ODAwMCwyMjE4MDAwLDE3NDMwMDAsNzg4MDAwLDQwODYwMDAsMjExNTAwMCwzOTE0MDAwLDM5MjgwMDAsNDM3MjAwMCwxOTkwMDAsMzc1MzAwMCwzNjQ3MDAwLDE2MjcwMDAsMTQ5OTAwMCwxODQyMDAwLDIxMjkwMDAsNDAwMCwxMjIzMDAwLDI4NjMwMDAsMzgzNDAwMCwzNjk0MDAwLDYzNjAwMCw0MjQ3MDAwLDQwMjIwMDAsMTAwMDAsMTcxNDAwMCwxNzUwMDAwLDI5MDEwMDAsMTM0NjAwMF0sIm9wcyI6MTkzOTEyMH1dLCJ1cGRhdGVkIjoiMjAyMC0wNy0xNVQxMTowMDo1Ny45MzhaIn0%3D\n          const params: MiddlewareParams = {\n            args: internalParams.args,\n            dataPath: internalParams.dataPath,\n            runInTransaction: internalParams.runInTransaction,\n            action: internalParams.action,\n            model: internalParams.model,\n          }\n          return resource.runInAsyncScope(() =>\n            this._requestWithMiddlewares(\n              params,\n              this._middlewares.slice(),\n              internalParams.clientMethod,\n              internalParams.callsite,\n              internalParams.headers,\n            ),\n          )\n        }\n\n        return resource.runInAsyncScope(() =>\n          this._executeRequest(internalParams),\n        )\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _requestWithMiddlewares(\n      params: MiddlewareParams,\n      middlewares: Middleware[],\n      clientMethod: string,\n      callsite?: string,\n      headers?: Record<string, string>,\n    ) {\n      const middleware = middlewares.shift()\n      if (middleware) {\n        return middleware(params, (params2) =>\n          this._requestWithMiddlewares(\n            params2,\n            middlewares,\n            clientMethod,\n            callsite,\n          ),\n        )\n      }\n\n      // No, we won't copy the whole object here just to make it easier to do TypeScript\n      // as it would be much slower\n      ; (params as InternalRequestParams).clientMethod = clientMethod\n        ; (params as InternalRequestParams).callsite = callsite\n        ; (params as InternalRequestParams).headers = headers\n\n      return this._executeRequest(params as InternalRequestParams)\n    }\n\n    private _executeRequest({\n      args,\n      clientMethod,\n      dataPath,\n      callsite,\n      runInTransaction,\n      action,\n      model,\n      headers,\n    }: InternalRequestParams) {\n      if (action !== 'executeRaw' && action !== 'queryRaw' && !model) {\n        throw new Error(`Model missing for action ${action}`)\n      }\n\n      if ((action === 'executeRaw' || action === 'queryRaw') && model) {\n        throw new Error(\n          `executeRaw and queryRaw can't be executed on a model basis. The model ${model} has been provided`,\n        )\n      }\n\n      let rootField: string | undefined\n      const operation = actionOperationMap[action]\n\n      if (action === 'executeRaw' || action === 'queryRaw') {\n        rootField = action\n      }\n\n      // TODO: Replace with lookup map for speedup\n      let mapping\n      if (model) {\n        mapping = this._dmmf.mappingsMap[model]\n        if (!mapping) {\n          throw new Error(`Could not find mapping for model ${model}`)\n        }\n\n        rootField = mapping[action]\n      }\n\n      if (operation !== 'query' && operation !== 'mutation') {\n        throw new Error(`Invalid operation ${operation} for action ${action}`)\n      }\n\n      const field = this._dmmf.rootFieldMap[rootField!]\n\n      if (!field) {\n        throw new Error(\n          `Could not find rootField ${rootField} for action ${action} for model ${model} on rootType ${operation}`,\n        )\n      }\n\n      const { isList } = field.outputType\n      const typeName = getOutputTypeName(field.outputType.type)\n\n      let document = makeDocument({\n        dmmf: this._dmmf,\n        rootField: rootField!,\n        rootTypeName: operation,\n        select: args,\n      })\n\n      document.validate(args, false, clientMethod, this._errorFormat, callsite)\n\n      document = transformDocument(document)\n\n      // as printJsonWithErrors takes a bit of compute\n      // we only want to do it, if debug is enabled for 'prisma-client'\n      if (Debug.enabled('prisma-client')) {\n        const query = String(document)\n        debug(`Prisma Client call:`)\n        debug(\n          `prisma.${clientMethod}(${printJsonWithErrors({\n            ast: args,\n            keyPaths: [],\n            valuePaths: [],\n            missingItems: [],\n          })})`,\n        )\n        debug(`Generated request:`)\n        debug(query + '\\n')\n      }\n\n      return this._fetcher.request({\n        document,\n        clientMethod,\n        typeName,\n        dataPath,\n        isList,\n        rootField: rootField!,\n        callsite,\n        showColors: this._errorFormat === 'pretty',\n        args,\n        engineHook: this._engineMiddlewares[0],\n        runInTransaction,\n        headers,\n      })\n    }\n\n    private _bootstrapClient() {\n      const clients = this._dmmf.mappings.reduce((acc, mapping) => {\n        const lowerCaseModel = lowerCase(mapping.model)\n        const model = this._dmmf.modelMap[mapping.model]\n\n        if (!model) {\n          throw new Error(`Invalid mapping ${mapping.model}, can't find model`)\n        }\n\n        const prismaClient = ({\n          operation,\n          actionName,\n          args,\n          dataPath,\n          modelName,\n        }) => {\n          dataPath = dataPath ?? []\n\n          const clientMethod = `${lowerCaseModel}.${actionName}`\n\n          let requestPromise: Promise<any>\n          const callsite = this._getCallsite()\n\n          const requestModelName = modelName ?? model.name\n\n          const clientImplementation = {\n            then: (onfulfilled, onrejected) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.then(onfulfilled, onrejected)\n            },\n            requestTransaction: () => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: true,\n                })\n              }\n\n              return requestPromise\n            },\n            catch: (onrejected) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.catch(onrejected)\n            },\n            finally: (onfinally) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.finally(onfinally)\n            },\n          }\n\n          // add relation fields\n          for (const field of model.fields.filter((f) => f.kind === 'object')) {\n            clientImplementation[field.name] = (fieldArgs) => {\n              const prefix = dataPath.includes('select')\n                ? 'select'\n                : dataPath.includes('include')\n                  ? 'include'\n                  : 'select'\n              const newDataPath = [...dataPath, prefix, field.name]\n              const newArgs = deepSet(args, newDataPath, fieldArgs || true)\n\n              return clients[field.type]({\n                operation,\n                actionName,\n                args: newArgs,\n                dataPath: newDataPath,\n                isList: field.isList,\n                /*\n                 * necessary for user.posts() calls -> the original model name needs to be preserved\n                 */\n                modelName: modelName || model.name,\n              })\n            }\n          }\n\n          return clientImplementation\n        }\n\n        acc[model.name] = prismaClient\n\n        return acc\n      }, {})\n\n      for (const mapping of this._dmmf.mappings) {\n        const lowerCaseModel = lowerCase(mapping.model)\n\n        const denyList = {\n          model: true,\n          plural: true,\n          aggregate: true,\n        }\n\n        const delegate: any = Object.entries(mapping).reduce(\n          (acc, [actionName, rootField]) => {\n            if (!denyList[actionName]) {\n              const operation = getOperation(actionName as any)\n              acc[actionName] = (args) =>\n                clients[mapping.model]({\n                  operation,\n                  actionName,\n                  args,\n                })\n            }\n\n            return acc\n          },\n          {},\n        )\n\n        delegate.count = (args) => {\n          return clients[mapping.model]({\n            operation: 'query',\n            actionName: `aggregate`,\n            args: args\n              ? {\n                ...args,\n                select: { count: true },\n              }\n              : undefined,\n            dataPath: ['count'],\n          })\n        }\n\n        delegate.aggregate = (args) => {\n          /**\n           * avg, count, sum, min, max need to go into select\n           * For speed reasons we can go with \"for in \"\n           */\n          const select = Object.entries(args).reduce((acc, [key, value]) => {\n            if (aggregateKeys[key]) {\n              if (!acc.select) {\n                acc.select = {}\n              }\n              // `count` doesn't have a sub-selection\n              if (key === 'count') {\n                acc.select[key] = value\n              } else {\n                acc.select[key] = { select: value }\n              }\n            } else {\n              acc[key] = value\n            }\n            return acc\n          }, {} as any)\n\n          return clients[mapping.model]({\n            operation: 'query',\n            actionName: 'aggregate', // actionName is just cosmetics \uD83D\uDC85\uD83C\uDFFD\n            rootField: mapping.aggregate,\n            args: select,\n            dataPath: [],\n          })\n        }\n\n        this[lowerCaseModel] = delegate\n      }\n    }\n  }\n\n  return NewPrismaClient\n}\n\nexport class PrismaClientFetcher {\n  prisma: any\n  debug: boolean\n  hooks: any\n  dataloader: Dataloader<{\n    document: Document\n    runInTransaction?: boolean\n    headers?: Record<string, string>\n  }>\n\n  constructor(prisma, enableDebug = false, hooks?: any) {\n    this.prisma = prisma\n    this.debug = enableDebug\n    this.hooks = hooks\n    this.dataloader = new Dataloader({\n      batchLoader: async (requests) => {\n        const queries = requests.map((r) => String(r.document))\n        const runTransaction = requests[0].runInTransaction\n        return this.prisma._engine.requestBatch(queries, runTransaction)\n      },\n      singleLoader: async (request) => {\n        const query = String(request.document)\n        return this.prisma._engine.request(query, request.headers)\n      },\n      batchBy: (request) => {\n        if (request.runInTransaction) {\n          return 'transaction-batch'\n        }\n\n        if (!request.document.children[0].name.startsWith('findOne')) {\n          return null\n        }\n\n        const selectionSet = request.document.children[0].children!.join(',')\n\n        const args = request.document.children[0].args?.args\n          .map((a) => {\n            if (a.value instanceof Args) {\n              return a.key + '-' + a.value.args.map((a) => a.key).join(',')\n            }\n            return a.key\n          })\n          .join(',')\n\n        return `${request.document.children[0].name}|${args}|${selectionSet}`\n      },\n    })\n  }\n\n  async request({\n    document,\n    dataPath = [],\n    rootField,\n    typeName,\n    isList,\n    callsite,\n    clientMethod,\n    runInTransaction,\n    showColors,\n    engineHook,\n    args,\n    headers,\n  }: {\n    document: Document\n    dataPath: string[]\n    rootField: string\n    typeName: string\n    isList: boolean\n    clientMethod: string\n    callsite?: string\n    runInTransaction?: boolean\n    showColors?: boolean\n    engineHook?: EngineMiddleware\n    args: any\n    headers?: Record<string, string>\n  }) {\n    if (this.hooks && this.hooks.beforeRequest) {\n      const query = String(document)\n      this.hooks.beforeRequest({\n        query,\n        path: dataPath,\n        rootField,\n        typeName,\n        document,\n        isList,\n        clientMethod,\n        args,\n      })\n    }\n    try {\n      /**\n       * If there's an engine hook, use it here\n       */\n      let data, elapsed\n      if (engineHook) {\n        const result = await engineHook(\n          {\n            document,\n            runInTransaction,\n          },\n          (params) => this.dataloader.request(params),\n        )\n        data = result.data\n        elapsed = result.elapsed\n      } else {\n        const result = await this.dataloader.request({\n          document,\n          runInTransaction,\n          headers,\n        })\n        data = result.data\n        elapsed = result.elapsed\n      }\n\n      /**\n       * Unpack\n       */\n      const unpackResult = this.unpack(document, data, dataPath, rootField)\n      if (process.env.PRISMA_CLIENT_GET_TIME) {\n        return { data: unpackResult, elapsed }\n      }\n      return unpackResult\n    } catch (e) {\n      debug(e)\n      let message = e.message\n      if (callsite) {\n        const { stack } = printStack({\n          callsite,\n          originalMethod: clientMethod,\n          onUs: e.isPanic,\n          showColors,\n        })\n        message = stack + '\\n  ' + e.message\n      }\n\n      message = this.sanitizeMessage(message)\n      // TODO: Do request with callsite instead, so we don't need to rethrow\n      if (e.code) {\n        throw new PrismaClientKnownRequestError(\n          message,\n          e.code,\n          this.prisma._clientVersion,\n          e.meta,\n        )\n      } else if (e.isPanic) {\n        throw new PrismaClientRustPanicError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientUnknownRequestError) {\n        throw new PrismaClientUnknownRequestError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientInitializationError) {\n        throw new PrismaClientInitializationError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientRustPanicError) {\n        throw new PrismaClientRustPanicError(\n          message,\n          this.prisma._clientVersion,\n        )\n      }\n\n      e.clientVersion = this.prisma._clientVersion\n\n      throw e\n    }\n  }\n\n  sanitizeMessage(message) {\n    if (this.prisma._errorFormat && this.prisma._errorFormat !== 'pretty') {\n      return stripAnsi(message)\n    }\n    return message\n  }\n  unpack(document, data, path, rootField) {\n    if (data.data) {\n      data = data.data\n    }\n    const getPath: any[] = []\n    if (rootField) {\n      getPath.push(rootField)\n    }\n    getPath.push(...path.filter((p) => p !== 'select' && p !== 'include'))\n    return unpack({ document, data, path: getPath })\n  }\n}\n\nexport function getOperation(action: DMMF.ModelAction): 'query' | 'mutation' {\n  if (\n    action === DMMF.ModelAction.findMany ||\n    action === DMMF.ModelAction.findOne ||\n    action === DMMF.ModelAction.findFirst\n  ) {\n    return 'query'\n  }\n  return 'mutation'\n}\n", "export function serializeRawParameters(data: any): string {\n  return JSON.stringify(replaceDates(data))\n}\n\n/**\n * Replaces Date as needed in https://github.com/prisma/prisma-engines/pull/835\n * @param data parameters\n */\nexport function replaceDates(data: any): any {\n  const type = Object.prototype.toString.call(data)\n\n  if (type === '[object Date]') {\n    return {\n      prisma__type: 'date',\n      prisma__value: data.toJSON(),\n    }\n  }\n\n  if (type === '[object Object]') {\n    const tmp = {}\n    for (let key in data) {\n      if (key !== '__proto__') {\n        tmp[key] = replaceDates(data[key])\n      }\n    }\n    return tmp\n  }\n\n  if (type === '[object Array]') {\n    let k = data.length\n    let tmp\n    for (tmp = new Array(k); k--; ) {\n      tmp[k] = replaceDates(data[k])\n    }\n    return tmp\n  }\n\n  return data\n}\n", "import { DMMFClass } from './dmmf'\nimport { DMMF } from './dmmf-types'\nimport path from 'path'\nimport {\n  PrismaClientKnownRequestError,\n  PrismaClientUnknownRequestError,\n  PrismaClientInitializationError,\n  PrismaClientRustPanicError,\n} from '.'\nimport {\n  NodeEngine,\n  EngineConfig,\n  DatasourceOverwrite,\n} from '@prisma/engine-core/dist/NodeEngine'\nimport {\n  Document,\n  makeDocument,\n  unpack,\n  transformDocument,\n  Args,\n} from './query'\nimport Debug from '@prisma/debug'\nconst debug = Debug('prisma-client')\nimport fs from 'fs'\nimport chalk from 'chalk'\nimport * as sqlTemplateTag from 'sql-template-tag'\nimport dotenv from 'dotenv'\nimport { dotenvExpand } from '@prisma/sdk/dist/dotenvExpand'\nimport {\n  GeneratorConfig,\n  DataSource,\n} from '@prisma/generator-helper/dist/types'\nimport { getLogLevel } from './getLogLevel'\nimport { mergeBy } from './mergeBy'\nimport { lowerCase, getOutputTypeName } from './utils/common'\nimport { deepSet } from './utils/deep-set'\nimport { Dataloader } from './Dataloader'\nimport { printStack } from './utils/printStack'\nimport stripAnsi from 'strip-ansi'\nimport { printJsonWithErrors } from './utils/printJsonErrors'\nimport { ConnectorType } from './utils/printDatasources'\nimport { omit } from './utils/omit'\nimport { mapPreviewFeatures } from '@prisma/sdk/dist/utils/mapPreviewFeatures'\nimport { serializeRawParameters } from './utils/serializeRawParameters'\nimport { AsyncResource } from 'async_hooks'\nimport { clientVersion } from './utils/clientVersion'\nimport { mssqlPreparedStatement } from './utils/mssqlPreparedStatement'\n\nexport type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n\nexport type Datasource = {\n  url?: string\n}\nexport type Datasources = Record<string, Datasource>\n\nexport interface PrismaClientOptions {\n  /**\n   * Overwrites the datasource url from your prisma.schema file\n   */\n  datasources?: Datasources\n\n  /**\n   * @default \"colorless\"\n   */\n  errorFormat?: ErrorFormat\n\n  /**\n   * @example\n   * \\`\\`\\`\n   * // Defaults to stdout\n   * log: ['query', 'info', 'warn']\n   *\n   * // Emit as events\n   * log: [\n   *  { emit: 'stdout', level: 'query' },\n   *  { emit: 'stdout', level: 'info' },\n   *  { emit: 'stdout', level: 'warn' }\n   * ]\n   * \\`\\`\\`\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n   */\n  log?: Array<LogLevel | LogDefinition>\n\n  /**\n   * @internal\n   * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\n   */\n  __internal?: {\n    debug?: boolean\n    hooks?: Hooks\n    useUds?: boolean\n    engine?: {\n      cwd?: string\n      binaryPath?: string\n      endpoint?: string\n      enableEngineDebugMode?: boolean\n    }\n  }\n}\n\nexport type HookParams = {\n  query: string\n  path: string[]\n  rootField?: string\n  typeName?: string\n  document: any\n  clientMethod: string\n  args: any\n}\n\n/**\n * These options are being passed in to the middleware as \"params\"\n */\nexport type MiddlewareParams = {\n  model?: string\n  action: Action\n  args: any\n  dataPath: string[]\n  runInTransaction: boolean\n}\n\n/**\n * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation\n */\nexport type Middleware<T = any> = (\n  params: MiddlewareParams,\n  next: (params: MiddlewareParams) => Promise<T>,\n) => Promise<T>\n\nexport interface InternalRequestParams extends MiddlewareParams {\n  /**\n   * The original client method being called.\n   * Even though the rootField / operation can be changed,\n   * this method stays as it is, as it's what the user's\n   * code looks like\n   */\n  clientMethod: string\n  callsite?: string\n  headers?: Record<string, string>\n}\n\nexport type HookPoint = 'all' | 'engine'\n\nexport type EngineMiddlewareParams = {\n  document: Document\n  runInTransaction?: boolean\n}\n\n// only used by the .use() hooks\nexport type AllHookArgs = {\n  params: HookParams\n  fetch: (params: HookParams) => Promise<any>\n}\n/**\n * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation\n */\nexport type EngineMiddleware<T = any> = (\n  params: EngineMiddlewareParams,\n  next: (params: EngineMiddlewareParams) => Promise<T>,\n) => Promise<T>\n\nexport type Hooks = {\n  beforeRequest?: (options: HookParams) => any\n}\n\n/* Types for Logging */\nexport type LogLevel = 'info' | 'query' | 'warn' | 'error'\nexport type LogDefinition = {\n  level: LogLevel\n  emit: 'stdout' | 'event'\n}\n\nexport type GetLogType<\n  T extends LogLevel | LogDefinition\n  > = T extends LogDefinition\n  ? T['emit'] extends 'event'\n  ? T['level']\n  : never\n  : never\nexport type GetEvents<T extends Array<LogLevel | LogDefinition>> =\n  | GetLogType<T[0]>\n  | GetLogType<T[1]>\n  | GetLogType<T[2]>\n\nexport type QueryEvent = {\n  timestamp: Date\n  query: string\n  params: string\n  duration: number\n  target: string\n}\n\nexport type LogEvent = {\n  timestamp: Date\n  message: string\n  target: string\n}\n/* End Types for Logging */\n\nexport interface GetPrismaClientOptions {\n  document: DMMF.Document\n  generator?: GeneratorConfig\n  sqliteDatasourceOverrides?: DatasourceOverwrite[]\n  relativePath: string\n  dirname: string\n  clientVersion?: string\n  engineVersion?: string\n}\n\nexport type Action =\n  | 'findOne'\n  | 'findFirst'\n  | 'findMany'\n  | 'create'\n  | 'update'\n  | 'updateMany'\n  | 'upsert'\n  | 'delete'\n  | 'deleteMany'\n  | 'executeRaw'\n  | 'queryRaw'\n  | 'aggregate'\n\nconst actionOperationMap = {\n  findOne: 'query',\n  findFirst: 'query',\n  findMany: 'query',\n  count: 'query',\n  create: 'mutation',\n  update: 'mutation',\n  updateMany: 'mutation',\n  upsert: 'mutation',\n  delete: 'mutation',\n  deleteMany: 'mutation',\n  executeRaw: 'mutation',\n  queryRaw: 'mutation',\n  aggregate: 'query',\n}\n\nconst aggregateKeys = {\n  avg: true,\n  count: true,\n  sum: true,\n  min: true,\n  max: true,\n}\n\n// TODO: We **may** be able to get real types. However, we have both a bootstrapping\n// problem here, that we want to return a type that's not yet defined\n// and we're typecasting this anyway later\nexport function getPrismaClient(config: GetPrismaClientOptions): any {\n  class NewPrismaClient {\n    _dmmf: DMMFClass\n    _engine: NodeEngine\n    _fetcher: PrismaClientFetcher\n    _connectionPromise?: Promise<any>\n    _disconnectionPromise?: Promise<any>\n    _engineConfig: EngineConfig\n    private _errorFormat: ErrorFormat\n    private _hooks?: Hooks\n    private _getConfigPromise?: Promise<{\n      datasources: DataSource[]\n      generators: GeneratorConfig[]\n    }>\n    private _middlewares: Middleware[] = []\n    private _engineMiddlewares: EngineMiddleware[] = []\n    private _clientVersion: string\n    constructor(optionsArg?: PrismaClientOptions) {\n      this._clientVersion = config.clientVersion ?? clientVersion\n      try {\n        const options: PrismaClientOptions = optionsArg ?? {}\n        const internal = options.__internal ?? {}\n\n        const useDebug = internal.debug === true\n        if (useDebug) {\n          Debug.enable('prisma-client')\n        }\n\n        if (internal.hooks) {\n          this._hooks = internal.hooks\n        }\n\n        let predefinedDatasources = config.sqliteDatasourceOverrides ?? []\n        predefinedDatasources = predefinedDatasources.map((d) => ({\n          name: d.name,\n          url: 'file:' + path.resolve(config.dirname, d.url),\n        }))\n\n        const inputDatasources = Object.entries(options.datasources || {})\n          .filter(([_, source]) => {\n            return source && source.url\n          })\n          .map(([name, { url }]: any) => ({ name, url }))\n\n        const datasources = mergeBy(\n          predefinedDatasources,\n          inputDatasources,\n          (source) => source.name,\n        )\n\n        const engineConfig = internal.engine || {}\n\n        if (options.errorFormat) {\n          this._errorFormat = options.errorFormat\n        } else if (process.env.NODE_ENV === 'production') {\n          this._errorFormat = 'minimal'\n        } else if (process.env.NO_COLOR) {\n          this._errorFormat = 'colorless'\n        } else {\n          this._errorFormat = 'colorless' // default errorFormat\n        }\n\n        const envFile = this.readEnv()\n\n        this._dmmf = new DMMFClass(config.document)\n\n        let cwd = path.resolve(config.dirname, config.relativePath)\n\n        if (!fs.existsSync(cwd)) {\n          cwd = config.dirname\n        }\n\n        const previewFeatures = config.generator?.previewFeatures ?? []\n\n        this._engineConfig = {\n          cwd,\n          enableDebugLogs: useDebug,\n          enableEngineDebugMode: engineConfig.enableEngineDebugMode,\n          datamodelPath: path.join(config.dirname, 'schema.prisma'),\n          prismaPath: engineConfig.binaryPath ?? undefined,\n          engineEndpoint: engineConfig.endpoint,\n          datasources,\n          generator: config.generator,\n          showColors: this._errorFormat === 'pretty',\n          logLevel: options.log && (getLogLevel(options.log) as any), // TODO\n          logQueries:\n            options.log &&\n            Boolean(\n              typeof options.log === 'string'\n                ? options.log === 'query'\n                : options.log.find((o) =>\n                  typeof o === 'string' ? o === 'query' : o.level === 'query',\n                ),\n            ),\n          env: envFile,\n          flags: [],\n          clientVersion: config.clientVersion,\n          enableExperimental: mapPreviewFeatures(previewFeatures),\n          useUds: internal.useUds,\n        }\n\n        const sanitizedEngineConfig = omit(this._engineConfig, [\n          'env',\n          'datasources',\n        ])\n        debug({ engineConfig: sanitizedEngineConfig })\n\n        this._engine = new NodeEngine(this._engineConfig)\n        this._fetcher = new PrismaClientFetcher(this, false, this._hooks)\n\n        if (options.log) {\n          for (const log of options.log) {\n            const level =\n              typeof log === 'string'\n                ? log\n                : log.emit === 'stdout'\n                  ? log.level\n                  : null\n            if (level) {\n              this.$on(level, (event) => {\n                const colorMap = {\n                  query: 'blue',\n                  info: 'cyan',\n                  warn: 'yellow',\n                  error: 'red',\n                }\n                console.error(\n                  chalk[colorMap[level]](`prisma:${level}`.padEnd(13)) +\n                  (event.message || event.query),\n                )\n              })\n            }\n          }\n        }\n\n        this._bootstrapClient()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private readEnv() {\n      const dotEnvPath = path.resolve(\n        config.dirname,\n        config.relativePath,\n        '.env',\n      )\n      if (fs.existsSync(dotEnvPath)) {\n        return dotenvExpand(dotenv.config({ path: dotEnvPath })).parsed\n      }\n\n      return {}\n    }\n    use(...args) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.use() is deprecated, please use prisma.$use() instead`,\n      )\n      return (this.$use as any)(...args)\n    }\n    $use(cb: Middleware)\n    $use(namespace: 'all', cb: Middleware)\n    $use(namespace: 'engine', cb: EngineMiddleware)\n    $use(\n      namespace: HookPoint | Middleware,\n      cb?: Middleware | EngineMiddleware,\n    ) {\n      if (typeof namespace === 'function') {\n        this._middlewares.push(namespace)\n      } else if (typeof namespace === 'string') {\n        if (namespace === 'all') {\n          this._middlewares.push(cb! as Middleware)\n        } else if (namespace === 'engine') {\n          this._engineMiddlewares.push(cb! as EngineMiddleware)\n        } else {\n          throw new Error(`Unknown middleware hook ${namespace}`)\n        }\n      } else {\n        throw new Error(`Invalid middleware ${namespace}`)\n      }\n    }\n    on(eventType: any, callback: (event: any) => void) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.on() is deprecated, please use prisma.$on() instead`,\n      )\n      return this.$on(eventType, callback)\n    }\n    $on(eventType: any, callback: (event: any) => void) {\n      if (eventType === 'beforeExit') {\n        this._engine.on('beforeExit', callback)\n      } else {\n        this._engine.on(eventType, (event) => {\n          const fields = event.fields\n          if (eventType === 'query') {\n            return callback({\n              timestamp: event.timestamp,\n              query: fields.query,\n              params: fields.params,\n              duration: fields.duration_ms,\n              target: event.target,\n            })\n          } else {\n            // warn, info, or error events\n            return callback({\n              timestamp: event.timestamp,\n              message: fields.message,\n              target: event.target,\n            })\n          }\n        })\n      }\n    }\n    connect() {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.connect() is deprecated, please use prisma.$connect() instead`,\n      )\n      return this.$connect()\n    }\n    async $connect() {\n      try {\n        return this._engine.start()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n    /**\n     * @private\n     */\n    async _runDisconnect() {\n      await this._engine.stop()\n      delete this._connectionPromise\n      this._engine = new NodeEngine(this._engineConfig)\n      delete this._disconnectionPromise\n      delete this._getConfigPromise\n    }\n    disconnect() {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.disconnect() is deprecated, please use prisma.$disconnect() instead`,\n      )\n      return this.$disconnect()\n    }\n    /**\n     * Disconnect from the database\n     */\n    async $disconnect() {\n      try {\n        return this._engine.stop()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private async _getActiveProvider(): Promise<ConnectorType> {\n      const configResult = await this._engine.getConfig()\n      return configResult.datasources[0].activeProvider!\n    }\n\n    executeRaw(stringOrTemplateStringsArray, ...values) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.executeRaw() is deprecated, please use prisma.$executeRaw() instead`,\n      )\n      return this.$executeRaw(stringOrTemplateStringsArray, ...values)\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    private async $executeRawInternal(stringOrTemplateStringsArray, ...values) {\n      let query = ''\n      let parameters: any = undefined\n\n      const activeProvider = await this._getActiveProvider()\n\n      if (typeof stringOrTemplateStringsArray === 'string') {\n        // If this was called as prisma.$executeRaw(<SQL>, [...values]), assume it is a pre-prepared SQL statement, and forward it without any changes\n        query = stringOrTemplateStringsArray\n        parameters = {\n          values: serializeRawParameters(values || []),\n          __prismaRawParamaters__: true,\n        }\n      } else if (Array.isArray(stringOrTemplateStringsArray)) {\n        // If this was called as prisma.$executeRaw`<SQL>`, try to generate a SQL prepared statement\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.sql\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'postgresql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.text\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'sqlserver': {\n            query = mssqlPreparedStatement(stringOrTemplateStringsArray)\n            parameters = {\n              values: serializeRawParameters(values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n        }\n      } else {\n        // If this was called as prisma.raw(sql`<SQL>`), use prepared statements from sql-template-tag\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).sql\n            break\n          case 'postgresql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).text\n            break\n          case 'sqlserver':\n            query = mssqlPreparedStatement(\n              (stringOrTemplateStringsArray as sqlTemplateTag.Sql).strings,\n            )\n            break\n        }\n        parameters = {\n          values: serializeRawParameters(\n            (stringOrTemplateStringsArray as sqlTemplateTag.Sql).values,\n          ),\n          __prismaRawParamaters__: true,\n        }\n      }\n\n      if (parameters?.values) {\n        debug(`prisma.$executeRaw(${query}, ${parameters.values})`)\n      } else {\n        debug(`prisma.$executeRaw(${query})`)\n      }\n\n      const args = { query, parameters }\n\n      debug(`Prisma Client call:`)\n      return this._request({\n        args,\n        clientMethod: 'executeRaw',\n        dataPath: [],\n        action: 'executeRaw',\n        callsite: this._getCallsite(),\n        runInTransaction: false,\n      })\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    $executeRaw(stringOrTemplateStringsArray, ...values) {\n      try {\n        const promise = this.$executeRawInternal(stringOrTemplateStringsArray, ...values)\n          ; (promise as any).isExecuteRaw = true\n        return promise\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _getCallsite() {\n      if (this._errorFormat !== 'minimal') {\n        return new Error().stack\n      }\n      return undefined\n    }\n\n    queryRaw(stringOrTemplateStringsArray, ...args) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.queryRaw() is deprecated, please use prisma.$queryRaw() instead`,\n      )\n      return this.$queryRaw(stringOrTemplateStringsArray, ...args)\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    private async $queryRawInternal(\n      stringOrTemplateStringsArray:\n        | string\n        | TemplateStringsArray\n        | sqlTemplateTag.Sql,\n      ...values: any[]\n    ) {\n      let query = ''\n      let parameters: any = undefined\n\n      const activeProvider = await this._getActiveProvider()\n\n      if (typeof stringOrTemplateStringsArray === 'string') {\n        // If this was called as prisma.$queryRaw(<SQL>, [...values]), assume it is a pre-prepared SQL statement, and forward it without any changes\n        query = stringOrTemplateStringsArray\n        parameters = {\n          values: serializeRawParameters(values || []),\n          __prismaRawParamaters__: true,\n        }\n      } else if (Array.isArray(stringOrTemplateStringsArray)) {\n        // If this was called as prisma.$queryRaw`<SQL>`, try to generate a SQL prepared statement\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.sql\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'postgresql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.text\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'sqlserver': {\n            query = mssqlPreparedStatement(stringOrTemplateStringsArray)\n            parameters = {\n              values: serializeRawParameters(values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n        }\n      } else {\n        // If this was called as prisma.raw(sql`<SQL>`), use prepared statements from sql-template-tag\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).sql\n            break\n          case 'postgresql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).text\n            break\n          case 'sqlserver':\n            query = mssqlPreparedStatement(\n              (stringOrTemplateStringsArray as sqlTemplateTag.Sql).strings,\n            )\n            break\n        }\n        parameters = {\n          values: serializeRawParameters(\n            (stringOrTemplateStringsArray as sqlTemplateTag.Sql).values,\n          ),\n          __prismaRawParamaters__: true,\n        }\n      }\n\n      if (parameters?.values) {\n        debug(`prisma.queryRaw(${query}, ${parameters.values})`)\n      } else {\n        debug(`prisma.queryRaw(${query})`)\n      }\n\n      const args = { query, parameters }\n\n      debug(`Prisma Client call:`)\n      return this._request({\n        args,\n        clientMethod: 'queryRaw',\n        dataPath: [],\n        action: 'queryRaw',\n        callsite: this._getCallsite(),\n        runInTransaction: false,\n      })\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    $queryRaw(stringOrTemplateStringsArray, ...values) {\n      try {\n        const promise = this.$queryRawInternal(stringOrTemplateStringsArray, ...values)\n          ; (promise as any).isQueryRaw = true\n        return promise\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    async __internal_triggerPanic(fatal: boolean) {\n      if (!this._engineConfig.enableEngineDebugMode) {\n        throw new Error(`In order to use .__internal_triggerPanic(), please enable the debug mode like so:\nnew PrismaClient({\n  __internal: {\n    engine: {\n      enableEngineDebugMode: true\n    }\n  }\n})`)\n      }\n\n      const query = 'SELECT 1'\n\n      const headers: Record<string, string> = fatal\n        ? { 'X-DEBUG-FATAL': '1' }\n        : { 'X-DEBUG-NON-FATAL': '1' }\n\n      return this._request({\n        action: 'queryRaw',\n        args: {\n          query,\n          parameters: undefined,\n        },\n        clientMethod: 'queryRaw',\n        dataPath: [],\n        runInTransaction: false,\n        headers,\n        callsite: this._getCallsite(),\n      })\n    }\n\n    transaction(promises) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.transaction() is deprecated, please use prisma.$transaction() instead`,\n      )\n      return this.$transaction(promises)\n    }\n\n    private async $transactionInternal(promises: Array<any>): Promise<any> {\n      if (config.generator?.previewFeatures?.includes('transactionApi')) {\n        for (const p of promises) {\n          if (!p) {\n            throw new Error(\n              `All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`,\n            )\n          }\n          if (p?.isQueryRaw) {\n            throw new Error(`$queryRaw is not yet supported within $transaction.\nPlease report in https://github.com/prisma/prisma/issues/3828 if you need this feature.`)\n          }\n          if (p?.isExecuteRaw) {\n            throw new Error(`$executeRaw is not yet supported within $transaction.\nPlease report in https://github.com/prisma/prisma/issues/3828 if you need this feature`)\n          }\n          if (\n            !p.requestTransaction ||\n            typeof p.requestTransaction !== 'function'\n          ) {\n            throw new Error(\n              `All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`,\n            )\n          }\n        }\n        return Promise.all(promises.map((p) => p.requestTransaction()))\n      } else {\n        throw new Error(\n          `In order to use the .transaction() api, please enable 'previewFeatures = \"transactionApi\" in your schema.`,\n        )\n      }\n    }\n\n    async $transaction(promises: Array<any>): Promise<any> {\n      try {\n        return this.$transactionInternal(promises)\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _request(internalParams: InternalRequestParams) {\n      try {\n        const resource = new AsyncResource('prisma-client-request')\n        if (this._middlewares.length > 0) {\n          // https://perf.link/#eyJpZCI6Img4bmd0anp5eGxrIiwidGl0bGUiOiJGaW5kaW5nIG51bWJlcnMgaW4gYW4gYXJyYXkgb2YgMTAwMCIsImJlZm9yZSI6ImNvbnN0IGRhdGEgPSB7XG4gIG9wZXJhdGlvbjogXCJxdWVyeVwiLFxuICByb290RmllbGQ6IFwiZmluZE1hbnlVc2VyXCIsXG4gIGFyZ3M6IHtcbiAgICB3aGVyZTogeyBpZDogeyBndDogNSB9IH1cbiAgfSxcbiAgZGF0YVBhdGg6IFtdLFxuICBjbGllbnRNZXRob2Q6ICd1c2VyLmZpbmRNYW55J1xufSIsInRlc3RzIjpbeyJuYW1lIjoiZm9yIGluIiwiY29kZSI6ImNvbnN0IG5ld0RhdGEgPSB7fVxuZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICBpZiAoa2V5ICE9PSAnY2xpZW50TWV0aG9kJykge1xuICAgIG5ld0RhdGFba2V5XSA9IGRhdGFba2V5XVxuICB9XG59IiwicnVucyI6WzU1MzAwMCw0OTAwMDAsMzQ0MDAwLDYyNDAwMCwxMzkxMDAwLDEyMjQwMDAsMTA2NDAwMCwxMjE3MDAwLDc0MDAwLDM3MzAwMCw5MDUwMDAsNTM3MDAwLDE3MDYwMDAsOTAzMDAwLDE0MjUwMDAsMTMxMjAwMCw3NjkwMDAsMTM0NTAwMCwxOTQ4MDAwLDk5MDAwMCw5MDAwMDAsMTM0ODAwMCwxMDk2MDAwLDM4NjAwMCwxNTE3MDAwLDE5MzYwMDAsMTAwMCwyMTM0MDAwLDEzMjgwMDAsODI5MDAwLDE1ODYwMDAsMTc2MzAwMCw1MDgwMDAsOTg2MDAwLDE5NDkwMDAsMjEwODAwMCwxNjA4MDAwLDIyNDAwMCwxOTAyMDAwLDEyNjgwMDAsMjEzNDAwMCwxNzEwMDAwLDEzNzIwMDAsMjExMDAwMCwxNzgwMDAwLDc3NzAwMCw1NzgwMDAsNDAwMCw4OTAwMDAsMTEwMTAwMCwxNTk0MDAwLDE3ODAwMDAsMzU0MDAwLDU0NDAwMCw4MjQwMDAsNzEwMDAwLDg0OTAwMCwxNjQwMDAwLDE5ODQwMDAsNzAzMDAwLDg4MjAwMCw4NTAwMDAsMTA2MDAwLDMwMzAwMCwxMzMwMDAsNjA4MDAwLDIxMzQwMDAsNTUxMDAwLDc0MjAwMCwyMDcwMDAsMTU3NTAwMCwxMzQwMDAsNDAwMCwxMDAwLDQ5NDAwMCwyNTAwMDAsMTQwMjAwMCw2OTgwMDAsNTgxMDAwLDQ4MDAwMCwyMDMwMDAsMTY4MzAwMCwxNjcxMDAwLDEyNDAwMDAsMTk1NjAwMCwzMDUwMDAsODkwMDAsNjUzMDAwLDE3MDgwMDAsMTYwMTAwMCwxOTg0MDAwLDg4ODAwMCwyMTAwMDAwLDE5NzUwMDAsNTM2MDAwLDU3NTAwMCwyMTM0MDAwLDEwMTcwMDAsMTI5NzAwMCw3NTYwMDBdLCJvcHMiOjEwNDUxNTB9LHsibmFtZSI6IkRlY29uc3RydWN0b3IiLCJjb2RlIjoiY29uc3QgeyBjbGllbnRNZXRob2QsIC4uLnJlc3QgfSA9IGRhdGEiLCJydW5zIjpbMjE0MDAwLDUxMDAwLDg2NDAwMCw3MjcwMDAsNDMxMDAwLDIyMDAwMCwzOTAwMDAsODQxMDAwLDIyOTAwMCw3MjIwMDAsNDEzMDAwLDYwODAwMCwyOTgwMDAsMzY4MDAwLDg2NDAwMCw5MjQwMDAsMTI4MDAwLDU1MzAwMCw4ODAwMDAsNTQ1MDAwLDc3NTAwMCw0MzAwMDAsMjM3MDAwLDc4NjAwMCw1NTUwMDAsNTI2MDAwLDMyNzAwMCw2MzAwMCw5MTIwMDAsMTgxMDAwLDMzMTAwMCw0MzAwMCwyMjUwMDAsNTQ3MDAwLDgyMjAwMCw3OTMwMDAsMTA1NzAwMCw1NjAwMCwyNzUwMDAsMzkzMDAwLDgwNTAwMCw5MzAwMCw3NjYwMDAsODM0MDAwLDUwMzAwMCw4MDAwMCwyMzgwMDAsNDY0MDAwLDU2NDAwMCw3MzAwMDAsOTU1MDAwLDgwOTAwMCwyMDMwMDAsNDEzMDAwLDM0NDAwMCw1MDIwMDAsNjEzMDAwLDEwMDAwMCw0MzIwMDAsNjcwMDAwLDQ1MzAwMCw4OTEwMDAsNTUwMDAsMjMwMDAwLDM5MTAwMCw3NTQwMDAsMTEyMjAwMCw3NjIwMDAsMzU3MDAwLDQ3MDAwLDc5MjAwMCwzNTQwMDAsMTA4MDAwMCwxNjAwMCwxODgwMDAsMTQxMDAwLDIxMDAwMCw2MDcwMDAsOTAyMDAwLDgyNTAwMCwxOTAwMDAsMjMzMDAwLDI4MzAwMCwyMzgwMDAsNjk2MDAwLDc2ODAwMCw3NTgwMDAsMTk0MDAwLDI3OTAwMCwyMjMwMDAsMjM4MDAwLDkzNDAwMCw2MDUwMDAsMTcwMDAsMjEwMDAwLDMyMjAwMCwxMDM0MDAwLDgxMjAwMCw0NDYwMDAsNjMxMDAwXSwib3BzIjo0OTAxMDB9LHsibmFtZSI6ImRlbGV0ZSIsImNvZGUiOiJjb25zdCB7IGNsaWVudE1ldGhvZCB9ID0gZGF0YVxuZGVsZXRlIGRhdGEuY2xpZW50TWV0aG9kIiwicnVucyI6WzI3NjIwMDAsNjIyMDAwLDEwNTcwMDAsMzIzMTAwMCwzNDQ2MDAwLDIwNzMwMDAsMzM4MjAwMCwyNzA0MDAwLDM4ODEwMDAsMTIwMTAwMCwzNzk3MDAwLDI1OTAwMCwxMDI4MDAwLDI1MTgwMDAsMjEwMjAwMCwxOTczMDAwLDM0MTIwMDAsMzU4MDAwLDExNDcwMDAsMTA3NDAwMCwzMTk1MDAwLDM2NzUwMDAsNTQ3MDAwLDIwNzkwMDAsMjc0NTAwMCwyNDE1MDAwLDIxOTAwMCwzNzM3MDAwLDM2OTIwMDAsMTY0MDAwLDI0MzMwMDAsNjQzMDAwLDcxODAwMCw0Mzg2MDAwLDE3MDIwMDAsMTAyNDAwMCw1NjUwMDAsNDIxOTAwMCwxMTk3MDAwLDE4MzkwMDAsMzgyMTAwMCwxMTUyMDAwLDg1MzAwMCwxMzczMDAwLDI5NTAwMCwxNDg5MDAwLDE0MjEwMDAsMjcyNDAwMCw1MDYxMDAwLDI2NTcwMDAsMjYzNzAwMCwyOTkwMDAsMjE1NzAwMCwxNTAxMDAwLDM2OTAwMDAsMzU3OTAwMCw0MjE5MDAwLDI4NTgwMDAsNTI0MzAwMCwxNTA0MDAwLDEyMTMwMDAsMjM4NDAwMCw3NzgwMDAsMjgyNjAwMCwxNzQ5MDAwLDM2MjAwMCwyNzEzMDAwLDMzODYwMDAsMzE2NjAwMCwxNTMwMDAsNzk0MDAwLDMyMTcwMDAsMjA4MjAwMCw0MTUwMDAsMzMyMDAwMCwyMTA1MDAwLDE1NzYwMDAsMjUxMDAwLDIzMjkwMDAsOTI1MDAwLDM3MTUwMDAsNjkyMDAwLDE5MDIwMDAsMjA0NzAwMCwyNTM5MDAwLDIwMjkwMDAsMzE3OTAwMCwyMTA2MDAwLDg5NTAwMCwxNTUwMDAwLDYwNzAwMCw0MTA1MDAwLDM0ODMwMDAsMzcxNTAwMCw0OTQwMDAwLDIyODAwMCw0MDI2MDAwLDE2MTYwMDAsMzMxNDAwMCwyNDIyMDAwXSwib3BzIjoyMTY2MDgwfSx7Im5hbWUiOiJDcmVhdGUgbmV3IG9iamVjdCIsImNvZGUiOiJjb25zdCBuZXdEYXRhID0ge1xuICBvcGVyYXRpb246IGRhdGEub3BlcmF0aW9uLFxuICByb290RmllbGQ6IGRhdGEucm9vdEZpZWxkLFxuICBhcmdzOiBkYXRhLmFyZ3MsXG4gIGRhdGFQYXRoOiBkYXRhLmRhdGFQYXRoXG59IiwicnVucyI6WzcwNTAwMCwxMTAwMDAsMzI3NTAwMCwxOTgwMDAsMjE5OTAwMCw0MzYwMDAsODI4MDAwLDI5MjcwMDAsNzI0MDAwLDI1NDAwMCwyOTgzMDAwLDI2NzIwMDAsMjUzMDAwLDI4MjcwMDAsMzA0ODAwMCwyOTA3MDAwLDM0OTkwMDAsMjY1OTAwMCwzODIyMDAwLDI3NzcwMDAsMzc5NzAwMCw4MDAwMDAsNDM1MDAwLDExOTMwMDAsMTAwMDAsMTQ0MDAwMCw3NTcwMDAsMTMyMDAwMCwzMjIwMDAsMjA3MDAwLDM2ODAwMDAsMzkxMTAwMCwzMjQxMDAwLDExMDcwMDAsNDM4MDAwLDMwNDQwMDAsMTA3NjAwMCwyMTAwMDAsNDIxOTAwMCwzNzQ4MDAwLDQwNjcwMDAsNzc0MDAwLDYzMDAwLDMyMTAwMCwzMDQ4MDAwLDMxMjgwMDAsMTg3MTAwMCwzNTkxMDAwLDI0MzcwMDAsNjcxMDAwLDc5OTAwMCwxMTUzMDAwLDIxMTMwMDAsOTUwMDAsNTg3MDAwLDYyMzAwMCwxMzEzMDAwLDMxNTgwMDAsMzMyNzAwMCwxNTkwMDAsNDg4MDAwLDIxMTAwMCwxMjk0MDAwLDExNTcwMDAsNDA0MDAwLDM2MjMwMDAsMjY4NDAwMCw4NzkwMDAsMjE4NTAwMCwxNTkyMDAwLDM2ODcwMDAsMjI0ODAwMCwyMjE4MDAwLDE3NDMwMDAsNzg4MDAwLDQwODYwMDAsMjExNTAwMCwzOTE0MDAwLDM5MjgwMDAsNDM3MjAwMCwxOTkwMDAsMzc1MzAwMCwzNjQ3MDAwLDE2MjcwMDAsMTQ5OTAwMCwxODQyMDAwLDIxMjkwMDAsNDAwMCwxMjIzMDAwLDI4NjMwMDAsMzgzNDAwMCwzNjk0MDAwLDYzNjAwMCw0MjQ3MDAwLDQwMjIwMDAsMTAwMDAsMTcxNDAwMCwxNzUwMDAwLDI5MDEwMDAsMTM0NjAwMF0sIm9wcyI6MTkzOTEyMH1dLCJ1cGRhdGVkIjoiMjAyMC0wNy0xNVQxMTowMDo1Ny45MzhaIn0%3D\n          const params: MiddlewareParams = {\n            args: internalParams.args,\n            dataPath: internalParams.dataPath,\n            runInTransaction: internalParams.runInTransaction,\n            action: internalParams.action,\n            model: internalParams.model,\n          }\n          return resource.runInAsyncScope(() =>\n            this._requestWithMiddlewares(\n              params,\n              this._middlewares.slice(),\n              internalParams.clientMethod,\n              internalParams.callsite,\n              internalParams.headers,\n            ),\n          )\n        }\n\n        return resource.runInAsyncScope(() =>\n          this._executeRequest(internalParams),\n        )\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _requestWithMiddlewares(\n      params: MiddlewareParams,\n      middlewares: Middleware[],\n      clientMethod: string,\n      callsite?: string,\n      headers?: Record<string, string>,\n    ) {\n      const middleware = middlewares.shift()\n      if (middleware) {\n        return middleware(params, (params2) =>\n          this._requestWithMiddlewares(\n            params2,\n            middlewares,\n            clientMethod,\n            callsite,\n          ),\n        )\n      }\n\n      // No, we won't copy the whole object here just to make it easier to do TypeScript\n      // as it would be much slower\n      ; (params as InternalRequestParams).clientMethod = clientMethod\n        ; (params as InternalRequestParams).callsite = callsite\n        ; (params as InternalRequestParams).headers = headers\n\n      return this._executeRequest(params as InternalRequestParams)\n    }\n\n    private _executeRequest({\n      args,\n      clientMethod,\n      dataPath,\n      callsite,\n      runInTransaction,\n      action,\n      model,\n      headers,\n    }: InternalRequestParams) {\n      if (action !== 'executeRaw' && action !== 'queryRaw' && !model) {\n        throw new Error(`Model missing for action ${action}`)\n      }\n\n      if ((action === 'executeRaw' || action === 'queryRaw') && model) {\n        throw new Error(\n          `executeRaw and queryRaw can't be executed on a model basis. The model ${model} has been provided`,\n        )\n      }\n\n      let rootField: string | undefined\n      const operation = actionOperationMap[action]\n\n      if (action === 'executeRaw' || action === 'queryRaw') {\n        rootField = action\n      }\n\n      // TODO: Replace with lookup map for speedup\n      let mapping\n      if (model) {\n        mapping = this._dmmf.mappingsMap[model]\n        if (!mapping) {\n          throw new Error(`Could not find mapping for model ${model}`)\n        }\n\n        rootField = mapping[action]\n      }\n\n      if (operation !== 'query' && operation !== 'mutation') {\n        throw new Error(`Invalid operation ${operation} for action ${action}`)\n      }\n\n      const field = this._dmmf.rootFieldMap[rootField!]\n\n      if (!field) {\n        throw new Error(\n          `Could not find rootField ${rootField} for action ${action} for model ${model} on rootType ${operation}`,\n        )\n      }\n\n      const { isList } = field.outputType\n      const typeName = getOutputTypeName(field.outputType.type)\n\n      let document = makeDocument({\n        dmmf: this._dmmf,\n        rootField: rootField!,\n        rootTypeName: operation,\n        select: args,\n      })\n\n      document.validate(args, false, clientMethod, this._errorFormat, callsite)\n\n      document = transformDocument(document)\n\n      // as printJsonWithErrors takes a bit of compute\n      // we only want to do it, if debug is enabled for 'prisma-client'\n      if (Debug.enabled('prisma-client')) {\n        const query = String(document)\n        debug(`Prisma Client call:`)\n        debug(\n          `prisma.${clientMethod}(${printJsonWithErrors({\n            ast: args,\n            keyPaths: [],\n            valuePaths: [],\n            missingItems: [],\n          })})`,\n        )\n        debug(`Generated request:`)\n        debug(query + '\\n')\n      }\n\n      return this._fetcher.request({\n        document,\n        clientMethod,\n        typeName,\n        dataPath,\n        isList,\n        rootField: rootField!,\n        callsite,\n        showColors: this._errorFormat === 'pretty',\n        args,\n        engineHook: this._engineMiddlewares[0],\n        runInTransaction,\n        headers,\n      })\n    }\n\n    private _bootstrapClient() {\n      const clients = this._dmmf.mappings.reduce((acc, mapping) => {\n        const lowerCaseModel = lowerCase(mapping.model)\n        const model = this._dmmf.modelMap[mapping.model]\n\n        if (!model) {\n          throw new Error(`Invalid mapping ${mapping.model}, can't find model`)\n        }\n\n        const prismaClient = ({\n          operation,\n          actionName,\n          args,\n          dataPath,\n          modelName,\n        }) => {\n          dataPath = dataPath ?? []\n\n          const clientMethod = `${lowerCaseModel}.${actionName}`\n\n          let requestPromise: Promise<any>\n          const callsite = this._getCallsite()\n\n          const requestModelName = modelName ?? model.name\n\n          const clientImplementation = {\n            then: (onfulfilled, onrejected) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.then(onfulfilled, onrejected)\n            },\n            requestTransaction: () => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: true,\n                })\n              }\n\n              return requestPromise\n            },\n            catch: (onrejected) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.catch(onrejected)\n            },\n            finally: (onfinally) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.finally(onfinally)\n            },\n          }\n\n          // add relation fields\n          for (const field of model.fields.filter((f) => f.kind === 'object')) {\n            clientImplementation[field.name] = (fieldArgs) => {\n              const prefix = dataPath.includes('select')\n                ? 'select'\n                : dataPath.includes('include')\n                  ? 'include'\n                  : 'select'\n              const newDataPath = [...dataPath, prefix, field.name]\n              const newArgs = deepSet(args, newDataPath, fieldArgs || true)\n\n              return clients[field.type]({\n                operation,\n                actionName,\n                args: newArgs,\n                dataPath: newDataPath,\n                isList: field.isList,\n                /*\n                 * necessary for user.posts() calls -> the original model name needs to be preserved\n                 */\n                modelName: modelName || model.name,\n              })\n            }\n          }\n\n          return clientImplementation\n        }\n\n        acc[model.name] = prismaClient\n\n        return acc\n      }, {})\n\n      for (const mapping of this._dmmf.mappings) {\n        const lowerCaseModel = lowerCase(mapping.model)\n\n        const denyList = {\n          model: true,\n          plural: true,\n          aggregate: true,\n        }\n\n        const delegate: any = Object.entries(mapping).reduce(\n          (acc, [actionName, rootField]) => {\n            if (!denyList[actionName]) {\n              const operation = getOperation(actionName as any)\n              acc[actionName] = (args) =>\n                clients[mapping.model]({\n                  operation,\n                  actionName,\n                  args,\n                })\n            }\n\n            return acc\n          },\n          {},\n        )\n\n        delegate.count = (args) => {\n          return clients[mapping.model]({\n            operation: 'query',\n            actionName: `aggregate`,\n            args: args\n              ? {\n                ...args,\n                select: { count: true },\n              }\n              : undefined,\n            dataPath: ['count'],\n          })\n        }\n\n        delegate.aggregate = (args) => {\n          /**\n           * avg, count, sum, min, max need to go into select\n           * For speed reasons we can go with \"for in \"\n           */\n          const select = Object.entries(args).reduce((acc, [key, value]) => {\n            if (aggregateKeys[key]) {\n              if (!acc.select) {\n                acc.select = {}\n              }\n              // `count` doesn't have a sub-selection\n              if (key === 'count') {\n                acc.select[key] = value\n              } else {\n                acc.select[key] = { select: value }\n              }\n            } else {\n              acc[key] = value\n            }\n            return acc\n          }, {} as any)\n\n          return clients[mapping.model]({\n            operation: 'query',\n            actionName: 'aggregate', // actionName is just cosmetics \uD83D\uDC85\uD83C\uDFFD\n            rootField: mapping.aggregate,\n            args: select,\n            dataPath: [],\n          })\n        }\n\n        this[lowerCaseModel] = delegate\n      }\n    }\n  }\n\n  return NewPrismaClient\n}\n\nexport class PrismaClientFetcher {\n  prisma: any\n  debug: boolean\n  hooks: any\n  dataloader: Dataloader<{\n    document: Document\n    runInTransaction?: boolean\n    headers?: Record<string, string>\n  }>\n\n  constructor(prisma, enableDebug = false, hooks?: any) {\n    this.prisma = prisma\n    this.debug = enableDebug\n    this.hooks = hooks\n    this.dataloader = new Dataloader({\n      batchLoader: async (requests) => {\n        const queries = requests.map((r) => String(r.document))\n        const runTransaction = requests[0].runInTransaction\n        return this.prisma._engine.requestBatch(queries, runTransaction)\n      },\n      singleLoader: async (request) => {\n        const query = String(request.document)\n        return this.prisma._engine.request(query, request.headers)\n      },\n      batchBy: (request) => {\n        if (request.runInTransaction) {\n          return 'transaction-batch'\n        }\n\n        if (!request.document.children[0].name.startsWith('findOne')) {\n          return null\n        }\n\n        const selectionSet = request.document.children[0].children!.join(',')\n\n        const args = request.document.children[0].args?.args\n          .map((a) => {\n            if (a.value instanceof Args) {\n              return a.key + '-' + a.value.args.map((a) => a.key).join(',')\n            }\n            return a.key\n          })\n          .join(',')\n\n        return `${request.document.children[0].name}|${args}|${selectionSet}`\n      },\n    })\n  }\n\n  async request({\n    document,\n    dataPath = [],\n    rootField,\n    typeName,\n    isList,\n    callsite,\n    clientMethod,\n    runInTransaction,\n    showColors,\n    engineHook,\n    args,\n    headers,\n  }: {\n    document: Document\n    dataPath: string[]\n    rootField: string\n    typeName: string\n    isList: boolean\n    clientMethod: string\n    callsite?: string\n    runInTransaction?: boolean\n    showColors?: boolean\n    engineHook?: EngineMiddleware\n    args: any\n    headers?: Record<string, string>\n  }) {\n    if (this.hooks && this.hooks.beforeRequest) {\n      const query = String(document)\n      this.hooks.beforeRequest({\n        query,\n        path: dataPath,\n        rootField,\n        typeName,\n        document,\n        isList,\n        clientMethod,\n        args,\n      })\n    }\n    try {\n      /**\n       * If there's an engine hook, use it here\n       */\n      let data, elapsed\n      if (engineHook) {\n        const result = await engineHook(\n          {\n            document,\n            runInTransaction,\n          },\n          (params) => this.dataloader.request(params),\n        )\n        data = result.data\n        elapsed = result.elapsed\n      } else {\n        const result = await this.dataloader.request({\n          document,\n          runInTransaction,\n          headers,\n        })\n        data = result.data\n        elapsed = result.elapsed\n      }\n\n      /**\n       * Unpack\n       */\n      const unpackResult = this.unpack(document, data, dataPath, rootField)\n      if (process.env.PRISMA_CLIENT_GET_TIME) {\n        return { data: unpackResult, elapsed }\n      }\n      return unpackResult\n    } catch (e) {\n      debug(e)\n      let message = e.message\n      if (callsite) {\n        const { stack } = printStack({\n          callsite,\n          originalMethod: clientMethod,\n          onUs: e.isPanic,\n          showColors,\n        })\n        message = stack + '\\n  ' + e.message\n      }\n\n      message = this.sanitizeMessage(message)\n      // TODO: Do request with callsite instead, so we don't need to rethrow\n      if (e.code) {\n        throw new PrismaClientKnownRequestError(\n          message,\n          e.code,\n          this.prisma._clientVersion,\n          e.meta,\n        )\n      } else if (e.isPanic) {\n        throw new PrismaClientRustPanicError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientUnknownRequestError) {\n        throw new PrismaClientUnknownRequestError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientInitializationError) {\n        throw new PrismaClientInitializationError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientRustPanicError) {\n        throw new PrismaClientRustPanicError(\n          message,\n          this.prisma._clientVersion,\n        )\n      }\n\n      e.clientVersion = this.prisma._clientVersion\n\n      throw e\n    }\n  }\n\n  sanitizeMessage(message) {\n    if (this.prisma._errorFormat && this.prisma._errorFormat !== 'pretty') {\n      return stripAnsi(message)\n    }\n    return message\n  }\n  unpack(document, data, path, rootField) {\n    if (data.data) {\n      data = data.data\n    }\n    const getPath: any[] = []\n    if (rootField) {\n      getPath.push(rootField)\n    }\n    getPath.push(...path.filter((p) => p !== 'select' && p !== 'include'))\n    return unpack({ document, data, path: getPath })\n  }\n}\n\nexport function getOperation(action: DMMF.ModelAction): 'query' | 'mutation' {\n  if (\n    action === DMMF.ModelAction.findMany ||\n    action === DMMF.ModelAction.findOne ||\n    action === DMMF.ModelAction.findFirst\n  ) {\n    return 'query'\n  }\n  return 'mutation'\n}\n", "export const clientVersion = require('../../../package.json').version", "// Generate something like: SELECT * FROM User WHERE name = @P1 AND email = @P2 ...\nexport const mssqlPreparedStatement = (\n  template: string[] | TemplateStringsArray,\n) => {\n  return template.reduce((acc, str, idx) => `${acc}@P${idx}${str}`)\n}\n", "import { DMMFClass } from './dmmf'\nimport { DMMF } from './dmmf-types'\nimport path from 'path'\nimport {\n  PrismaClientKnownRequestError,\n  PrismaClientUnknownRequestError,\n  PrismaClientInitializationError,\n  PrismaClientRustPanicError,\n} from '.'\nimport {\n  NodeEngine,\n  EngineConfig,\n  DatasourceOverwrite,\n} from '@prisma/engine-core/dist/NodeEngine'\nimport {\n  Document,\n  makeDocument,\n  unpack,\n  transformDocument,\n  Args,\n} from './query'\nimport Debug from '@prisma/debug'\nconst debug = Debug('prisma-client')\nimport fs from 'fs'\nimport chalk from 'chalk'\nimport * as sqlTemplateTag from 'sql-template-tag'\nimport dotenv from 'dotenv'\nimport { dotenvExpand } from '@prisma/sdk/dist/dotenvExpand'\nimport {\n  GeneratorConfig,\n  DataSource,\n} from '@prisma/generator-helper/dist/types'\nimport { getLogLevel } from './getLogLevel'\nimport { mergeBy } from './mergeBy'\nimport { lowerCase, getOutputTypeName } from './utils/common'\nimport { deepSet } from './utils/deep-set'\nimport { Dataloader } from './Dataloader'\nimport { printStack } from './utils/printStack'\nimport stripAnsi from 'strip-ansi'\nimport { printJsonWithErrors } from './utils/printJsonErrors'\nimport { ConnectorType } from './utils/printDatasources'\nimport { omit } from './utils/omit'\nimport { mapPreviewFeatures } from '@prisma/sdk/dist/utils/mapPreviewFeatures'\nimport { serializeRawParameters } from './utils/serializeRawParameters'\nimport { AsyncResource } from 'async_hooks'\nimport { clientVersion } from './utils/clientVersion'\nimport { mssqlPreparedStatement } from './utils/mssqlPreparedStatement'\n\nexport type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n\nexport type Datasource = {\n  url?: string\n}\nexport type Datasources = Record<string, Datasource>\n\nexport interface PrismaClientOptions {\n  /**\n   * Overwrites the datasource url from your prisma.schema file\n   */\n  datasources?: Datasources\n\n  /**\n   * @default \"colorless\"\n   */\n  errorFormat?: ErrorFormat\n\n  /**\n   * @example\n   * \\`\\`\\`\n   * // Defaults to stdout\n   * log: ['query', 'info', 'warn']\n   *\n   * // Emit as events\n   * log: [\n   *  { emit: 'stdout', level: 'query' },\n   *  { emit: 'stdout', level: 'info' },\n   *  { emit: 'stdout', level: 'warn' }\n   * ]\n   * \\`\\`\\`\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n   */\n  log?: Array<LogLevel | LogDefinition>\n\n  /**\n   * @internal\n   * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\n   */\n  __internal?: {\n    debug?: boolean\n    hooks?: Hooks\n    useUds?: boolean\n    engine?: {\n      cwd?: string\n      binaryPath?: string\n      endpoint?: string\n      enableEngineDebugMode?: boolean\n    }\n  }\n}\n\nexport type HookParams = {\n  query: string\n  path: string[]\n  rootField?: string\n  typeName?: string\n  document: any\n  clientMethod: string\n  args: any\n}\n\n/**\n * These options are being passed in to the middleware as \"params\"\n */\nexport type MiddlewareParams = {\n  model?: string\n  action: Action\n  args: any\n  dataPath: string[]\n  runInTransaction: boolean\n}\n\n/**\n * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation\n */\nexport type Middleware<T = any> = (\n  params: MiddlewareParams,\n  next: (params: MiddlewareParams) => Promise<T>,\n) => Promise<T>\n\nexport interface InternalRequestParams extends MiddlewareParams {\n  /**\n   * The original client method being called.\n   * Even though the rootField / operation can be changed,\n   * this method stays as it is, as it's what the user's\n   * code looks like\n   */\n  clientMethod: string\n  callsite?: string\n  headers?: Record<string, string>\n}\n\nexport type HookPoint = 'all' | 'engine'\n\nexport type EngineMiddlewareParams = {\n  document: Document\n  runInTransaction?: boolean\n}\n\n// only used by the .use() hooks\nexport type AllHookArgs = {\n  params: HookParams\n  fetch: (params: HookParams) => Promise<any>\n}\n/**\n * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation\n */\nexport type EngineMiddleware<T = any> = (\n  params: EngineMiddlewareParams,\n  next: (params: EngineMiddlewareParams) => Promise<T>,\n) => Promise<T>\n\nexport type Hooks = {\n  beforeRequest?: (options: HookParams) => any\n}\n\n/* Types for Logging */\nexport type LogLevel = 'info' | 'query' | 'warn' | 'error'\nexport type LogDefinition = {\n  level: LogLevel\n  emit: 'stdout' | 'event'\n}\n\nexport type GetLogType<\n  T extends LogLevel | LogDefinition\n  > = T extends LogDefinition\n  ? T['emit'] extends 'event'\n  ? T['level']\n  : never\n  : never\nexport type GetEvents<T extends Array<LogLevel | LogDefinition>> =\n  | GetLogType<T[0]>\n  | GetLogType<T[1]>\n  | GetLogType<T[2]>\n\nexport type QueryEvent = {\n  timestamp: Date\n  query: string\n  params: string\n  duration: number\n  target: string\n}\n\nexport type LogEvent = {\n  timestamp: Date\n  message: string\n  target: string\n}\n/* End Types for Logging */\n\nexport interface GetPrismaClientOptions {\n  document: DMMF.Document\n  generator?: GeneratorConfig\n  sqliteDatasourceOverrides?: DatasourceOverwrite[]\n  relativePath: string\n  dirname: string\n  clientVersion?: string\n  engineVersion?: string\n}\n\nexport type Action =\n  | 'findOne'\n  | 'findFirst'\n  | 'findMany'\n  | 'create'\n  | 'update'\n  | 'updateMany'\n  | 'upsert'\n  | 'delete'\n  | 'deleteMany'\n  | 'executeRaw'\n  | 'queryRaw'\n  | 'aggregate'\n\nconst actionOperationMap = {\n  findOne: 'query',\n  findFirst: 'query',\n  findMany: 'query',\n  count: 'query',\n  create: 'mutation',\n  update: 'mutation',\n  updateMany: 'mutation',\n  upsert: 'mutation',\n  delete: 'mutation',\n  deleteMany: 'mutation',\n  executeRaw: 'mutation',\n  queryRaw: 'mutation',\n  aggregate: 'query',\n}\n\nconst aggregateKeys = {\n  avg: true,\n  count: true,\n  sum: true,\n  min: true,\n  max: true,\n}\n\n// TODO: We **may** be able to get real types. However, we have both a bootstrapping\n// problem here, that we want to return a type that's not yet defined\n// and we're typecasting this anyway later\nexport function getPrismaClient(config: GetPrismaClientOptions): any {\n  class NewPrismaClient {\n    _dmmf: DMMFClass\n    _engine: NodeEngine\n    _fetcher: PrismaClientFetcher\n    _connectionPromise?: Promise<any>\n    _disconnectionPromise?: Promise<any>\n    _engineConfig: EngineConfig\n    private _errorFormat: ErrorFormat\n    private _hooks?: Hooks\n    private _getConfigPromise?: Promise<{\n      datasources: DataSource[]\n      generators: GeneratorConfig[]\n    }>\n    private _middlewares: Middleware[] = []\n    private _engineMiddlewares: EngineMiddleware[] = []\n    private _clientVersion: string\n    constructor(optionsArg?: PrismaClientOptions) {\n      this._clientVersion = config.clientVersion ?? clientVersion\n      try {\n        const options: PrismaClientOptions = optionsArg ?? {}\n        const internal = options.__internal ?? {}\n\n        const useDebug = internal.debug === true\n        if (useDebug) {\n          Debug.enable('prisma-client')\n        }\n\n        if (internal.hooks) {\n          this._hooks = internal.hooks\n        }\n\n        let predefinedDatasources = config.sqliteDatasourceOverrides ?? []\n        predefinedDatasources = predefinedDatasources.map((d) => ({\n          name: d.name,\n          url: 'file:' + path.resolve(config.dirname, d.url),\n        }))\n\n        const inputDatasources = Object.entries(options.datasources || {})\n          .filter(([_, source]) => {\n            return source && source.url\n          })\n          .map(([name, { url }]: any) => ({ name, url }))\n\n        const datasources = mergeBy(\n          predefinedDatasources,\n          inputDatasources,\n          (source) => source.name,\n        )\n\n        const engineConfig = internal.engine || {}\n\n        if (options.errorFormat) {\n          this._errorFormat = options.errorFormat\n        } else if (process.env.NODE_ENV === 'production') {\n          this._errorFormat = 'minimal'\n        } else if (process.env.NO_COLOR) {\n          this._errorFormat = 'colorless'\n        } else {\n          this._errorFormat = 'colorless' // default errorFormat\n        }\n\n        const envFile = this.readEnv()\n\n        this._dmmf = new DMMFClass(config.document)\n\n        let cwd = path.resolve(config.dirname, config.relativePath)\n\n        if (!fs.existsSync(cwd)) {\n          cwd = config.dirname\n        }\n\n        const previewFeatures = config.generator?.previewFeatures ?? []\n\n        this._engineConfig = {\n          cwd,\n          enableDebugLogs: useDebug,\n          enableEngineDebugMode: engineConfig.enableEngineDebugMode,\n          datamodelPath: path.join(config.dirname, 'schema.prisma'),\n          prismaPath: engineConfig.binaryPath ?? undefined,\n          engineEndpoint: engineConfig.endpoint,\n          datasources,\n          generator: config.generator,\n          showColors: this._errorFormat === 'pretty',\n          logLevel: options.log && (getLogLevel(options.log) as any), // TODO\n          logQueries:\n            options.log &&\n            Boolean(\n              typeof options.log === 'string'\n                ? options.log === 'query'\n                : options.log.find((o) =>\n                  typeof o === 'string' ? o === 'query' : o.level === 'query',\n                ),\n            ),\n          env: envFile,\n          flags: [],\n          clientVersion: config.clientVersion,\n          enableExperimental: mapPreviewFeatures(previewFeatures),\n          useUds: internal.useUds,\n        }\n\n        const sanitizedEngineConfig = omit(this._engineConfig, [\n          'env',\n          'datasources',\n        ])\n        debug({ engineConfig: sanitizedEngineConfig })\n\n        this._engine = new NodeEngine(this._engineConfig)\n        this._fetcher = new PrismaClientFetcher(this, false, this._hooks)\n\n        if (options.log) {\n          for (const log of options.log) {\n            const level =\n              typeof log === 'string'\n                ? log\n                : log.emit === 'stdout'\n                  ? log.level\n                  : null\n            if (level) {\n              this.$on(level, (event) => {\n                const colorMap = {\n                  query: 'blue',\n                  info: 'cyan',\n                  warn: 'yellow',\n                  error: 'red',\n                }\n                console.error(\n                  chalk[colorMap[level]](`prisma:${level}`.padEnd(13)) +\n                  (event.message || event.query),\n                )\n              })\n            }\n          }\n        }\n\n        this._bootstrapClient()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private readEnv() {\n      const dotEnvPath = path.resolve(\n        config.dirname,\n        config.relativePath,\n        '.env',\n      )\n      if (fs.existsSync(dotEnvPath)) {\n        return dotenvExpand(dotenv.config({ path: dotEnvPath })).parsed\n      }\n\n      return {}\n    }\n    use(...args) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.use() is deprecated, please use prisma.$use() instead`,\n      )\n      return (this.$use as any)(...args)\n    }\n    $use(cb: Middleware)\n    $use(namespace: 'all', cb: Middleware)\n    $use(namespace: 'engine', cb: EngineMiddleware)\n    $use(\n      namespace: HookPoint | Middleware,\n      cb?: Middleware | EngineMiddleware,\n    ) {\n      if (typeof namespace === 'function') {\n        this._middlewares.push(namespace)\n      } else if (typeof namespace === 'string') {\n        if (namespace === 'all') {\n          this._middlewares.push(cb! as Middleware)\n        } else if (namespace === 'engine') {\n          this._engineMiddlewares.push(cb! as EngineMiddleware)\n        } else {\n          throw new Error(`Unknown middleware hook ${namespace}`)\n        }\n      } else {\n        throw new Error(`Invalid middleware ${namespace}`)\n      }\n    }\n    on(eventType: any, callback: (event: any) => void) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.on() is deprecated, please use prisma.$on() instead`,\n      )\n      return this.$on(eventType, callback)\n    }\n    $on(eventType: any, callback: (event: any) => void) {\n      if (eventType === 'beforeExit') {\n        this._engine.on('beforeExit', callback)\n      } else {\n        this._engine.on(eventType, (event) => {\n          const fields = event.fields\n          if (eventType === 'query') {\n            return callback({\n              timestamp: event.timestamp,\n              query: fields.query,\n              params: fields.params,\n              duration: fields.duration_ms,\n              target: event.target,\n            })\n          } else {\n            // warn, info, or error events\n            return callback({\n              timestamp: event.timestamp,\n              message: fields.message,\n              target: event.target,\n            })\n          }\n        })\n      }\n    }\n    connect() {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.connect() is deprecated, please use prisma.$connect() instead`,\n      )\n      return this.$connect()\n    }\n    async $connect() {\n      try {\n        return this._engine.start()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n    /**\n     * @private\n     */\n    async _runDisconnect() {\n      await this._engine.stop()\n      delete this._connectionPromise\n      this._engine = new NodeEngine(this._engineConfig)\n      delete this._disconnectionPromise\n      delete this._getConfigPromise\n    }\n    disconnect() {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.disconnect() is deprecated, please use prisma.$disconnect() instead`,\n      )\n      return this.$disconnect()\n    }\n    /**\n     * Disconnect from the database\n     */\n    async $disconnect() {\n      try {\n        return this._engine.stop()\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private async _getActiveProvider(): Promise<ConnectorType> {\n      const configResult = await this._engine.getConfig()\n      return configResult.datasources[0].activeProvider!\n    }\n\n    executeRaw(stringOrTemplateStringsArray, ...values) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.executeRaw() is deprecated, please use prisma.$executeRaw() instead`,\n      )\n      return this.$executeRaw(stringOrTemplateStringsArray, ...values)\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    private async $executeRawInternal(stringOrTemplateStringsArray, ...values) {\n      let query = ''\n      let parameters: any = undefined\n\n      const activeProvider = await this._getActiveProvider()\n\n      if (typeof stringOrTemplateStringsArray === 'string') {\n        // If this was called as prisma.$executeRaw(<SQL>, [...values]), assume it is a pre-prepared SQL statement, and forward it without any changes\n        query = stringOrTemplateStringsArray\n        parameters = {\n          values: serializeRawParameters(values || []),\n          __prismaRawParamaters__: true,\n        }\n      } else if (Array.isArray(stringOrTemplateStringsArray)) {\n        // If this was called as prisma.$executeRaw`<SQL>`, try to generate a SQL prepared statement\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.sql\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'postgresql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.text\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'sqlserver': {\n            query = mssqlPreparedStatement(stringOrTemplateStringsArray)\n            parameters = {\n              values: serializeRawParameters(values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n        }\n      } else {\n        // If this was called as prisma.raw(sql`<SQL>`), use prepared statements from sql-template-tag\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).sql\n            break\n          case 'postgresql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).text\n            break\n          case 'sqlserver':\n            query = mssqlPreparedStatement(\n              (stringOrTemplateStringsArray as sqlTemplateTag.Sql).strings,\n            )\n            break\n        }\n        parameters = {\n          values: serializeRawParameters(\n            (stringOrTemplateStringsArray as sqlTemplateTag.Sql).values,\n          ),\n          __prismaRawParamaters__: true,\n        }\n      }\n\n      if (parameters?.values) {\n        debug(`prisma.$executeRaw(${query}, ${parameters.values})`)\n      } else {\n        debug(`prisma.$executeRaw(${query})`)\n      }\n\n      const args = { query, parameters }\n\n      debug(`Prisma Client call:`)\n      return this._request({\n        args,\n        clientMethod: 'executeRaw',\n        dataPath: [],\n        action: 'executeRaw',\n        callsite: this._getCallsite(),\n        runInTransaction: false,\n      })\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    $executeRaw(stringOrTemplateStringsArray, ...values) {\n      try {\n        const promise = this.$executeRawInternal(stringOrTemplateStringsArray, ...values)\n          ; (promise as any).isExecuteRaw = true\n        return promise\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _getCallsite() {\n      if (this._errorFormat !== 'minimal') {\n        return new Error().stack\n      }\n      return undefined\n    }\n\n    queryRaw(stringOrTemplateStringsArray, ...args) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.queryRaw() is deprecated, please use prisma.$queryRaw() instead`,\n      )\n      return this.$queryRaw(stringOrTemplateStringsArray, ...args)\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    private async $queryRawInternal(\n      stringOrTemplateStringsArray:\n        | string\n        | TemplateStringsArray\n        | sqlTemplateTag.Sql,\n      ...values: any[]\n    ) {\n      let query = ''\n      let parameters: any = undefined\n\n      const activeProvider = await this._getActiveProvider()\n\n      if (typeof stringOrTemplateStringsArray === 'string') {\n        // If this was called as prisma.$queryRaw(<SQL>, [...values]), assume it is a pre-prepared SQL statement, and forward it without any changes\n        query = stringOrTemplateStringsArray\n        parameters = {\n          values: serializeRawParameters(values || []),\n          __prismaRawParamaters__: true,\n        }\n      } else if (Array.isArray(stringOrTemplateStringsArray)) {\n        // If this was called as prisma.$queryRaw`<SQL>`, try to generate a SQL prepared statement\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.sql\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'postgresql': {\n            let queryInstance = sqlTemplateTag.sqltag(\n              stringOrTemplateStringsArray as any,\n              ...values,\n            )\n\n            query = queryInstance.text\n            parameters = {\n              values: serializeRawParameters(queryInstance.values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n\n          case 'sqlserver': {\n            query = mssqlPreparedStatement(stringOrTemplateStringsArray)\n            parameters = {\n              values: serializeRawParameters(values),\n              __prismaRawParamaters__: true,\n            }\n            break\n          }\n        }\n      } else {\n        // If this was called as prisma.raw(sql`<SQL>`), use prepared statements from sql-template-tag\n        switch (activeProvider) {\n          case 'sqlite':\n          case 'mysql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).sql\n            break\n          case 'postgresql':\n            query = (stringOrTemplateStringsArray as sqlTemplateTag.Sql).text\n            break\n          case 'sqlserver':\n            query = mssqlPreparedStatement(\n              (stringOrTemplateStringsArray as sqlTemplateTag.Sql).strings,\n            )\n            break\n        }\n        parameters = {\n          values: serializeRawParameters(\n            (stringOrTemplateStringsArray as sqlTemplateTag.Sql).values,\n          ),\n          __prismaRawParamaters__: true,\n        }\n      }\n\n      if (parameters?.values) {\n        debug(`prisma.queryRaw(${query}, ${parameters.values})`)\n      } else {\n        debug(`prisma.queryRaw(${query})`)\n      }\n\n      const args = { query, parameters }\n\n      debug(`Prisma Client call:`)\n      return this._request({\n        args,\n        clientMethod: 'queryRaw',\n        dataPath: [],\n        action: 'queryRaw',\n        callsite: this._getCallsite(),\n        runInTransaction: false,\n      })\n    }\n\n    /**\n     * Executes a raw query. Always returns a number\n     */\n    $queryRaw(stringOrTemplateStringsArray, ...values) {\n      try {\n        const promise = this.$queryRawInternal(stringOrTemplateStringsArray, ...values)\n          ; (promise as any).isQueryRaw = true\n        return promise\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    async __internal_triggerPanic(fatal: boolean) {\n      if (!this._engineConfig.enableEngineDebugMode) {\n        throw new Error(`In order to use .__internal_triggerPanic(), please enable the debug mode like so:\nnew PrismaClient({\n  __internal: {\n    engine: {\n      enableEngineDebugMode: true\n    }\n  }\n})`)\n      }\n\n      const query = 'SELECT 1'\n\n      const headers: Record<string, string> = fatal\n        ? { 'X-DEBUG-FATAL': '1' }\n        : { 'X-DEBUG-NON-FATAL': '1' }\n\n      return this._request({\n        action: 'queryRaw',\n        args: {\n          query,\n          parameters: undefined,\n        },\n        clientMethod: 'queryRaw',\n        dataPath: [],\n        runInTransaction: false,\n        headers,\n        callsite: this._getCallsite(),\n      })\n    }\n\n    transaction(promises) {\n      console.warn(\n        `${chalk.yellow(\n          'warn',\n        )} prisma.transaction() is deprecated, please use prisma.$transaction() instead`,\n      )\n      return this.$transaction(promises)\n    }\n\n    private async $transactionInternal(promises: Array<any>): Promise<any> {\n      if (config.generator?.previewFeatures?.includes('transactionApi')) {\n        for (const p of promises) {\n          if (!p) {\n            throw new Error(\n              `All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`,\n            )\n          }\n          if (p?.isQueryRaw) {\n            throw new Error(`$queryRaw is not yet supported within $transaction.\nPlease report in https://github.com/prisma/prisma/issues/3828 if you need this feature.`)\n          }\n          if (p?.isExecuteRaw) {\n            throw new Error(`$executeRaw is not yet supported within $transaction.\nPlease report in https://github.com/prisma/prisma/issues/3828 if you need this feature`)\n          }\n          if (\n            !p.requestTransaction ||\n            typeof p.requestTransaction !== 'function'\n          ) {\n            throw new Error(\n              `All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`,\n            )\n          }\n        }\n        return Promise.all(promises.map((p) => p.requestTransaction()))\n      } else {\n        throw new Error(\n          `In order to use the .transaction() api, please enable 'previewFeatures = \"transactionApi\" in your schema.`,\n        )\n      }\n    }\n\n    async $transaction(promises: Array<any>): Promise<any> {\n      try {\n        return this.$transactionInternal(promises)\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _request(internalParams: InternalRequestParams) {\n      try {\n        const resource = new AsyncResource('prisma-client-request')\n        if (this._middlewares.length > 0) {\n          // https://perf.link/#eyJpZCI6Img4bmd0anp5eGxrIiwidGl0bGUiOiJGaW5kaW5nIG51bWJlcnMgaW4gYW4gYXJyYXkgb2YgMTAwMCIsImJlZm9yZSI6ImNvbnN0IGRhdGEgPSB7XG4gIG9wZXJhdGlvbjogXCJxdWVyeVwiLFxuICByb290RmllbGQ6IFwiZmluZE1hbnlVc2VyXCIsXG4gIGFyZ3M6IHtcbiAgICB3aGVyZTogeyBpZDogeyBndDogNSB9IH1cbiAgfSxcbiAgZGF0YVBhdGg6IFtdLFxuICBjbGllbnRNZXRob2Q6ICd1c2VyLmZpbmRNYW55J1xufSIsInRlc3RzIjpbeyJuYW1lIjoiZm9yIGluIiwiY29kZSI6ImNvbnN0IG5ld0RhdGEgPSB7fVxuZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICBpZiAoa2V5ICE9PSAnY2xpZW50TWV0aG9kJykge1xuICAgIG5ld0RhdGFba2V5XSA9IGRhdGFba2V5XVxuICB9XG59IiwicnVucyI6WzU1MzAwMCw0OTAwMDAsMzQ0MDAwLDYyNDAwMCwxMzkxMDAwLDEyMjQwMDAsMTA2NDAwMCwxMjE3MDAwLDc0MDAwLDM3MzAwMCw5MDUwMDAsNTM3MDAwLDE3MDYwMDAsOTAzMDAwLDE0MjUwMDAsMTMxMjAwMCw3NjkwMDAsMTM0NTAwMCwxOTQ4MDAwLDk5MDAwMCw5MDAwMDAsMTM0ODAwMCwxMDk2MDAwLDM4NjAwMCwxNTE3MDAwLDE5MzYwMDAsMTAwMCwyMTM0MDAwLDEzMjgwMDAsODI5MDAwLDE1ODYwMDAsMTc2MzAwMCw1MDgwMDAsOTg2MDAwLDE5NDkwMDAsMjEwODAwMCwxNjA4MDAwLDIyNDAwMCwxOTAyMDAwLDEyNjgwMDAsMjEzNDAwMCwxNzEwMDAwLDEzNzIwMDAsMjExMDAwMCwxNzgwMDAwLDc3NzAwMCw1NzgwMDAsNDAwMCw4OTAwMDAsMTEwMTAwMCwxNTk0MDAwLDE3ODAwMDAsMzU0MDAwLDU0NDAwMCw4MjQwMDAsNzEwMDAwLDg0OTAwMCwxNjQwMDAwLDE5ODQwMDAsNzAzMDAwLDg4MjAwMCw4NTAwMDAsMTA2MDAwLDMwMzAwMCwxMzMwMDAsNjA4MDAwLDIxMzQwMDAsNTUxMDAwLDc0MjAwMCwyMDcwMDAsMTU3NTAwMCwxMzQwMDAsNDAwMCwxMDAwLDQ5NDAwMCwyNTAwMDAsMTQwMjAwMCw2OTgwMDAsNTgxMDAwLDQ4MDAwMCwyMDMwMDAsMTY4MzAwMCwxNjcxMDAwLDEyNDAwMDAsMTk1NjAwMCwzMDUwMDAsODkwMDAsNjUzMDAwLDE3MDgwMDAsMTYwMTAwMCwxOTg0MDAwLDg4ODAwMCwyMTAwMDAwLDE5NzUwMDAsNTM2MDAwLDU3NTAwMCwyMTM0MDAwLDEwMTcwMDAsMTI5NzAwMCw3NTYwMDBdLCJvcHMiOjEwNDUxNTB9LHsibmFtZSI6IkRlY29uc3RydWN0b3IiLCJjb2RlIjoiY29uc3QgeyBjbGllbnRNZXRob2QsIC4uLnJlc3QgfSA9IGRhdGEiLCJydW5zIjpbMjE0MDAwLDUxMDAwLDg2NDAwMCw3MjcwMDAsNDMxMDAwLDIyMDAwMCwzOTAwMDAsODQxMDAwLDIyOTAwMCw3MjIwMDAsNDEzMDAwLDYwODAwMCwyOTgwMDAsMzY4MDAwLDg2NDAwMCw5MjQwMDAsMTI4MDAwLDU1MzAwMCw4ODAwMDAsNTQ1MDAwLDc3NTAwMCw0MzAwMDAsMjM3MDAwLDc4NjAwMCw1NTUwMDAsNTI2MDAwLDMyNzAwMCw2MzAwMCw5MTIwMDAsMTgxMDAwLDMzMTAwMCw0MzAwMCwyMjUwMDAsNTQ3MDAwLDgyMjAwMCw3OTMwMDAsMTA1NzAwMCw1NjAwMCwyNzUwMDAsMzkzMDAwLDgwNTAwMCw5MzAwMCw3NjYwMDAsODM0MDAwLDUwMzAwMCw4MDAwMCwyMzgwMDAsNDY0MDAwLDU2NDAwMCw3MzAwMDAsOTU1MDAwLDgwOTAwMCwyMDMwMDAsNDEzMDAwLDM0NDAwMCw1MDIwMDAsNjEzMDAwLDEwMDAwMCw0MzIwMDAsNjcwMDAwLDQ1MzAwMCw4OTEwMDAsNTUwMDAsMjMwMDAwLDM5MTAwMCw3NTQwMDAsMTEyMjAwMCw3NjIwMDAsMzU3MDAwLDQ3MDAwLDc5MjAwMCwzNTQwMDAsMTA4MDAwMCwxNjAwMCwxODgwMDAsMTQxMDAwLDIxMDAwMCw2MDcwMDAsOTAyMDAwLDgyNTAwMCwxOTAwMDAsMjMzMDAwLDI4MzAwMCwyMzgwMDAsNjk2MDAwLDc2ODAwMCw3NTgwMDAsMTk0MDAwLDI3OTAwMCwyMjMwMDAsMjM4MDAwLDkzNDAwMCw2MDUwMDAsMTcwMDAsMjEwMDAwLDMyMjAwMCwxMDM0MDAwLDgxMjAwMCw0NDYwMDAsNjMxMDAwXSwib3BzIjo0OTAxMDB9LHsibmFtZSI6ImRlbGV0ZSIsImNvZGUiOiJjb25zdCB7IGNsaWVudE1ldGhvZCB9ID0gZGF0YVxuZGVsZXRlIGRhdGEuY2xpZW50TWV0aG9kIiwicnVucyI6WzI3NjIwMDAsNjIyMDAwLDEwNTcwMDAsMzIzMTAwMCwzNDQ2MDAwLDIwNzMwMDAsMzM4MjAwMCwyNzA0MDAwLDM4ODEwMDAsMTIwMTAwMCwzNzk3MDAwLDI1OTAwMCwxMDI4MDAwLDI1MTgwMDAsMjEwMjAwMCwxOTczMDAwLDM0MTIwMDAsMzU4MDAwLDExNDcwMDAsMTA3NDAwMCwzMTk1MDAwLDM2NzUwMDAsNTQ3MDAwLDIwNzkwMDAsMjc0NTAwMCwyNDE1MDAwLDIxOTAwMCwzNzM3MDAwLDM2OTIwMDAsMTY0MDAwLDI0MzMwMDAsNjQzMDAwLDcxODAwMCw0Mzg2MDAwLDE3MDIwMDAsMTAyNDAwMCw1NjUwMDAsNDIxOTAwMCwxMTk3MDAwLDE4MzkwMDAsMzgyMTAwMCwxMTUyMDAwLDg1MzAwMCwxMzczMDAwLDI5NTAwMCwxNDg5MDAwLDE0MjEwMDAsMjcyNDAwMCw1MDYxMDAwLDI2NTcwMDAsMjYzNzAwMCwyOTkwMDAsMjE1NzAwMCwxNTAxMDAwLDM2OTAwMDAsMzU3OTAwMCw0MjE5MDAwLDI4NTgwMDAsNTI0MzAwMCwxNTA0MDAwLDEyMTMwMDAsMjM4NDAwMCw3NzgwMDAsMjgyNjAwMCwxNzQ5MDAwLDM2MjAwMCwyNzEzMDAwLDMzODYwMDAsMzE2NjAwMCwxNTMwMDAsNzk0MDAwLDMyMTcwMDAsMjA4MjAwMCw0MTUwMDAsMzMyMDAwMCwyMTA1MDAwLDE1NzYwMDAsMjUxMDAwLDIzMjkwMDAsOTI1MDAwLDM3MTUwMDAsNjkyMDAwLDE5MDIwMDAsMjA0NzAwMCwyNTM5MDAwLDIwMjkwMDAsMzE3OTAwMCwyMTA2MDAwLDg5NTAwMCwxNTUwMDAwLDYwNzAwMCw0MTA1MDAwLDM0ODMwMDAsMzcxNTAwMCw0OTQwMDAwLDIyODAwMCw0MDI2MDAwLDE2MTYwMDAsMzMxNDAwMCwyNDIyMDAwXSwib3BzIjoyMTY2MDgwfSx7Im5hbWUiOiJDcmVhdGUgbmV3IG9iamVjdCIsImNvZGUiOiJjb25zdCBuZXdEYXRhID0ge1xuICBvcGVyYXRpb246IGRhdGEub3BlcmF0aW9uLFxuICByb290RmllbGQ6IGRhdGEucm9vdEZpZWxkLFxuICBhcmdzOiBkYXRhLmFyZ3MsXG4gIGRhdGFQYXRoOiBkYXRhLmRhdGFQYXRoXG59IiwicnVucyI6WzcwNTAwMCwxMTAwMDAsMzI3NTAwMCwxOTgwMDAsMjE5OTAwMCw0MzYwMDAsODI4MDAwLDI5MjcwMDAsNzI0MDAwLDI1NDAwMCwyOTgzMDAwLDI2NzIwMDAsMjUzMDAwLDI4MjcwMDAsMzA0ODAwMCwyOTA3MDAwLDM0OTkwMDAsMjY1OTAwMCwzODIyMDAwLDI3NzcwMDAsMzc5NzAwMCw4MDAwMDAsNDM1MDAwLDExOTMwMDAsMTAwMDAsMTQ0MDAwMCw3NTcwMDAsMTMyMDAwMCwzMjIwMDAsMjA3MDAwLDM2ODAwMDAsMzkxMTAwMCwzMjQxMDAwLDExMDcwMDAsNDM4MDAwLDMwNDQwMDAsMTA3NjAwMCwyMTAwMDAsNDIxOTAwMCwzNzQ4MDAwLDQwNjcwMDAsNzc0MDAwLDYzMDAwLDMyMTAwMCwzMDQ4MDAwLDMxMjgwMDAsMTg3MTAwMCwzNTkxMDAwLDI0MzcwMDAsNjcxMDAwLDc5OTAwMCwxMTUzMDAwLDIxMTMwMDAsOTUwMDAsNTg3MDAwLDYyMzAwMCwxMzEzMDAwLDMxNTgwMDAsMzMyNzAwMCwxNTkwMDAsNDg4MDAwLDIxMTAwMCwxMjk0MDAwLDExNTcwMDAsNDA0MDAwLDM2MjMwMDAsMjY4NDAwMCw4NzkwMDAsMjE4NTAwMCwxNTkyMDAwLDM2ODcwMDAsMjI0ODAwMCwyMjE4MDAwLDE3NDMwMDAsNzg4MDAwLDQwODYwMDAsMjExNTAwMCwzOTE0MDAwLDM5MjgwMDAsNDM3MjAwMCwxOTkwMDAsMzc1MzAwMCwzNjQ3MDAwLDE2MjcwMDAsMTQ5OTAwMCwxODQyMDAwLDIxMjkwMDAsNDAwMCwxMjIzMDAwLDI4NjMwMDAsMzgzNDAwMCwzNjk0MDAwLDYzNjAwMCw0MjQ3MDAwLDQwMjIwMDAsMTAwMDAsMTcxNDAwMCwxNzUwMDAwLDI5MDEwMDAsMTM0NjAwMF0sIm9wcyI6MTkzOTEyMH1dLCJ1cGRhdGVkIjoiMjAyMC0wNy0xNVQxMTowMDo1Ny45MzhaIn0%3D\n          const params: MiddlewareParams = {\n            args: internalParams.args,\n            dataPath: internalParams.dataPath,\n            runInTransaction: internalParams.runInTransaction,\n            action: internalParams.action,\n            model: internalParams.model,\n          }\n          return resource.runInAsyncScope(() =>\n            this._requestWithMiddlewares(\n              params,\n              this._middlewares.slice(),\n              internalParams.clientMethod,\n              internalParams.callsite,\n              internalParams.headers,\n            ),\n          )\n        }\n\n        return resource.runInAsyncScope(() =>\n          this._executeRequest(internalParams),\n        )\n      } catch (e) {\n        e.clientVersion = this._clientVersion\n        throw e\n      }\n    }\n\n    private _requestWithMiddlewares(\n      params: MiddlewareParams,\n      middlewares: Middleware[],\n      clientMethod: string,\n      callsite?: string,\n      headers?: Record<string, string>,\n    ) {\n      const middleware = middlewares.shift()\n      if (middleware) {\n        return middleware(params, (params2) =>\n          this._requestWithMiddlewares(\n            params2,\n            middlewares,\n            clientMethod,\n            callsite,\n          ),\n        )\n      }\n\n      // No, we won't copy the whole object here just to make it easier to do TypeScript\n      // as it would be much slower\n      ; (params as InternalRequestParams).clientMethod = clientMethod\n        ; (params as InternalRequestParams).callsite = callsite\n        ; (params as InternalRequestParams).headers = headers\n\n      return this._executeRequest(params as InternalRequestParams)\n    }\n\n    private _executeRequest({\n      args,\n      clientMethod,\n      dataPath,\n      callsite,\n      runInTransaction,\n      action,\n      model,\n      headers,\n    }: InternalRequestParams) {\n      if (action !== 'executeRaw' && action !== 'queryRaw' && !model) {\n        throw new Error(`Model missing for action ${action}`)\n      }\n\n      if ((action === 'executeRaw' || action === 'queryRaw') && model) {\n        throw new Error(\n          `executeRaw and queryRaw can't be executed on a model basis. The model ${model} has been provided`,\n        )\n      }\n\n      let rootField: string | undefined\n      const operation = actionOperationMap[action]\n\n      if (action === 'executeRaw' || action === 'queryRaw') {\n        rootField = action\n      }\n\n      // TODO: Replace with lookup map for speedup\n      let mapping\n      if (model) {\n        mapping = this._dmmf.mappingsMap[model]\n        if (!mapping) {\n          throw new Error(`Could not find mapping for model ${model}`)\n        }\n\n        rootField = mapping[action]\n      }\n\n      if (operation !== 'query' && operation !== 'mutation') {\n        throw new Error(`Invalid operation ${operation} for action ${action}`)\n      }\n\n      const field = this._dmmf.rootFieldMap[rootField!]\n\n      if (!field) {\n        throw new Error(\n          `Could not find rootField ${rootField} for action ${action} for model ${model} on rootType ${operation}`,\n        )\n      }\n\n      const { isList } = field.outputType\n      const typeName = getOutputTypeName(field.outputType.type)\n\n      let document = makeDocument({\n        dmmf: this._dmmf,\n        rootField: rootField!,\n        rootTypeName: operation,\n        select: args,\n      })\n\n      document.validate(args, false, clientMethod, this._errorFormat, callsite)\n\n      document = transformDocument(document)\n\n      // as printJsonWithErrors takes a bit of compute\n      // we only want to do it, if debug is enabled for 'prisma-client'\n      if (Debug.enabled('prisma-client')) {\n        const query = String(document)\n        debug(`Prisma Client call:`)\n        debug(\n          `prisma.${clientMethod}(${printJsonWithErrors({\n            ast: args,\n            keyPaths: [],\n            valuePaths: [],\n            missingItems: [],\n          })})`,\n        )\n        debug(`Generated request:`)\n        debug(query + '\\n')\n      }\n\n      return this._fetcher.request({\n        document,\n        clientMethod,\n        typeName,\n        dataPath,\n        isList,\n        rootField: rootField!,\n        callsite,\n        showColors: this._errorFormat === 'pretty',\n        args,\n        engineHook: this._engineMiddlewares[0],\n        runInTransaction,\n        headers,\n      })\n    }\n\n    private _bootstrapClient() {\n      const clients = this._dmmf.mappings.reduce((acc, mapping) => {\n        const lowerCaseModel = lowerCase(mapping.model)\n        const model = this._dmmf.modelMap[mapping.model]\n\n        if (!model) {\n          throw new Error(`Invalid mapping ${mapping.model}, can't find model`)\n        }\n\n        const prismaClient = ({\n          operation,\n          actionName,\n          args,\n          dataPath,\n          modelName,\n        }) => {\n          dataPath = dataPath ?? []\n\n          const clientMethod = `${lowerCaseModel}.${actionName}`\n\n          let requestPromise: Promise<any>\n          const callsite = this._getCallsite()\n\n          const requestModelName = modelName ?? model.name\n\n          const clientImplementation = {\n            then: (onfulfilled, onrejected) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.then(onfulfilled, onrejected)\n            },\n            requestTransaction: () => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: true,\n                })\n              }\n\n              return requestPromise\n            },\n            catch: (onrejected) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.catch(onrejected)\n            },\n            finally: (onfinally) => {\n              if (!requestPromise) {\n                requestPromise = this._request({\n                  args,\n                  dataPath,\n                  action: actionName,\n                  model: requestModelName,\n                  clientMethod,\n                  callsite,\n                  runInTransaction: false,\n                })\n              }\n\n              return requestPromise.finally(onfinally)\n            },\n          }\n\n          // add relation fields\n          for (const field of model.fields.filter((f) => f.kind === 'object')) {\n            clientImplementation[field.name] = (fieldArgs) => {\n              const prefix = dataPath.includes('select')\n                ? 'select'\n                : dataPath.includes('include')\n                  ? 'include'\n                  : 'select'\n              const newDataPath = [...dataPath, prefix, field.name]\n              const newArgs = deepSet(args, newDataPath, fieldArgs || true)\n\n              return clients[field.type]({\n                operation,\n                actionName,\n                args: newArgs,\n                dataPath: newDataPath,\n                isList: field.isList,\n                /*\n                 * necessary for user.posts() calls -> the original model name needs to be preserved\n                 */\n                modelName: modelName || model.name,\n              })\n            }\n          }\n\n          return clientImplementation\n        }\n\n        acc[model.name] = prismaClient\n\n        return acc\n      }, {})\n\n      for (const mapping of this._dmmf.mappings) {\n        const lowerCaseModel = lowerCase(mapping.model)\n\n        const denyList = {\n          model: true,\n          plural: true,\n          aggregate: true,\n        }\n\n        const delegate: any = Object.entries(mapping).reduce(\n          (acc, [actionName, rootField]) => {\n            if (!denyList[actionName]) {\n              const operation = getOperation(actionName as any)\n              acc[actionName] = (args) =>\n                clients[mapping.model]({\n                  operation,\n                  actionName,\n                  args,\n                })\n            }\n\n            return acc\n          },\n          {},\n        )\n\n        delegate.count = (args) => {\n          return clients[mapping.model]({\n            operation: 'query',\n            actionName: `aggregate`,\n            args: args\n              ? {\n                ...args,\n                select: { count: true },\n              }\n              : undefined,\n            dataPath: ['count'],\n          })\n        }\n\n        delegate.aggregate = (args) => {\n          /**\n           * avg, count, sum, min, max need to go into select\n           * For speed reasons we can go with \"for in \"\n           */\n          const select = Object.entries(args).reduce((acc, [key, value]) => {\n            if (aggregateKeys[key]) {\n              if (!acc.select) {\n                acc.select = {}\n              }\n              // `count` doesn't have a sub-selection\n              if (key === 'count') {\n                acc.select[key] = value\n              } else {\n                acc.select[key] = { select: value }\n              }\n            } else {\n              acc[key] = value\n            }\n            return acc\n          }, {} as any)\n\n          return clients[mapping.model]({\n            operation: 'query',\n            actionName: 'aggregate', // actionName is just cosmetics \uD83D\uDC85\uD83C\uDFFD\n            rootField: mapping.aggregate,\n            args: select,\n            dataPath: [],\n          })\n        }\n\n        this[lowerCaseModel] = delegate\n      }\n    }\n  }\n\n  return NewPrismaClient\n}\n\nexport class PrismaClientFetcher {\n  prisma: any\n  debug: boolean\n  hooks: any\n  dataloader: Dataloader<{\n    document: Document\n    runInTransaction?: boolean\n    headers?: Record<string, string>\n  }>\n\n  constructor(prisma, enableDebug = false, hooks?: any) {\n    this.prisma = prisma\n    this.debug = enableDebug\n    this.hooks = hooks\n    this.dataloader = new Dataloader({\n      batchLoader: async (requests) => {\n        const queries = requests.map((r) => String(r.document))\n        const runTransaction = requests[0].runInTransaction\n        return this.prisma._engine.requestBatch(queries, runTransaction)\n      },\n      singleLoader: async (request) => {\n        const query = String(request.document)\n        return this.prisma._engine.request(query, request.headers)\n      },\n      batchBy: (request) => {\n        if (request.runInTransaction) {\n          return 'transaction-batch'\n        }\n\n        if (!request.document.children[0].name.startsWith('findOne')) {\n          return null\n        }\n\n        const selectionSet = request.document.children[0].children!.join(',')\n\n        const args = request.document.children[0].args?.args\n          .map((a) => {\n            if (a.value instanceof Args) {\n              return a.key + '-' + a.value.args.map((a) => a.key).join(',')\n            }\n            return a.key\n          })\n          .join(',')\n\n        return `${request.document.children[0].name}|${args}|${selectionSet}`\n      },\n    })\n  }\n\n  async request({\n    document,\n    dataPath = [],\n    rootField,\n    typeName,\n    isList,\n    callsite,\n    clientMethod,\n    runInTransaction,\n    showColors,\n    engineHook,\n    args,\n    headers,\n  }: {\n    document: Document\n    dataPath: string[]\n    rootField: string\n    typeName: string\n    isList: boolean\n    clientMethod: string\n    callsite?: string\n    runInTransaction?: boolean\n    showColors?: boolean\n    engineHook?: EngineMiddleware\n    args: any\n    headers?: Record<string, string>\n  }) {\n    if (this.hooks && this.hooks.beforeRequest) {\n      const query = String(document)\n      this.hooks.beforeRequest({\n        query,\n        path: dataPath,\n        rootField,\n        typeName,\n        document,\n        isList,\n        clientMethod,\n        args,\n      })\n    }\n    try {\n      /**\n       * If there's an engine hook, use it here\n       */\n      let data, elapsed\n      if (engineHook) {\n        const result = await engineHook(\n          {\n            document,\n            runInTransaction,\n          },\n          (params) => this.dataloader.request(params),\n        )\n        data = result.data\n        elapsed = result.elapsed\n      } else {\n        const result = await this.dataloader.request({\n          document,\n          runInTransaction,\n          headers,\n        })\n        data = result.data\n        elapsed = result.elapsed\n      }\n\n      /**\n       * Unpack\n       */\n      const unpackResult = this.unpack(document, data, dataPath, rootField)\n      if (process.env.PRISMA_CLIENT_GET_TIME) {\n        return { data: unpackResult, elapsed }\n      }\n      return unpackResult\n    } catch (e) {\n      debug(e)\n      let message = e.message\n      if (callsite) {\n        const { stack } = printStack({\n          callsite,\n          originalMethod: clientMethod,\n          onUs: e.isPanic,\n          showColors,\n        })\n        message = stack + '\\n  ' + e.message\n      }\n\n      message = this.sanitizeMessage(message)\n      // TODO: Do request with callsite instead, so we don't need to rethrow\n      if (e.code) {\n        throw new PrismaClientKnownRequestError(\n          message,\n          e.code,\n          this.prisma._clientVersion,\n          e.meta,\n        )\n      } else if (e.isPanic) {\n        throw new PrismaClientRustPanicError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientUnknownRequestError) {\n        throw new PrismaClientUnknownRequestError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientInitializationError) {\n        throw new PrismaClientInitializationError(\n          message,\n          this.prisma._clientVersion,\n        )\n      } else if (e instanceof PrismaClientRustPanicError) {\n        throw new PrismaClientRustPanicError(\n          message,\n          this.prisma._clientVersion,\n        )\n      }\n\n      e.clientVersion = this.prisma._clientVersion\n\n      throw e\n    }\n  }\n\n  sanitizeMessage(message) {\n    if (this.prisma._errorFormat && this.prisma._errorFormat !== 'pretty') {\n      return stripAnsi(message)\n    }\n    return message\n  }\n  unpack(document, data, path, rootField) {\n    if (data.data) {\n      data = data.data\n    }\n    const getPath: any[] = []\n    if (rootField) {\n      getPath.push(rootField)\n    }\n    getPath.push(...path.filter((p) => p !== 'select' && p !== 'include'))\n    return unpack({ document, data, path: getPath })\n  }\n}\n\nexport function getOperation(action: DMMF.ModelAction): 'query' | 'mutation' {\n  if (\n    action === DMMF.ModelAction.findMany ||\n    action === DMMF.ModelAction.findOne ||\n    action === DMMF.ModelAction.findFirst\n  ) {\n    return 'query'\n  }\n  return 'mutation'\n}\n"],
  "mappings": "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",
  "names": []
}
